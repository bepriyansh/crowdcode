"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codeium";
exports.ids = ["vendor-chunks/@codeium"];
exports.modules = {

/***/ "(ssr)/./node_modules/@codeium/react-code-editor/dist/esm/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@codeium/react-code-editor/dist/esm/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CodeiumEditor: () => (/* binding */ CodeiumEditor),\n/* harmony export */   Document: () => (/* binding */ Document$1),\n/* harmony export */   Language: () => (/* binding */ Language)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ CodeiumEditor,Document,Language auto */ if (false) {}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Assert that condition is truthy or throw error (with message)\n */ function assert(condition, msg) {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\nconst FLOAT32_MAX = 3.4028234663852886e38, FLOAT32_MIN = -3.4028234663852886e38, UINT32_MAX = 0xffffffff, INT32_MAX = 0x7fffffff, INT32_MIN = -0x80000000;\n/**\n * Assert a valid signed protobuf 32-bit integer.\n */ function assertInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid int 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error(\"invalid int 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid unsigned protobuf 32-bit integer.\n */ function assertUInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid uint 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error(\"invalid uint 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid protobuf float value.\n */ function assertFloat32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid float 32: \" + typeof arg);\n    if (!Number.isFinite(arg)) return;\n    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error(\"invalid float 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst enumTypeSymbol = Symbol(\"@bufbuild/protobuf/enum-type\");\n/**\n * Get reflection information from a generated enum.\n * If this function is called on something other than a generated\n * enum, it raises an error.\n */ function getEnumType(enumObject) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\n    const t = enumObject[enumTypeSymbol];\n    assert(t, \"missing enum type on enum object\");\n    return t; // eslint-disable-line @typescript-eslint/no-unsafe-return\n}\n/**\n * Sets reflection information on a generated enum.\n */ function setEnumType(enumObject, typeName, values, opt) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v)=>({\n            no: v.no,\n            name: v.name,\n            localName: enumObject[v.no]\n        })));\n}\n/**\n * Create a new EnumType with the given values.\n */ function makeEnumType(typeName, values, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n_opt) {\n    const names = Object.create(null);\n    const numbers = Object.create(null);\n    const normalValues = [];\n    for (const value of values){\n        // We do not surface options at this time\n        // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};\n        const n = normalizeEnumValue(value);\n        normalValues.push(n);\n        names[value.name] = n;\n        numbers[value.no] = n;\n    }\n    return {\n        typeName,\n        values: normalValues,\n        // We do not surface options at this time\n        // options: opt?.options ?? Object.create(null),\n        findName (name) {\n            return names[name];\n        },\n        findNumber (no) {\n            return numbers[no];\n        }\n    };\n}\n/**\n * Create a new enum object with the given values.\n * Sets reflection information.\n */ function makeEnum(typeName, values, opt) {\n    const enumObject = {};\n    for (const value of values){\n        const n = normalizeEnumValue(value);\n        enumObject[n.localName] = n.no;\n        enumObject[n.no] = n.localName;\n    }\n    setEnumType(enumObject, typeName, values);\n    return enumObject;\n}\nfunction normalizeEnumValue(value) {\n    if (\"localName\" in value) {\n        return value;\n    }\n    return Object.assign(Object.assign({}, value), {\n        localName: value.name\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Message is the base class of every message, generated, or created at\n * runtime.\n *\n * It is _not_ safe to extend this class. If you want to create a message at\n * run time, use proto3.makeMessageType().\n */ class Message {\n    /**\n     * Compare with a message of the same type.\n     */ equals(other) {\n        return this.getType().runtime.util.equals(this.getType(), this, other);\n    }\n    /**\n     * Create a deep copy.\n     */ clone() {\n        return this.getType().runtime.util.clone(this);\n    }\n    /**\n     * Parse from binary data, merging fields.\n     *\n     * Repeated fields are appended. Map entries are added, overwriting\n     * existing keys.\n     *\n     * If a message field is already present, it will be merged with the\n     * new data.\n     */ fromBinary(bytes, options) {\n        const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);\n        format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);\n        return this;\n    }\n    /**\n     * Parse a message from a JSON value.\n     */ fromJson(jsonValue, options) {\n        const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);\n        format.readMessage(type, jsonValue, opt, this);\n        return this;\n    }\n    /**\n     * Parse a message from a JSON string.\n     */ fromJsonString(jsonString, options) {\n        let json;\n        try {\n            json = JSON.parse(jsonString);\n        } catch (e) {\n            throw new Error(`cannot decode ${this.getType().typeName} from JSON: ${e instanceof Error ? e.message : String(e)}`);\n        }\n        return this.fromJson(json, options);\n    }\n    /**\n     * Serialize the message to binary data.\n     */ toBinary(options) {\n        const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();\n        bin.writeMessage(this, writer, opt);\n        return writer.finish();\n    }\n    /**\n     * Serialize the message to a JSON value, a JavaScript value that can be\n     * passed to JSON.stringify().\n     */ toJson(options) {\n        const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);\n        return json.writeMessage(this, opt);\n    }\n    /**\n     * Serialize the message to a JSON string.\n     */ toJsonString(options) {\n        var _a;\n        const value = this.toJson(options);\n        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\n    }\n    /**\n     * Override for serialization behavior. This will be invoked when calling\n     * JSON.stringify on this message (i.e. JSON.stringify(msg)).\n     *\n     * Note that this will not serialize google.protobuf.Any with a packed\n     * message because the protobuf JSON format specifies that it needs to be\n     * unpacked, and this is only possible with a type registry to look up the\n     * message type.  As a result, attempting to serialize a message with this\n     * type will throw an Error.\n     *\n     * This method is protected because you should not need to invoke it\n     * directly -- instead use JSON.stringify or toJsonString for\n     * stringified JSON.  Alternatively, if actual JSON is desired, you should\n     * use toJson.\n     */ toJSON() {\n        return this.toJson({\n            emitDefaultValues: true\n        });\n    }\n    /**\n     * Retrieve the MessageType of this message - a singleton that represents\n     * the protobuf message declaration and provides metadata for reflection-\n     * based operations.\n     */ getType() {\n        // Any class that extends Message _must_ provide a complete static\n        // implementation of MessageType.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n        return Object.getPrototypeOf(this).constructor;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new message type using the given runtime.\n */ function makeMessageType(runtime, typeName, fields, opt) {\n    var _a;\n    const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(\".\") + 1);\n    const type = {\n        [localName]: function(data) {\n            runtime.util.initFields(this);\n            runtime.util.initPartial(data, this);\n        }\n    }[localName];\n    Object.setPrototypeOf(type.prototype, new Message());\n    Object.assign(type, {\n        runtime,\n        typeName,\n        fields: runtime.util.newFieldList(fields),\n        fromBinary (bytes, options) {\n            return new type().fromBinary(bytes, options);\n        },\n        fromJson (jsonValue, options) {\n            return new type().fromJson(jsonValue, options);\n        },\n        fromJsonString (jsonString, options) {\n            return new type().fromJsonString(jsonString, options);\n        },\n        equals (a, b) {\n            return runtime.util.equals(type, a, b);\n        }\n    });\n    return type;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeProtoRuntime(syntax, json, bin, util) {\n    return {\n        syntax,\n        json,\n        bin,\n        util,\n        makeMessageType (typeName, fields, opt) {\n            return makeMessageType(this, typeName, fields, opt);\n        },\n        makeEnum,\n        makeEnumType,\n        getEnumType\n    };\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */ var ScalarType;\n(function(ScalarType) {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n    ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\n    ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\n    ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\n    ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\n    ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\n    ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported in proto3. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.\n    // TYPE_GROUP = 10,\n    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n    // New in version 2.\n    ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\n    ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\n    // TYPE_ENUM = 14,\n    ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\n    ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\n    ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\n    ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\n/**\n * JavaScript representation of fields with 64 bit integral types (int64, uint64,\n * sint64, fixed64, sfixed64).\n *\n * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,\n * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use\n * String if `[jstype = JS_STRING]` is specified.\n *\n * ```protobuf\n * uint64 field_a = 1; // BigInt\n * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt\n * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt\n * uint64 field_b = 2 [jstype = JS_STRING]; // String\n * ```\n */ var LongType;\n(function(LongType) {\n    /**\n     * Use JavaScript BigInt.\n     */ LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\n    /**\n     * Use JavaScript String.\n     *\n     * Field option `[jstype = JS_STRING]`.\n     */ LongType[LongType[\"STRING\"] = 1] = \"STRING\";\n})(LongType || (LongType = {}));\n// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */ /**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */ function varint64read() {\n    let lowBits = 0;\n    let highBits = 0;\n    for(let shift = 0; shift < 28; shift += 7){\n        let b = this.buf[this.pos++];\n        lowBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    let middleByte = this.buf[this.pos++];\n    // last four bits of the first 32 bit number\n    lowBits |= (middleByte & 0x0f) << 28;\n    // 3 upper bits are part of the next 32 bit number\n    highBits = (middleByte & 0x70) >> 4;\n    if ((middleByte & 0x80) == 0) {\n        this.assertBounds();\n        return [\n            lowBits,\n            highBits\n        ];\n    }\n    for(let shift = 3; shift <= 31; shift += 7){\n        let b = this.buf[this.pos++];\n        highBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    throw new Error(\"invalid varint\");\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */ function varint64write(lo, hi, bytes) {\n    for(let i = 0; i < 28; i = i + 7){\n        const shift = lo >>> i;\n        const hasNext = !(shift >>> 7 == 0 && hi == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    const splitBits = lo >>> 28 & 0x0f | (hi & 0x07) << 4;\n    const hasMoreBits = !(hi >> 3 == 0);\n    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n    if (!hasMoreBits) {\n        return;\n    }\n    for(let i = 3; i < 31; i = i + 7){\n        const shift = hi >>> i;\n        const hasNext = !(shift >>> 7 == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    bytes.push(hi >>> 31 & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64FromString(dec) {\n    // Check for minus sign.\n    const minus = dec[0] === \"-\";\n    if (minus) {\n        dec = dec.slice(1);\n    }\n    // Work 6 decimal digits at a time, acting like we're converting base 1e6\n    // digits to binary. This is safe to do with floating point math because\n    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n    const base = 1e6;\n    let lowBits = 0;\n    let highBits = 0;\n    function add1e6digit(begin, end) {\n        // Note: Number('') is 0.\n        const digit1e6 = Number(dec.slice(begin, end));\n        highBits *= base;\n        lowBits = lowBits * base + digit1e6;\n        // Carry bits from lowBits to\n        if (lowBits >= TWO_PWR_32_DBL) {\n            highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);\n            lowBits = lowBits % TWO_PWR_32_DBL;\n        }\n    }\n    add1e6digit(-24, -18);\n    add1e6digit(-18, -12);\n    add1e6digit(-12, -6);\n    add1e6digit(-6);\n    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64ToString(lo, hi) {\n    let bits = newBits(lo, hi);\n    // If we're treating the input as a signed value and the high bit is set, do\n    // a manual two's complement conversion before the decimal conversion.\n    const negative = bits.hi & 0x80000000;\n    if (negative) {\n        bits = negate(bits.lo, bits.hi);\n    }\n    const result = uInt64ToString(bits.lo, bits.hi);\n    return negative ? \"-\" + result : result;\n}\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function uInt64ToString(lo, hi) {\n    ({ lo, hi } = toUnsigned(lo, hi));\n    // Skip the expensive conversion if the number is small enough to use the\n    // built-in conversions.\n    // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n    // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n    // integer precision.\n    // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n    if (hi <= 0x1FFFFF) {\n        return String(TWO_PWR_32_DBL * hi + lo);\n    }\n    // What this code is doing is essentially converting the input number from\n    // base-2 to base-1e7, which allows us to represent the 64-bit range with\n    // only 3 (very large) digits. Those digits are then trivial to convert to\n    // a base-10 string.\n    // The magic numbers used here are -\n    // 2^24 = 16777216 = (1,6777216) in base-1e7.\n    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n    // Split 32:32 representation into 16:24:24 representation so our\n    // intermediate digits don't overflow.\n    const low = lo & 0xFFFFFF;\n    const mid = (lo >>> 24 | hi << 8) & 0xFFFFFF;\n    const high = hi >> 16 & 0xFFFF;\n    // Assemble our three base-1e7 digits, ignoring carries. The maximum\n    // value in a digit at this step is representable as a 48-bit integer, which\n    // can be stored in a 64-bit floating point number.\n    let digitA = low + mid * 6777216 + high * 6710656;\n    let digitB = mid + high * 8147497;\n    let digitC = high * 2;\n    // Apply carries from A to B and from B to C.\n    const base = 10000000;\n    if (digitA >= base) {\n        digitB += Math.floor(digitA / base);\n        digitA %= base;\n    }\n    if (digitB >= base) {\n        digitC += Math.floor(digitB / base);\n        digitB %= base;\n    }\n    // If digitC is 0, then we should have returned in the trivial code path\n    // at the top for non-safe integers. Given this, we can assume both digitB\n    // and digitA need leading zeros.\n    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\n}\nfunction toUnsigned(lo, hi) {\n    return {\n        lo: lo >>> 0,\n        hi: hi >>> 0\n    };\n}\nfunction newBits(lo, hi) {\n    return {\n        lo: lo | 0,\n        hi: hi | 0\n    };\n}\n/**\n * Returns two's compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */ function negate(lowBits, highBits) {\n    highBits = ~highBits;\n    if (lowBits) {\n        lowBits = ~lowBits + 1;\n    } else {\n        // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n        // adding 1 to that, results in 0x100000000, which leaves\n        // the low bits 0x0 and simply adds one to the high bits.\n        highBits += 1;\n    }\n    return newBits(lowBits, highBits);\n}\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */ const decimalFrom1e7WithLeadingZeros = (digit1e7)=>{\n    const partial = String(digit1e7);\n    return \"0000000\".slice(partial.length) + partial;\n};\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */ function varint32write(value, bytes) {\n    if (value >= 0) {\n        // write value as varint 32\n        while(value > 0x7f){\n            bytes.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        bytes.push(value);\n    } else {\n        for(let i = 0; i < 9; i++){\n            bytes.push(value & 127 | 128);\n            value = value >> 7;\n        }\n        bytes.push(1);\n    }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */ function varint32read() {\n    let b = this.buf[this.pos++];\n    let result = b & 0x7f;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 7;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 14;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 21;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    // Extract only last 4 bits\n    b = this.buf[this.pos++];\n    result |= (b & 0x0f) << 28;\n    for(let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)b = this.buf[this.pos++];\n    if ((b & 0x80) != 0) throw new Error(\"invalid varint\");\n    this.assertBounds();\n    // Result can have 32 bits, convert it to unsigned\n    return result >>> 0;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeInt64Support() {\n    const dv = new DataView(new ArrayBuffer(8));\n    // note that Safari 14 implements BigInt, but not the DataView methods\n    const ok = typeof BigInt === \"function\" && typeof dv.getBigInt64 === \"function\" && typeof dv.getBigUint64 === \"function\" && typeof dv.setBigInt64 === \"function\" && typeof dv.setBigUint64 === \"function\" && (typeof process != \"object\" || typeof process.env != \"object\" || process.env.BUF_BIGINT_DISABLE !== \"1\");\n    if (ok) {\n        const MIN = BigInt(\"-9223372036854775808\"), MAX = BigInt(\"9223372036854775807\"), UMIN = BigInt(\"0\"), UMAX = BigInt(\"18446744073709551615\");\n        return {\n            zero: BigInt(0),\n            supported: true,\n            parse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > MAX || bi < MIN) {\n                    throw new Error(`int64 invalid: ${value}`);\n                }\n                return bi;\n            },\n            uParse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > UMAX || bi < UMIN) {\n                    throw new Error(`uint64 invalid: ${value}`);\n                }\n                return bi;\n            },\n            enc (value) {\n                dv.setBigInt64(0, this.parse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            uEnc (value) {\n                dv.setBigInt64(0, this.uParse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            dec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigInt64(0, true);\n            },\n            uDec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigUint64(0, true);\n            }\n        };\n    }\n    const assertInt64String = (value)=>assert(/^-?[0-9]+$/.test(value), `int64 invalid: ${value}`);\n    const assertUInt64String = (value)=>assert(/^[0-9]+$/.test(value), `uint64 invalid: ${value}`);\n    return {\n        zero: \"0\",\n        supported: false,\n        parse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return value;\n        },\n        uParse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return value;\n        },\n        enc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return int64FromString(value);\n        },\n        uEnc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return int64FromString(value);\n        },\n        dec (lo, hi) {\n            return int64ToString(lo, hi);\n        },\n        uDec (lo, hi) {\n            return uInt64ToString(lo, hi);\n        }\n    };\n}\nconst protoInt64 = makeInt64Support();\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */ /**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */ var WireType;\n(function(WireType) {\n    /**\n     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n     */ WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n    /**\n     * Used for fixed64, sfixed64, double.\n     * Always 8 bytes with little-endian byte order.\n     */ WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n    /**\n     * Used for string, bytes, embedded messages, packed repeated fields\n     *\n     * Only repeated numeric types (types which use the varint, 32-bit,\n     * or 64-bit wire types) can be packed. In proto3, such fields are\n     * packed by default.\n     */ WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n    /**\n     * Used for groups\n     * @deprecated\n     */ WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n    /**\n     * Used for groups\n     * @deprecated\n     */ WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n    /**\n     * Used for fixed32, sfixed32, float.\n     * Always 4 bytes with little-endian byte order.\n     */ WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\nclass BinaryWriter {\n    constructor(textEncoder){\n        /**\n         * Previous fork states.\n         */ this.stack = [];\n        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\n        this.chunks = [];\n        this.buf = [];\n    }\n    /**\n     * Return all bytes written and reset this writer.\n     */ finish() {\n        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n        let len = 0;\n        for(let i = 0; i < this.chunks.length; i++)len += this.chunks[i].length;\n        let bytes = new Uint8Array(len);\n        let offset = 0;\n        for(let i = 0; i < this.chunks.length; i++){\n            bytes.set(this.chunks[i], offset);\n            offset += this.chunks[i].length;\n        }\n        this.chunks = [];\n        return bytes;\n    }\n    /**\n     * Start a new fork for length-delimited data like a message\n     * or a packed repeated field.\n     *\n     * Must be joined later with `join()`.\n     */ fork() {\n        this.stack.push({\n            chunks: this.chunks,\n            buf: this.buf\n        });\n        this.chunks = [];\n        this.buf = [];\n        return this;\n    }\n    /**\n     * Join the last fork. Write its length and bytes, then\n     * return to the previous state.\n     */ join() {\n        // get chunk of fork\n        let chunk = this.finish();\n        // restore previous state\n        let prev = this.stack.pop();\n        if (!prev) throw new Error(\"invalid state, fork stack empty\");\n        this.chunks = prev.chunks;\n        this.buf = prev.buf;\n        // write length of chunk as varint\n        this.uint32(chunk.byteLength);\n        return this.raw(chunk);\n    }\n    /**\n     * Writes a tag (field number and wire type).\n     *\n     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n     *\n     * Generated code should compute the tag ahead of time and call `uint32()`.\n     */ tag(fieldNo, type) {\n        return this.uint32((fieldNo << 3 | type) >>> 0);\n    }\n    /**\n     * Write a chunk of raw bytes.\n     */ raw(chunk) {\n        if (this.buf.length) {\n            this.chunks.push(new Uint8Array(this.buf));\n            this.buf = [];\n        }\n        this.chunks.push(chunk);\n        return this;\n    }\n    /**\n     * Write a `uint32` value, an unsigned 32 bit varint.\n     */ uint32(value) {\n        assertUInt32(value);\n        // write value as varint 32, inlined for speed\n        while(value > 0x7f){\n            this.buf.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        this.buf.push(value);\n        return this;\n    }\n    /**\n     * Write a `int32` value, a signed 32 bit varint.\n     */ int32(value) {\n        assertInt32(value);\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n     * Write a `bool` value, a variant.\n     */ bool(value) {\n        this.buf.push(value ? 1 : 0);\n        return this;\n    }\n    /**\n     * Write a `bytes` value, length-delimited arbitrary data.\n     */ bytes(value) {\n        this.uint32(value.byteLength); // write length of chunk as varint\n        return this.raw(value);\n    }\n    /**\n     * Write a `string` value, length-delimited data converted to UTF-8 text.\n     */ string(value) {\n        let chunk = this.textEncoder.encode(value);\n        this.uint32(chunk.byteLength); // write length of chunk as varint\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `float` value, 32-bit floating point number.\n     */ float(value) {\n        assertFloat32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setFloat32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `double` value, a 64-bit floating point number.\n     */ double(value) {\n        let chunk = new Uint8Array(8);\n        new DataView(chunk.buffer).setFloat64(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n     */ fixed32(value) {\n        assertUInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setUint32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n     */ sfixed32(value) {\n        assertInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setInt32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n     */ sint32(value) {\n        assertInt32(value);\n        // zigzag encode\n        value = (value << 1 ^ value >> 31) >>> 0;\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n     */ sfixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n     */ fixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `int64` value, a signed 64-bit varint.\n     */ int64(value) {\n        let tc = protoInt64.enc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n    /**\n     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n     */ sint64(value) {\n        let tc = protoInt64.enc(value), // zigzag encode\n        sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;\n        varint64write(lo, hi, this.buf);\n        return this;\n    }\n    /**\n     * Write a `uint64` value, an unsigned 64-bit varint.\n     */ uint64(value) {\n        let tc = protoInt64.uEnc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n}\nclass BinaryReader {\n    constructor(buf, textDecoder){\n        this.varint64 = varint64read; // dirty cast for `this`\n        /**\n         * Read a `uint32` field, an unsigned 32 bit varint.\n         */ this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\n        this.buf = buf;\n        this.len = buf.length;\n        this.pos = 0;\n        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();\n    }\n    /**\n     * Reads a tag - field number and wire type.\n     */ tag() {\n        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;\n        if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n        return [\n            fieldNo,\n            wireType\n        ];\n    }\n    /**\n     * Skip one element on the wire and return the skipped data.\n     * Supports WireType.StartGroup since v2.0.0-alpha.23.\n     */ skip(wireType) {\n        let start = this.pos;\n        switch(wireType){\n            case WireType.Varint:\n                while(this.buf[this.pos++] & 0x80){\n                // ignore\n                }\n                break;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit64:\n                this.pos += 4;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit32:\n                this.pos += 4;\n                break;\n            case WireType.LengthDelimited:\n                let len = this.uint32();\n                this.pos += len;\n                break;\n            case WireType.StartGroup:\n                // From descriptor.proto: Group type is deprecated, not supported in proto3.\n                // But we must still be able to parse and treat as unknown.\n                let t;\n                while((t = this.tag()[1]) !== WireType.EndGroup){\n                    this.skip(t);\n                }\n                break;\n            default:\n                throw new Error(\"cant skip wire type \" + wireType);\n        }\n        this.assertBounds();\n        return this.buf.subarray(start, this.pos);\n    }\n    /**\n     * Throws error if position in byte array is out of range.\n     */ assertBounds() {\n        if (this.pos > this.len) throw new RangeError(\"premature EOF\");\n    }\n    /**\n     * Read a `int32` field, a signed 32 bit varint.\n     */ int32() {\n        return this.uint32() | 0;\n    }\n    /**\n     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n     */ sint32() {\n        let zze = this.uint32();\n        // decode zigzag\n        return zze >>> 1 ^ -(zze & 1);\n    }\n    /**\n     * Read a `int64` field, a signed 64-bit varint.\n     */ int64() {\n        return protoInt64.dec(...this.varint64());\n    }\n    /**\n     * Read a `uint64` field, an unsigned 64-bit varint.\n     */ uint64() {\n        return protoInt64.uDec(...this.varint64());\n    }\n    /**\n     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n     */ sint64() {\n        let [lo, hi] = this.varint64();\n        // decode zig zag\n        let s = -(lo & 1);\n        lo = (lo >>> 1 | (hi & 1) << 31) ^ s;\n        hi = hi >>> 1 ^ s;\n        return protoInt64.dec(lo, hi);\n    }\n    /**\n     * Read a `bool` field, a variant.\n     */ bool() {\n        let [lo, hi] = this.varint64();\n        return lo !== 0 || hi !== 0;\n    }\n    /**\n     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n     */ fixed32() {\n        return this.view.getUint32((this.pos += 4) - 4, true);\n    }\n    /**\n     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n     */ sfixed32() {\n        return this.view.getInt32((this.pos += 4) - 4, true);\n    }\n    /**\n     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n     */ fixed64() {\n        return protoInt64.uDec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n     */ sfixed64() {\n        return protoInt64.dec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n     * Read a `float` field, 32-bit floating point number.\n     */ float() {\n        return this.view.getFloat32((this.pos += 4) - 4, true);\n    }\n    /**\n     * Read a `double` field, a 64-bit floating point number.\n     */ double() {\n        return this.view.getFloat64((this.pos += 8) - 8, true);\n    }\n    /**\n     * Read a `bytes` field, length-delimited arbitrary data.\n     */ bytes() {\n        let len = this.uint32(), start = this.pos;\n        this.pos += len;\n        this.assertBounds();\n        return this.buf.subarray(start, start + len);\n    }\n    /**\n     * Read a `string` field, length-delimited data converted to UTF-8 text.\n     */ string() {\n        return this.textDecoder.decode(this.bytes());\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Wrap a primitive message field value in its corresponding wrapper\n * message. This function is idempotent.\n */ function wrapField(type, value) {\n    if (value instanceof Message || !type.fieldWrapper) {\n        return value;\n    }\n    return type.fieldWrapper.wrapField(value);\n}\n({\n    \"google.protobuf.DoubleValue\": ScalarType.DOUBLE,\n    \"google.protobuf.FloatValue\": ScalarType.FLOAT,\n    \"google.protobuf.Int64Value\": ScalarType.INT64,\n    \"google.protobuf.UInt64Value\": ScalarType.UINT64,\n    \"google.protobuf.Int32Value\": ScalarType.INT32,\n    \"google.protobuf.UInt32Value\": ScalarType.UINT32,\n    \"google.protobuf.BoolValue\": ScalarType.BOOL,\n    \"google.protobuf.StringValue\": ScalarType.STRING,\n    \"google.protobuf.BytesValue\": ScalarType.BYTES\n});\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any */ /**\n * Returns true if both scalar values are equal.\n */ function scalarEquals(type, a, b) {\n    if (a === b) {\n        // This correctly matches equal values except BYTES and (possibly) 64-bit integers.\n        return true;\n    }\n    // Special case BYTES - we need to compare each byte individually\n    if (type == ScalarType.BYTES) {\n        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\n            return false;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length; i++){\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Special case 64-bit integers - we support number, string and bigint representation.\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(type){\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // Loose comparison will match between 0n, 0 and \"0\".\n            return a == b;\n    }\n    // Anything that hasn't been caught by strict comparison or special cased\n    // BYTES and 64-bit integers is not equal.\n    return false;\n}\n/**\n * Returns the default value for the given scalar type, following\n * proto3 semantics.\n */ function scalarDefaultValue(type, longType) {\n    switch(type){\n        case ScalarType.BOOL:\n            return false;\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n            return longType == 0 ? protoInt64.zero : \"0\";\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            return 0.0;\n        case ScalarType.BYTES:\n            return new Uint8Array(0);\n        case ScalarType.STRING:\n            return \"\";\n        default:\n            // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.\n            // We do not use individual cases to save a few bytes code size.\n            return 0;\n    }\n}\n/**\n * Get information for writing a scalar value.\n *\n * Returns tuple:\n * [0]: appropriate WireType\n * [1]: name of the appropriate method of IBinaryWriter\n * [2]: whether the given value is a default value for proto3 semantics\n *\n * If argument `value` is omitted, [2] is always false.\n */ function scalarTypeInfo(type, value) {\n    const isUndefined = value === undefined;\n    let wireType = WireType.Varint;\n    let isIntrinsicDefault = value === 0;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults\n    switch(type){\n        case ScalarType.STRING:\n            isIntrinsicDefault = isUndefined || !value.length;\n            wireType = WireType.LengthDelimited;\n            break;\n        case ScalarType.BOOL:\n            isIntrinsicDefault = value === false;\n            break;\n        case ScalarType.DOUBLE:\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.FLOAT:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.INT64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            break;\n        case ScalarType.UINT64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            break;\n        case ScalarType.FIXED64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.BYTES:\n            isIntrinsicDefault = isUndefined || !value.byteLength;\n            wireType = WireType.LengthDelimited;\n            break;\n        case ScalarType.FIXED32:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.SFIXED32:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.SFIXED64:\n            isIntrinsicDefault = isUndefined || value == 0;\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.SINT64:\n            isIntrinsicDefault = isUndefined || value == 0;\n            break;\n    }\n    const method = ScalarType[type].toLowerCase();\n    return [\n        wireType,\n        method,\n        isUndefined || isIntrinsicDefault\n    ];\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unnecessary-condition, no-case-declarations, prefer-const */ const unknownFieldsSymbol = Symbol(\"@bufbuild/protobuf/unknown-fields\");\n// Default options for parsing binary data.\nconst readDefaults = {\n    readUnknownFields: true,\n    readerFactory: (bytes)=>new BinaryReader(bytes)\n};\n// Default options for serializing binary data.\nconst writeDefaults = {\n    writeUnknownFields: true,\n    writerFactory: ()=>new BinaryWriter()\n};\nfunction makeReadOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;\n}\nfunction makeWriteOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;\n}\nfunction makeBinaryFormatCommon() {\n    return {\n        makeReadOptions: makeReadOptions$1,\n        makeWriteOptions: makeWriteOptions$1,\n        listUnknownFields (message) {\n            var _a;\n            return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];\n        },\n        discardUnknownFields (message) {\n            delete message[unknownFieldsSymbol];\n        },\n        writeUnknownFields (message, writer) {\n            const m = message;\n            const c = m[unknownFieldsSymbol];\n            if (c) {\n                for (const f of c){\n                    writer.tag(f.no, f.wireType).raw(f.data);\n                }\n            }\n        },\n        onUnknownField (message, no, wireType, data) {\n            const m = message;\n            if (!Array.isArray(m[unknownFieldsSymbol])) {\n                m[unknownFieldsSymbol] = [];\n            }\n            m[unknownFieldsSymbol].push({\n                no,\n                wireType,\n                data\n            });\n        },\n        readMessage (message, reader, length, options) {\n            const type = message.getType();\n            const end = length === undefined ? reader.len : reader.pos + length;\n            while(reader.pos < end){\n                const [fieldNo, wireType] = reader.tag(), field = type.fields.find(fieldNo);\n                if (!field) {\n                    const data = reader.skip(wireType);\n                    if (options.readUnknownFields) {\n                        this.onUnknownField(message, fieldNo, wireType, data);\n                    }\n                    continue;\n                }\n                let target = message, repeated = field.repeated, localName = field.localName;\n                if (field.oneof) {\n                    target = target[field.oneof.localName];\n                    if (target.case != localName) {\n                        delete target.value;\n                    }\n                    target.case = localName;\n                    localName = \"value\";\n                }\n                switch(field.kind){\n                    case \"scalar\":\n                    case \"enum\":\n                        const scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                        let read = readScalar$1;\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n                        if (field.kind == \"scalar\" && field.L > 0) {\n                            read = readScalarLTString;\n                        }\n                        if (repeated) {\n                            let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n                            if (wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES) {\n                                let e = reader.uint32() + reader.pos;\n                                while(reader.pos < e){\n                                    arr.push(read(reader, scalarType));\n                                }\n                            } else {\n                                arr.push(read(reader, scalarType));\n                            }\n                        } else {\n                            target[localName] = read(reader, scalarType);\n                        }\n                        break;\n                    case \"message\":\n                        const messageType = field.T;\n                        if (repeated) {\n                            // safe to assume presence of array, oneof cannot contain repeated values\n                            target[localName].push(readMessageField(reader, new messageType(), options));\n                        } else {\n                            if (target[localName] instanceof Message) {\n                                readMessageField(reader, target[localName], options);\n                            } else {\n                                target[localName] = readMessageField(reader, new messageType(), options);\n                                if (messageType.fieldWrapper && !field.oneof && !field.repeated) {\n                                    target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                                }\n                            }\n                        }\n                        break;\n                    case \"map\":\n                        let [mapKey, mapVal] = readMapEntry(field, reader, options);\n                        // safe to assume presence of map object, oneof cannot contain repeated values\n                        target[localName][mapKey] = mapVal;\n                        break;\n                }\n            }\n        }\n    };\n}\n// Read a message, avoiding MessageType.fromBinary() to re-use the\n// BinaryReadOptions and the IBinaryReader.\nfunction readMessageField(reader, message, options) {\n    const format = message.getType().runtime.bin;\n    format.readMessage(message, reader, reader.uint32(), options);\n    return message;\n}\n// Read a map field, expecting key field = 1, value field = 2\nfunction readMapEntry(field, reader, options) {\n    const length = reader.uint32(), end = reader.pos + length;\n    let key, val;\n    while(reader.pos < end){\n        let [fieldNo] = reader.tag();\n        switch(fieldNo){\n            case 1:\n                key = readScalar$1(reader, field.K);\n                break;\n            case 2:\n                switch(field.V.kind){\n                    case \"scalar\":\n                        val = readScalar$1(reader, field.V.T);\n                        break;\n                    case \"enum\":\n                        val = reader.int32();\n                        break;\n                    case \"message\":\n                        val = readMessageField(reader, new field.V.T(), options);\n                        break;\n                }\n                break;\n        }\n    }\n    if (key === undefined) {\n        let keyRaw = scalarDefaultValue(field.K, LongType.BIGINT);\n        key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;\n    }\n    if (typeof key != \"string\" && typeof key != \"number\") {\n        key = key.toString();\n    }\n    if (val === undefined) {\n        switch(field.V.kind){\n            case \"scalar\":\n                val = scalarDefaultValue(field.V.T, LongType.BIGINT);\n                break;\n            case \"enum\":\n                val = 0;\n                break;\n            case \"message\":\n                val = new field.V.T();\n                break;\n        }\n    }\n    return [\n        key,\n        val\n    ];\n}\n// Read a scalar value, but return 64 bit integral types (int64, uint64,\n// sint64, fixed64, sfixed64) as string instead of bigint.\nfunction readScalarLTString(reader, type) {\n    const v = readScalar$1(reader, type);\n    return typeof v == \"bigint\" ? v.toString() : v;\n}\n// Does not use scalarTypeInfo() for better performance.\nfunction readScalar$1(reader, type) {\n    switch(type){\n        case ScalarType.STRING:\n            return reader.string();\n        case ScalarType.BOOL:\n            return reader.bool();\n        case ScalarType.DOUBLE:\n            return reader.double();\n        case ScalarType.FLOAT:\n            return reader.float();\n        case ScalarType.INT32:\n            return reader.int32();\n        case ScalarType.INT64:\n            return reader.int64();\n        case ScalarType.UINT64:\n            return reader.uint64();\n        case ScalarType.FIXED64:\n            return reader.fixed64();\n        case ScalarType.BYTES:\n            return reader.bytes();\n        case ScalarType.FIXED32:\n            return reader.fixed32();\n        case ScalarType.SFIXED32:\n            return reader.sfixed32();\n        case ScalarType.SFIXED64:\n            return reader.sfixed64();\n        case ScalarType.SINT64:\n            return reader.sint64();\n        case ScalarType.UINT32:\n            return reader.uint32();\n        case ScalarType.SINT32:\n            return reader.sint32();\n    }\n}\nfunction writeMapEntry(writer, options, field, key, value) {\n    writer.tag(field.no, WireType.LengthDelimited);\n    writer.fork();\n    // javascript only allows number or string for object properties\n    // we convert from our representation to the protobuf type\n    let keyValue = key;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys\n    switch(field.K){\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n            keyValue = Number.parseInt(key);\n            break;\n        case ScalarType.BOOL:\n            assert(key == \"true\" || key == \"false\");\n            keyValue = key == \"true\";\n            break;\n    }\n    // write key, expecting key field number = 1\n    writeScalar$1(writer, field.K, 1, keyValue, true);\n    // write value, expecting value field number = 2\n    switch(field.V.kind){\n        case \"scalar\":\n            writeScalar$1(writer, field.V.T, 2, value, true);\n            break;\n        case \"enum\":\n            writeScalar$1(writer, ScalarType.INT32, 2, value, true);\n            break;\n        case \"message\":\n            writeMessageField(writer, options, field.V.T, 2, value);\n            break;\n    }\n    writer.join();\n}\nfunction writeMessageField(writer, options, type, fieldNo, value) {\n    if (value !== undefined) {\n        const message = wrapField(type, value);\n        writer.tag(fieldNo, WireType.LengthDelimited).bytes(message.toBinary(options));\n    }\n}\nfunction writeScalar$1(writer, type, fieldNo, value, emitIntrinsicDefault) {\n    let [wireType, method, isIntrinsicDefault] = scalarTypeInfo(type, value);\n    if (!isIntrinsicDefault || emitIntrinsicDefault) {\n        writer.tag(fieldNo, wireType)[method](value);\n    }\n}\nfunction writePacked(writer, type, fieldNo, value) {\n    if (!value.length) {\n        return;\n    }\n    writer.tag(fieldNo, WireType.LengthDelimited).fork();\n    let [, method] = scalarTypeInfo(type);\n    for(let i = 0; i < value.length; i++){\n        writer[method](value[i]);\n    }\n    writer.join();\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unnecessary-condition, @typescript-eslint/strict-boolean-expressions, prefer-const, no-case-declarations */ function makeBinaryFormatProto3() {\n    return Object.assign(Object.assign({}, makeBinaryFormatCommon()), {\n        writeMessage (message, writer, options) {\n            const type = message.getType();\n            for (const field of type.fields.byNumber()){\n                let value, repeated = field.repeated, localName = field.localName;\n                if (field.oneof) {\n                    const oneof = message[field.oneof.localName];\n                    if (oneof.case !== localName) {\n                        continue; // field is not selected, skip\n                    }\n                    value = oneof.value;\n                } else {\n                    value = message[localName];\n                }\n                switch(field.kind){\n                    case \"scalar\":\n                    case \"enum\":\n                        let scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                        if (repeated) {\n                            if (field.packed) {\n                                writePacked(writer, scalarType, field.no, value);\n                            } else {\n                                for (const item of value){\n                                    writeScalar$1(writer, scalarType, field.no, item, true);\n                                }\n                            }\n                        } else {\n                            if (value !== undefined) {\n                                writeScalar$1(writer, scalarType, field.no, value, !!field.oneof || field.opt);\n                            }\n                        }\n                        break;\n                    case \"message\":\n                        if (repeated) {\n                            for (const item of value){\n                                writeMessageField(writer, options, field.T, field.no, item);\n                            }\n                        } else {\n                            writeMessageField(writer, options, field.T, field.no, value);\n                        }\n                        break;\n                    case \"map\":\n                        for (const [key, val] of Object.entries(value)){\n                            writeMapEntry(writer, options, field, key, val);\n                        }\n                        break;\n                }\n            }\n            if (options.writeUnknownFields) {\n                this.writeUnknownFields(message, writer);\n            }\n            return writer;\n        }\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */ // lookup table from base64 character to byte\nlet encTable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor(let i = 0; i < encTable.length; i++)decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\nconst protoBase64 = {\n    /**\n     * Decodes a base64 string to a byte array.\n     *\n     * - ignores white-space, including line breaks and tabs\n     * - allows inner padding (can decode concatenated base64 strings)\n     * - does not require padding\n     * - understands base64url encoding:\n     *   \"-\" instead of \"+\",\n     *   \"_\" instead of \"/\",\n     *   no padding\n     */ dec (base64Str) {\n        // estimate byte size, not accounting for inner padding and whitespace\n        let es = base64Str.length * 3 / 4;\n        if (base64Str[base64Str.length - 2] == \"=\") es -= 2;\n        else if (base64Str[base64Str.length - 1] == \"=\") es -= 1;\n        let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0; // previous byte\n        for(let i = 0; i < base64Str.length; i++){\n            b = decTable[base64Str.charCodeAt(i)];\n            if (b === undefined) {\n                switch(base64Str[i]){\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"=\":\n                        groupPos = 0; // reset state when padding found\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"\\n\":\n                    case \"\\r\":\n                    case \"\t\":\n                    case \" \":\n                        continue; // skip white-space, and padding\n                    default:\n                        throw Error(\"invalid base64 string.\");\n                }\n            }\n            switch(groupPos){\n                case 0:\n                    p = b;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    bytes[bytePos++] = p << 2 | (b & 48) >> 4;\n                    p = b;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\n                    p = b;\n                    groupPos = 3;\n                    break;\n                case 3:\n                    bytes[bytePos++] = (p & 3) << 6 | b;\n                    groupPos = 0;\n                    break;\n            }\n        }\n        if (groupPos == 1) throw Error(\"invalid base64 string.\");\n        return bytes.subarray(0, bytePos);\n    },\n    /**\n     * Encode a byte array to a base64 string.\n     */ enc (bytes) {\n        let base64 = \"\", groupPos = 0, b, p = 0; // carry over from previous byte\n        for(let i = 0; i < bytes.length; i++){\n            b = bytes[i];\n            switch(groupPos){\n                case 0:\n                    base64 += encTable[b >> 2];\n                    p = (b & 3) << 4;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    base64 += encTable[p | b >> 4];\n                    p = (b & 15) << 2;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    base64 += encTable[p | b >> 6];\n                    base64 += encTable[b & 63];\n                    groupPos = 0;\n                    break;\n            }\n        }\n        // add output padding\n        if (groupPos) {\n            base64 += encTable[p];\n            base64 += \"=\";\n            if (groupPos == 1) base64 += \"=\";\n        }\n        return base64;\n    }\n};\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations, @typescript-eslint/restrict-plus-operands,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ // Default options for parsing JSON.\nconst jsonReadDefaults = {\n    ignoreUnknownFields: false\n};\n// Default options for serializing to JSON.\nconst jsonWriteDefaults = {\n    emitDefaultValues: false,\n    enumAsInteger: false,\n    useProtoFieldName: false,\n    prettySpaces: 0\n};\nfunction makeReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;\n}\nfunction makeWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;\n}\nfunction makeJsonFormatCommon(makeWriteField) {\n    const writeField = makeWriteField(writeEnum, writeScalar);\n    return {\n        makeReadOptions,\n        makeWriteOptions,\n        readMessage (type, json, options, message) {\n            if (json == null || Array.isArray(json) || typeof json != \"object\") {\n                throw new Error(`cannot decode message ${type.typeName} from JSON: ${this.debug(json)}`);\n            }\n            message = message !== null && message !== void 0 ? message : new type();\n            const oneofSeen = {};\n            for (const [jsonKey, jsonValue] of Object.entries(json)){\n                const field = type.fields.findJsonName(jsonKey);\n                if (!field) {\n                    if (!options.ignoreUnknownFields) {\n                        throw new Error(`cannot decode message ${type.typeName} from JSON: key \"${jsonKey}\" is unknown`);\n                    }\n                    continue;\n                }\n                let localName = field.localName;\n                let target = message;\n                if (field.oneof) {\n                    if (jsonValue === null && field.kind == \"scalar\") {\n                        continue;\n                    }\n                    const seen = oneofSeen[field.oneof.localName];\n                    if (seen) {\n                        throw new Error(`cannot decode message ${type.typeName} from JSON: multiple keys for oneof \"${field.oneof.name}\" present: \"${seen}\", \"${jsonKey}\"`);\n                    }\n                    oneofSeen[field.oneof.localName] = jsonKey;\n                    target = target[field.oneof.localName] = {\n                        case: localName\n                    };\n                    localName = \"value\";\n                }\n                if (field.repeated) {\n                    if (jsonValue === null) {\n                        continue;\n                    }\n                    if (!Array.isArray(jsonValue)) {\n                        throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`);\n                    }\n                    const targetArray = target[localName];\n                    for (const jsonItem of jsonValue){\n                        if (jsonItem === null) {\n                            throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonItem)}`);\n                        }\n                        let val;\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- \"map\" is invalid for repeated fields\n                        switch(field.kind){\n                            case \"message\":\n                                val = field.T.fromJson(jsonItem, options);\n                                break;\n                            case \"enum\":\n                                val = readEnum(field.T, jsonItem, options.ignoreUnknownFields);\n                                if (val === undefined) continue;\n                                break;\n                            case \"scalar\":\n                                try {\n                                    val = readScalar(field.T, jsonItem, field.L);\n                                } catch (e) {\n                                    let m = `cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonItem)}`;\n                                    if (e instanceof Error && e.message.length > 0) {\n                                        m += `: ${e.message}`;\n                                    }\n                                    throw new Error(m);\n                                }\n                                break;\n                        }\n                        targetArray.push(val);\n                    }\n                } else if (field.kind == \"map\") {\n                    if (jsonValue === null) {\n                        continue;\n                    }\n                    if (Array.isArray(jsonValue) || typeof jsonValue != \"object\") {\n                        throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`);\n                    }\n                    const targetMap = target[localName];\n                    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)){\n                        if (jsonMapValue === null) {\n                            throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: map value null`);\n                        }\n                        let val;\n                        switch(field.V.kind){\n                            case \"message\":\n                                val = field.V.T.fromJson(jsonMapValue, options);\n                                break;\n                            case \"enum\":\n                                val = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields);\n                                if (val === undefined) continue;\n                                break;\n                            case \"scalar\":\n                                try {\n                                    val = readScalar(field.V.T, jsonMapValue, LongType.BIGINT);\n                                } catch (e) {\n                                    let m = `cannot decode map value for field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`;\n                                    if (e instanceof Error && e.message.length > 0) {\n                                        m += `: ${e.message}`;\n                                    }\n                                    throw new Error(m);\n                                }\n                                break;\n                        }\n                        try {\n                            targetMap[readScalar(field.K, field.K == ScalarType.BOOL ? jsonMapKey == \"true\" ? true : jsonMapKey == \"false\" ? false : jsonMapKey : jsonMapKey, LongType.BIGINT).toString()] = val;\n                        } catch (e) {\n                            let m = `cannot decode map key for field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`;\n                            if (e instanceof Error && e.message.length > 0) {\n                                m += `: ${e.message}`;\n                            }\n                            throw new Error(m);\n                        }\n                    }\n                } else {\n                    switch(field.kind){\n                        case \"message\":\n                            const messageType = field.T;\n                            if (jsonValue === null && messageType.typeName != \"google.protobuf.Value\") {\n                                if (field.oneof) {\n                                    throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: null is invalid for oneof field \"${jsonKey}\"`);\n                                }\n                                continue;\n                            }\n                            if (target[localName] instanceof Message) {\n                                target[localName].fromJson(jsonValue, options);\n                            } else {\n                                target[localName] = messageType.fromJson(jsonValue, options);\n                                if (messageType.fieldWrapper && !field.oneof) {\n                                    target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                                }\n                            }\n                            break;\n                        case \"enum\":\n                            const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields);\n                            if (enumValue !== undefined) {\n                                target[localName] = enumValue;\n                            }\n                            break;\n                        case \"scalar\":\n                            try {\n                                target[localName] = readScalar(field.T, jsonValue, field.L);\n                            } catch (e) {\n                                let m = `cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`;\n                                if (e instanceof Error && e.message.length > 0) {\n                                    m += `: ${e.message}`;\n                                }\n                                throw new Error(m);\n                            }\n                            break;\n                    }\n                }\n            }\n            return message;\n        },\n        writeMessage (message, options) {\n            const type = message.getType();\n            const json = {};\n            let field;\n            try {\n                for (const member of type.fields.byMember()){\n                    let jsonValue;\n                    if (member.kind == \"oneof\") {\n                        const oneof = message[member.localName];\n                        if (oneof.value === undefined) {\n                            continue;\n                        }\n                        field = member.findField(oneof.case);\n                        if (!field) {\n                            throw \"oneof case not found: \" + oneof.case;\n                        }\n                        jsonValue = writeField(field, oneof.value, options);\n                    } else {\n                        field = member;\n                        jsonValue = writeField(field, message[field.localName], options);\n                    }\n                    if (jsonValue !== undefined) {\n                        json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n                    }\n                }\n            } catch (e) {\n                const m = field ? `cannot encode field ${type.typeName}.${field.name} to JSON` : `cannot encode message ${type.typeName} to JSON`;\n                const r = e instanceof Error ? e.message : String(e);\n                throw new Error(m + (r.length > 0 ? `: ${r}` : \"\"));\n            }\n            return json;\n        },\n        readScalar,\n        writeScalar,\n        debug: debugJsonValue\n    };\n}\nfunction debugJsonValue(json) {\n    if (json === null) {\n        return \"null\";\n    }\n    switch(typeof json){\n        case \"object\":\n            return Array.isArray(json) ? \"array\" : \"object\";\n        case \"string\":\n            return json.length > 100 ? \"string\" : `\"${json.split('\"').join('\\\\\"')}\"`;\n        default:\n            return String(json);\n    }\n}\n// May throw an error. If the error message is non-blank, it should be shown.\n// It is up to the caller to provide context.\nfunction readScalar(type, json, longType) {\n    // every valid case in the switch below returns, and every fall\n    // through is regarded as a failure.\n    switch(type){\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            if (json === null) return 0.0;\n            if (json === \"NaN\") return Number.NaN;\n            if (json === \"Infinity\") return Number.POSITIVE_INFINITY;\n            if (json === \"-Infinity\") return Number.NEGATIVE_INFINITY;\n            if (json === \"\") {\n                break;\n            }\n            if (typeof json == \"string\" && json.trim().length !== json.length) {\n                break;\n            }\n            if (typeof json != \"string\" && typeof json != \"number\") {\n                break;\n            }\n            const float = Number(json);\n            if (Number.isNaN(float)) {\n                break;\n            }\n            if (!Number.isFinite(float)) {\n                break;\n            }\n            if (type == ScalarType.FLOAT) assertFloat32(float);\n            return float;\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.UINT32:\n            if (json === null) return 0;\n            let int32;\n            if (typeof json == \"number\") int32 = json;\n            else if (typeof json == \"string\" && json.length > 0) {\n                if (json.trim().length === json.length) int32 = Number(json);\n            }\n            if (int32 === undefined) break;\n            if (type == ScalarType.UINT32) assertUInt32(int32);\n            else assertInt32(int32);\n            return int32;\n        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            if (json === null) return protoInt64.zero;\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const long = protoInt64.parse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? long.toString() : long;\n        case ScalarType.FIXED64:\n        case ScalarType.UINT64:\n            if (json === null) return protoInt64.zero;\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const uLong = protoInt64.uParse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? uLong.toString() : uLong;\n        // bool:\n        case ScalarType.BOOL:\n            if (json === null) return false;\n            if (typeof json !== \"boolean\") break;\n            return json;\n        // string:\n        case ScalarType.STRING:\n            if (json === null) return \"\";\n            if (typeof json !== \"string\") {\n                break;\n            }\n            // A string must always contain UTF-8 encoded or 7-bit ASCII.\n            // We validate with encodeURIComponent, which appears to be the fastest widely available option.\n            try {\n                encodeURIComponent(json);\n            } catch (e) {\n                throw new Error(\"invalid UTF8\");\n            }\n            return json;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            if (json === null || json === \"\") return new Uint8Array(0);\n            if (typeof json !== \"string\") break;\n            return protoBase64.dec(json);\n    }\n    throw new Error();\n}\nfunction readEnum(type, json, ignoreUnknownFields) {\n    if (json === null) {\n        // proto3 requires 0 to be default value for all enums\n        return 0;\n    }\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(typeof json){\n        case \"number\":\n            if (Number.isInteger(json)) {\n                return json;\n            }\n            break;\n        case \"string\":\n            const value = type.findName(json);\n            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n            if (value || ignoreUnknownFields) {\n                return value === null || value === void 0 ? void 0 : value.no;\n            }\n            break;\n    }\n    throw new Error(`cannot decode enum ${type.typeName} from JSON: ${debugJsonValue(json)}`);\n}\nfunction writeEnum(type, value, emitIntrinsicDefault, enumAsInteger) {\n    var _a;\n    if (value === undefined) {\n        return value;\n    }\n    if (value === 0 && !emitIntrinsicDefault) {\n        // proto3 requires 0 to be default value for all enums\n        return undefined;\n    }\n    if (enumAsInteger) {\n        return value;\n    }\n    if (type.typeName == \"google.protobuf.NullValue\") {\n        return null;\n    }\n    const val = type.findNumber(value);\n    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value; // if we don't know the enum value, just return the number\n}\nfunction writeScalar(type, value, emitIntrinsicDefault) {\n    if (value === undefined) {\n        return undefined;\n    }\n    switch(type){\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n            assert(typeof value == \"number\");\n            return value != 0 || emitIntrinsicDefault ? value : undefined;\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.FLOAT:\n        // assertFloat32(value);\n        case ScalarType.DOUBLE:\n            assert(typeof value == \"number\");\n            if (Number.isNaN(value)) return \"NaN\";\n            if (value === Number.POSITIVE_INFINITY) return \"Infinity\";\n            if (value === Number.NEGATIVE_INFINITY) return \"-Infinity\";\n            return value !== 0 || emitIntrinsicDefault ? value : undefined;\n        // string:\n        case ScalarType.STRING:\n            assert(typeof value == \"string\");\n            return value.length > 0 || emitIntrinsicDefault ? value : undefined;\n        // bool:\n        case ScalarType.BOOL:\n            assert(typeof value == \"boolean\");\n            return value || emitIntrinsicDefault ? value : undefined;\n        // JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            assert(typeof value == \"bigint\" || typeof value == \"string\" || typeof value == \"number\");\n            // We use implicit conversion with `value != 0` to catch both 0n and \"0\"\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            return emitIntrinsicDefault || value != 0 ? value.toString(10) : undefined;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            assert(value instanceof Uint8Array);\n            return emitIntrinsicDefault || value.byteLength > 0 ? protoBase64.enc(value) : undefined;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations, @typescript-eslint/restrict-plus-operands,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ function makeJsonFormatProto3() {\n    return makeJsonFormatCommon((writeEnum, writeScalar)=>{\n        return function writeField(field, value, options) {\n            if (field.kind == \"map\") {\n                const jsonObj = {};\n                switch(field.V.kind){\n                    case \"scalar\":\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            const val = writeScalar(field.V.T, entryValue, true);\n                            assert(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                    case \"message\":\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            // JSON standard allows only (double quoted) string as property key\n                            jsonObj[entryKey.toString()] = entryValue.toJson(options);\n                        }\n                        break;\n                    case \"enum\":\n                        const enumType = field.V.T;\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            assert(entryValue === undefined || typeof entryValue == \"number\");\n                            const val = writeEnum(enumType, entryValue, true, options.enumAsInteger);\n                            assert(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || Object.keys(jsonObj).length > 0 ? jsonObj : undefined;\n            } else if (field.repeated) {\n                const jsonArr = [];\n                switch(field.kind){\n                    case \"scalar\":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(writeScalar(field.T, value[i], true));\n                        }\n                        break;\n                    case \"enum\":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(writeEnum(field.T, value[i], true, options.enumAsInteger));\n                        }\n                        break;\n                    case \"message\":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(wrapField(field.T, value[i]).toJson(options));\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : undefined;\n            } else {\n                switch(field.kind){\n                    case \"scalar\":\n                        return writeScalar(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues);\n                    case \"enum\":\n                        return writeEnum(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues, options.enumAsInteger);\n                    case \"message\":\n                        return value !== undefined ? wrapField(field.T, value).toJson(options) : undefined;\n                }\n            }\n        };\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */ function makeUtilCommon() {\n    return {\n        setEnumType,\n        initPartial (source, target) {\n            if (source === undefined) {\n                return;\n            }\n            const type = target.getType();\n            for (const member of type.fields.byMember()){\n                const localName = member.localName, t = target, s = source;\n                if (s[localName] === undefined) {\n                    continue;\n                }\n                switch(member.kind){\n                    case \"oneof\":\n                        const sk = s[localName].case;\n                        if (sk === undefined) {\n                            continue;\n                        }\n                        const sourceField = member.findField(sk);\n                        let val = s[localName].value;\n                        if (sourceField && sourceField.kind == \"message\" && !(val instanceof sourceField.T)) {\n                            val = new sourceField.T(val);\n                        } else if (sourceField && sourceField.kind === \"scalar\" && sourceField.T === ScalarType.BYTES) {\n                            val = toU8Arr(val);\n                        }\n                        t[localName] = {\n                            case: sk,\n                            value: val\n                        };\n                        break;\n                    case \"scalar\":\n                    case \"enum\":\n                        let copy = s[localName];\n                        if (member.T === ScalarType.BYTES) {\n                            copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);\n                        }\n                        t[localName] = copy;\n                        break;\n                    case \"map\":\n                        switch(member.V.kind){\n                            case \"scalar\":\n                            case \"enum\":\n                                if (member.V.T === ScalarType.BYTES) {\n                                    for (const [k, v] of Object.entries(s[localName])){\n                                        t[localName][k] = toU8Arr(v);\n                                    }\n                                } else {\n                                    Object.assign(t[localName], s[localName]);\n                                }\n                                break;\n                            case \"message\":\n                                const messageType = member.V.T;\n                                for (const k of Object.keys(s[localName])){\n                                    let val = s[localName][k];\n                                    if (!messageType.fieldWrapper) {\n                                        // We only take partial input for messages that are not a wrapper type.\n                                        // For those messages, we recursively normalize the partial input.\n                                        val = new messageType(val);\n                                    }\n                                    t[localName][k] = val;\n                                }\n                                break;\n                        }\n                        break;\n                    case \"message\":\n                        const mt = member.T;\n                        if (member.repeated) {\n                            t[localName] = s[localName].map((val)=>val instanceof mt ? val : new mt(val));\n                        } else if (s[localName] !== undefined) {\n                            const val = s[localName];\n                            if (mt.fieldWrapper) {\n                                if (// We can't use BytesValue.typeName as that will create a circular import\n                                mt.typeName === \"google.protobuf.BytesValue\") {\n                                    t[localName] = toU8Arr(val);\n                                } else {\n                                    t[localName] = val;\n                                }\n                            } else {\n                                t[localName] = val instanceof mt ? val : new mt(val);\n                            }\n                        }\n                        break;\n                }\n            }\n        },\n        equals (type, a, b) {\n            if (a === b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            return type.fields.byMember().every((m)=>{\n                const va = a[m.localName];\n                const vb = b[m.localName];\n                if (m.repeated) {\n                    if (va.length !== vb.length) {\n                        return false;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never \"map\"\n                    switch(m.kind){\n                        case \"message\":\n                            return va.every((a, i)=>m.T.equals(a, vb[i]));\n                        case \"scalar\":\n                            return va.every((a, i)=>scalarEquals(m.T, a, vb[i]));\n                        case \"enum\":\n                            return va.every((a, i)=>scalarEquals(ScalarType.INT32, a, vb[i]));\n                    }\n                    throw new Error(`repeated cannot contain ${m.kind}`);\n                }\n                switch(m.kind){\n                    case \"message\":\n                        return m.T.equals(va, vb);\n                    case \"enum\":\n                        return scalarEquals(ScalarType.INT32, va, vb);\n                    case \"scalar\":\n                        return scalarEquals(m.T, va, vb);\n                    case \"oneof\":\n                        if (va.case !== vb.case) {\n                            return false;\n                        }\n                        const s = m.findField(va.case);\n                        if (s === undefined) {\n                            return true;\n                        }\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never \"map\"\n                        switch(s.kind){\n                            case \"message\":\n                                return s.T.equals(va.value, vb.value);\n                            case \"enum\":\n                                return scalarEquals(ScalarType.INT32, va.value, vb.value);\n                            case \"scalar\":\n                                return scalarEquals(s.T, va.value, vb.value);\n                        }\n                        throw new Error(`oneof cannot contain ${s.kind}`);\n                    case \"map\":\n                        const keys = Object.keys(va).concat(Object.keys(vb));\n                        switch(m.V.kind){\n                            case \"message\":\n                                const messageType = m.V.T;\n                                return keys.every((k)=>messageType.equals(va[k], vb[k]));\n                            case \"enum\":\n                                return keys.every((k)=>scalarEquals(ScalarType.INT32, va[k], vb[k]));\n                            case \"scalar\":\n                                const scalarType = m.V.T;\n                                return keys.every((k)=>scalarEquals(scalarType, va[k], vb[k]));\n                        }\n                        break;\n                }\n            });\n        },\n        clone (message) {\n            const type = message.getType(), target = new type(), any = target;\n            for (const member of type.fields.byMember()){\n                const source = message[member.localName];\n                let copy;\n                if (member.repeated) {\n                    copy = source.map(cloneSingularField);\n                } else if (member.kind == \"map\") {\n                    copy = any[member.localName];\n                    for (const [key, v] of Object.entries(source)){\n                        copy[key] = cloneSingularField(v);\n                    }\n                } else if (member.kind == \"oneof\") {\n                    const f = member.findField(source.case);\n                    copy = f ? {\n                        case: source.case,\n                        value: cloneSingularField(source.value)\n                    } : {\n                        case: undefined\n                    };\n                } else {\n                    copy = cloneSingularField(source);\n                }\n                any[member.localName] = copy;\n            }\n            return target;\n        }\n    };\n}\n// clone a single field value - i.e. the element type of repeated fields, the value type of maps\nfunction cloneSingularField(value) {\n    if (value === undefined) {\n        return value;\n    }\n    if (value instanceof Message) {\n        return value.clone();\n    }\n    if (value instanceof Uint8Array) {\n        const c = new Uint8Array(value.byteLength);\n        c.set(value);\n        return c;\n    }\n    return value;\n}\n// converts any ArrayLike<number> to Uint8Array if necessary.\nfunction toU8Arr(input) {\n    return input instanceof Uint8Array ? input : new Uint8Array(input);\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalFieldList {\n    constructor(fields, normalizer){\n        this._fields = fields;\n        this._normalizer = normalizer;\n    }\n    findJsonName(jsonName) {\n        if (!this.jsonNames) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.jsonName] = t[f.name] = f;\n            }\n            this.jsonNames = t;\n        }\n        return this.jsonNames[jsonName];\n    }\n    find(fieldNo) {\n        if (!this.numbers) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.no] = f;\n            }\n            this.numbers = t;\n        }\n        return this.numbers[fieldNo];\n    }\n    list() {\n        if (!this.all) {\n            this.all = this._normalizer(this._fields);\n        }\n        return this.all;\n    }\n    byNumber() {\n        if (!this.numbersAsc) {\n            this.numbersAsc = this.list().concat().sort((a, b)=>a.no - b.no);\n        }\n        return this.numbersAsc;\n    }\n    byMember() {\n        if (!this.members) {\n            this.members = [];\n            const a = this.members;\n            let o;\n            for (const f of this.list()){\n                if (f.oneof) {\n                    if (f.oneof !== o) {\n                        o = f.oneof;\n                        a.push(o);\n                    }\n                } else {\n                    a.push(f);\n                }\n            }\n        }\n        return this.members;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns the name of a protobuf element in generated code.\n *\n * Field names - including oneofs - are converted to lowerCamelCase. For\n * messages, enumerations and services, the package name is stripped from\n * the type name. For nested messages and enumerations, the names are joined\n * with an underscore. For methods, the first character is made lowercase.\n */ /**\n * Returns the name of a field in generated code.\n */ function localFieldName(protoName, inOneof) {\n    const name = protoCamelCase(protoName);\n    if (inOneof) {\n        // oneof member names are not properties, but values of the `case` property.\n        return name;\n    }\n    return safeObjectProperty(safeMessageProperty(name));\n}\n/**\n * Returns the name of a oneof group in generated code.\n */ function localOneofName(protoName) {\n    return localFieldName(protoName, false);\n}\n/**\n * Returns the JSON name for a protobuf field, exactly like protoc does.\n */ const fieldJsonName = protoCamelCase;\n/**\n * Converts snake_case to protoCamelCase according to the convention\n * used by protoc to convert a field name to a JSON name.\n */ function protoCamelCase(snakeCase) {\n    let capNext = false;\n    const b = [];\n    for(let i = 0; i < snakeCase.length; i++){\n        let c = snakeCase.charAt(i);\n        switch(c){\n            case \"_\":\n                capNext = true;\n                break;\n            case \"0\":\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                b.push(c);\n                capNext = false;\n                break;\n            default:\n                if (capNext) {\n                    capNext = false;\n                    c = c.toUpperCase();\n                }\n                b.push(c);\n                break;\n        }\n    }\n    return b.join(\"\");\n}\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const reservedObjectProperties = new Set([\n    // names reserved by JavaScript\n    \"constructor\",\n    \"toString\",\n    \"toJSON\",\n    \"valueOf\"\n]);\n/**\n * Names that cannot be used for object properties because they are reserved\n * by the runtime.\n */ const reservedMessageProperties = new Set([\n    // names reserved by the runtime\n    \"getType\",\n    \"clone\",\n    \"equals\",\n    \"fromBinary\",\n    \"fromJson\",\n    \"fromJsonString\",\n    \"toBinary\",\n    \"toJson\",\n    \"toJsonString\",\n    // names reserved by the runtime for the future\n    \"toObject\"\n]);\nconst fallback = (name)=>`${name}$`;\n/**\n * Will wrap names that are Object prototype properties or names reserved\n * for `Message`s.\n */ const safeMessageProperty = (name)=>{\n    if (reservedMessageProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const safeObjectProperty = (name)=>{\n    if (reservedObjectProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalOneofInfo {\n    constructor(name){\n        this.kind = \"oneof\";\n        this.repeated = false;\n        this.packed = false;\n        this.opt = false;\n        this.default = undefined;\n        this.fields = [];\n        this.name = name;\n        this.localName = localOneofName(name);\n    }\n    addField(field) {\n        assert(field.oneof === this, `field ${field.name} not one of ${this.name}`);\n        this.fields.push(field);\n    }\n    findField(localName) {\n        if (!this._lookup) {\n            this._lookup = Object.create(null);\n            for(let i = 0; i < this.fields.length; i++){\n                this._lookup[this.fields[i].localName] = this.fields[i];\n            }\n        }\n        return this._lookup[localName];\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Provides functionality for messages defined with the proto3 syntax.\n */ const proto3 = makeProtoRuntime(\"proto3\", makeJsonFormatProto3(), makeBinaryFormatProto3(), Object.assign(Object.assign({}, makeUtilCommon()), {\n    newFieldList (fields) {\n        return new InternalFieldList(fields, normalizeFieldInfosProto3);\n    },\n    initFields (target) {\n        for (const member of target.getType().fields.byMember()){\n            if (member.opt) {\n                continue;\n            }\n            const name = member.localName, t = target;\n            if (member.repeated) {\n                t[name] = [];\n                continue;\n            }\n            switch(member.kind){\n                case \"oneof\":\n                    t[name] = {\n                        case: undefined\n                    };\n                    break;\n                case \"enum\":\n                    t[name] = 0;\n                    break;\n                case \"map\":\n                    t[name] = {};\n                    break;\n                case \"scalar\":\n                    t[name] = scalarDefaultValue(member.T, member.L); // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n                    break;\n            }\n        }\n    }\n}));\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ function normalizeFieldInfosProto3(fieldInfos) {\n    var _a, _b, _c, _d;\n    const r = [];\n    let o;\n    for (const field of typeof fieldInfos == \"function\" ? fieldInfos() : fieldInfos){\n        const f = field;\n        f.localName = localFieldName(field.name, field.oneof !== undefined);\n        f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);\n        f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\n        if (field.kind == \"scalar\") {\n            f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;\n        }\n        // From the proto3 language guide:\n        // > In proto3, repeated fields of scalar numeric types are packed by default.\n        // This information is incomplete - according to the conformance tests, BOOL\n        // and ENUM are packed by default as well. This means only STRING and BYTES\n        // are not packed by default, which makes sense because they are length-delimited.\n        f.packed = (_d = field.packed) !== null && _d !== void 0 ? _d : field.kind == \"enum\" || field.kind == \"scalar\" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;\n        // We do not surface options at this time\n        // f.options = field.options ?? emptyReadonlyObject;\n        if (field.oneof !== undefined) {\n            const ooname = typeof field.oneof == \"string\" ? field.oneof : field.oneof.name;\n            if (!o || o.name != ooname) {\n                o = new InternalOneofInfo(ooname);\n            }\n            f.oneof = o;\n            o.addField(f);\n        }\n        r.push(f);\n    }\n    return r;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * MethodKind represents the four method types that can be declared in\n * protobuf with the `stream` keyword:\n *\n * 1. Unary:           rpc (Input) returns (Output)\n * 2. ServerStreaming: rpc (Input) returns (stream Output)\n * 3. ClientStreaming: rpc (stream Input) returns (Output)\n * 4. BiDiStreaming:   rpc (stream Input) returns (stream Output)\n */ var MethodKind;\n(function(MethodKind) {\n    MethodKind[MethodKind[\"Unary\"] = 0] = \"Unary\";\n    MethodKind[MethodKind[\"ServerStreaming\"] = 1] = \"ServerStreaming\";\n    MethodKind[MethodKind[\"ClientStreaming\"] = 2] = \"ClientStreaming\";\n    MethodKind[MethodKind[\"BiDiStreaming\"] = 3] = \"BiDiStreaming\";\n})(MethodKind || (MethodKind = {}));\n/**\n * Is this method side-effect-free (or safe in HTTP parlance), or just\n * idempotent, or neither? HTTP based RPC implementation may choose GET verb\n * for safe methods, and PUT verb for idempotent methods instead of the\n * default POST.\n *\n * This enum matches the protobuf enum google.protobuf.MethodOptions.IdempotencyLevel,\n * defined in the well-known type google/protobuf/descriptor.proto, but\n * drops UNKNOWN.\n */ var MethodIdempotency;\n(function(MethodIdempotency) {\n    /**\n     * Idempotent, no side effects.\n     */ MethodIdempotency[MethodIdempotency[\"NoSideEffects\"] = 1] = \"NoSideEffects\";\n    /**\n     * Idempotent, but may have side effects.\n     */ MethodIdempotency[MethodIdempotency[\"Idempotent\"] = 2] = \"Idempotent\";\n})(MethodIdempotency || (MethodIdempotency = {}));\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Connect represents categories of errors as codes, and each code maps to a\n * specific HTTP status code. The codes and their semantics were chosen to\n * match gRPC. Only the codes below are valid  there are no user-defined\n * codes.\n *\n * See the specification at https://connectrpc.com/docs/protocol#error-codes\n * for details.\n */ var Code;\n(function(Code) {\n    /**\n     * Canceled, usually be the user\n     */ Code[Code[\"Canceled\"] = 1] = \"Canceled\";\n    /**\n     * Unknown error\n     */ Code[Code[\"Unknown\"] = 2] = \"Unknown\";\n    /**\n     * Argument invalid regardless of system state\n     */ Code[Code[\"InvalidArgument\"] = 3] = \"InvalidArgument\";\n    /**\n     * Operation expired, may or may not have completed.\n     */ Code[Code[\"DeadlineExceeded\"] = 4] = \"DeadlineExceeded\";\n    /**\n     * Entity not found.\n     */ Code[Code[\"NotFound\"] = 5] = \"NotFound\";\n    /**\n     * Entity already exists.\n     */ Code[Code[\"AlreadyExists\"] = 6] = \"AlreadyExists\";\n    /**\n     * Operation not authorized.\n     */ Code[Code[\"PermissionDenied\"] = 7] = \"PermissionDenied\";\n    /**\n     * Quota exhausted.\n     */ Code[Code[\"ResourceExhausted\"] = 8] = \"ResourceExhausted\";\n    /**\n     * Argument invalid in current system state.\n     */ Code[Code[\"FailedPrecondition\"] = 9] = \"FailedPrecondition\";\n    /**\n     * Operation aborted.\n     */ Code[Code[\"Aborted\"] = 10] = \"Aborted\";\n    /**\n     * Out of bounds, use instead of FailedPrecondition.\n     */ Code[Code[\"OutOfRange\"] = 11] = \"OutOfRange\";\n    /**\n     * Operation not implemented or disabled.\n     */ Code[Code[\"Unimplemented\"] = 12] = \"Unimplemented\";\n    /**\n     * Internal error, reserved for \"serious errors\".\n     */ Code[Code[\"Internal\"] = 13] = \"Internal\";\n    /**\n     * Unavailable, client should back off and retry.\n     */ Code[Code[\"Unavailable\"] = 14] = \"Unavailable\";\n    /**\n     * Unrecoverable data loss or corruption.\n     */ Code[Code[\"DataLoss\"] = 15] = \"DataLoss\";\n    /**\n     * Request isn't authenticated.\n     */ Code[Code[\"Unauthenticated\"] = 16] = \"Unauthenticated\";\n})(Code || (Code = {}));\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * codeToString returns the string representation of a Code.\n *\n * @private Internal code, does not follow semantic versioning.\n */ function codeToString(value) {\n    const name = Code[value];\n    if (typeof name != \"string\") {\n        return value.toString();\n    }\n    return name[0].toLowerCase() + name.substring(1).replace(/[A-Z]/g, (c)=>\"_\" + c.toLowerCase());\n}\nlet stringToCode;\n/**\n * codeFromString parses the string representation of a Code in snake_case.\n * For example, the string \"permission_denied\" parses into Code.PermissionDenied.\n *\n * If the given string cannot be parsed, the function returns undefined.\n *\n * @private Internal code, does not follow semantic versioning.\n */ function codeFromString(value) {\n    if (!stringToCode) {\n        stringToCode = {};\n        for (const value of Object.values(Code)){\n            if (typeof value == \"string\") {\n                continue;\n            }\n            stringToCode[codeToString(value)] = value;\n        }\n    }\n    return stringToCode[value];\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * ConnectError captures four pieces of information: a Code, an error\n * message, an optional cause of the error, and an optional collection of\n * arbitrary Protobuf messages called  \"details\".\n *\n * Because developer tools typically show just the error message, we prefix\n * it with the status code, so that the most important information is always\n * visible immediately.\n *\n * Error details are wrapped with google.protobuf.Any on the wire, so that\n * a server or middleware can attach arbitrary data to an error. Use the\n * method findDetails() to retrieve the details.\n */ class ConnectError extends Error {\n    /**\n     * Create a new ConnectError.\n     * If no code is provided, code \"unknown\" is used.\n     * Outgoing details are only relevant for the server side - a service may\n     * raise an error with details, and it is up to the protocol implementation\n     * to encode and send the details along with error.\n     */ constructor(message, code = Code.Unknown, metadata, outgoingDetails, cause){\n        super(createMessage(message, code));\n        this.name = \"ConnectError\";\n        // see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#example\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.rawMessage = message;\n        this.code = code;\n        this.metadata = new Headers(metadata !== null && metadata !== void 0 ? metadata : {});\n        this.details = outgoingDetails !== null && outgoingDetails !== void 0 ? outgoingDetails : [];\n        this.cause = cause;\n    }\n    /**\n     * Convert any value - typically a caught error into a ConnectError,\n     * following these rules:\n     * - If the value is already a ConnectError, return it as is.\n     * - If the value is an AbortError from the fetch API, return the message\n     *   of the AbortError with code Canceled.\n     * - For other Errors, return the error message with code Unknown by default.\n     * - For other values, return the values String representation as a message,\n     *   with the code Unknown by default.\n     * The original value will be used for the \"cause\" property for the new\n     * ConnectError.\n     */ static from(reason, code = Code.Unknown) {\n        if (reason instanceof ConnectError) {\n            return reason;\n        }\n        if (reason instanceof Error) {\n            if (reason.name == \"AbortError\") {\n                // Fetch requests can only be canceled with an AbortController.\n                // We detect that condition by looking at the name of the raised\n                // error object, and translate to the appropriate status code.\n                return new ConnectError(reason.message, Code.Canceled);\n            }\n            return new ConnectError(reason.message, code, undefined, undefined, reason);\n        }\n        return new ConnectError(String(reason), code, undefined, undefined, reason);\n    }\n    findDetails(typeOrRegistry) {\n        const registry = \"typeName\" in typeOrRegistry ? {\n            findMessage: (typeName)=>typeName === typeOrRegistry.typeName ? typeOrRegistry : undefined\n        } : typeOrRegistry;\n        const details = [];\n        for (const data of this.details){\n            if (data instanceof Message) {\n                if (registry.findMessage(data.getType().typeName)) {\n                    details.push(data);\n                }\n                continue;\n            }\n            const type = registry.findMessage(data.type);\n            if (type) {\n                try {\n                    details.push(type.fromBinary(data.value));\n                } catch (_) {\n                // We silently give up if we are unable to parse the detail, because\n                // that appears to be the least worst behavior.\n                // It is very unlikely that a user surrounds a catch body handling the\n                // error with another try-catch statement, and we do not want to\n                // recommend doing so.\n                }\n            }\n        }\n        return details;\n    }\n}\n/**\n * Create an error message, prefixing the given code.\n */ function createMessage(message, code) {\n    return message.length ? `[${codeToString(code)}] ${message}` : `[${codeToString(code)}]`;\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Merge two or more Headers objects by appending all fields from\n * all inputs to a new Headers object.\n */ function appendHeaders(...headers) {\n    const h = new Headers();\n    for (const e of headers){\n        e.forEach((value, key)=>{\n            h.append(key, value);\n        });\n    }\n    return h;\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create any client for the given service.\n *\n * The given createMethod function is called for each method definition\n * of the service. The function it returns is added to the client object\n * as a method.\n */ function makeAnyClient(service, createMethod) {\n    const client = {};\n    for (const [localName, methodInfo] of Object.entries(service.methods)){\n        const method = createMethod(Object.assign(Object.assign({}, methodInfo), {\n            localName,\n            service\n        }));\n        if (method != null) {\n            client[localName] = method;\n        }\n    }\n    return client;\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a WHATWG ReadableStream of enveloped messages from a ReadableStream\n * of bytes.\n *\n * Ideally, this would simply be a TransformStream, but ReadableStream.pipeThrough\n * does not have the necessary availability at this time.\n *\n * @private Internal code, does not follow semantic versioning.\n */ function createEnvelopeReadableStream(stream) {\n    let reader;\n    let buffer = new Uint8Array(0);\n    function append(chunk) {\n        const n = new Uint8Array(buffer.length + chunk.length);\n        n.set(buffer);\n        n.set(chunk, buffer.length);\n        buffer = n;\n    }\n    return new ReadableStream({\n        start () {\n            reader = stream.getReader();\n        },\n        async pull (controller) {\n            let header = undefined;\n            for(;;){\n                if (header === undefined && buffer.byteLength >= 5) {\n                    let length = 0;\n                    for(let i = 1; i < 5; i++){\n                        length = (length << 8) + buffer[i];\n                    }\n                    header = {\n                        flags: buffer[0],\n                        length\n                    };\n                }\n                if (header !== undefined && buffer.byteLength >= header.length + 5) {\n                    break;\n                }\n                const result = await reader.read();\n                if (result.done) {\n                    break;\n                }\n                append(result.value);\n            }\n            if (header === undefined) {\n                if (buffer.byteLength == 0) {\n                    controller.close();\n                    return;\n                }\n                controller.error(new ConnectError(\"premature end of stream\", Code.DataLoss));\n                return;\n            }\n            const data = buffer.subarray(5, 5 + header.length);\n            buffer = buffer.subarray(5 + header.length);\n            controller.enqueue({\n                flags: header.flags,\n                data\n            });\n        }\n    });\n}\n/**\n * Encode a single enveloped message.\n *\n * @private Internal code, does not follow semantic versioning.\n */ function encodeEnvelope(flags, data) {\n    const bytes = new Uint8Array(data.length + 5);\n    bytes.set(data, 5);\n    const v = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    v.setUint8(0, flags); // first byte is flags\n    v.setUint32(1, data.length); // 4 bytes message length\n    return bytes;\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __asyncValues$1 =  false || function(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n};\nvar __await$2 =  false || function(v) {\n    return this instanceof __await$2 ? (this.v = v, this) : new __await$2(v);\n};\nvar __asyncGenerator$2 =  false || function(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await$2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n};\nvar __asyncDelegator$1 =  false || function(o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n        throw e;\n    }), verb(\"return\"), i[Symbol.iterator] = function() {\n        return this;\n    }, i;\n    function verb(n, f) {\n        i[n] = o[n] ? function(v) {\n            return (p = !p) ? {\n                value: __await$2(o[n](v)),\n                done: false\n            } : f ? f(v) : v;\n        } : f;\n    }\n};\n/**\n * Create an asynchronous iterable from an array.\n *\n * @private Internal code, does not follow semantic versioning.\n */ // eslint-disable-next-line @typescript-eslint/require-await\nfunction createAsyncIterable(items) {\n    return __asyncGenerator$2(this, arguments, function* createAsyncIterable_1() {\n        yield __await$2((yield* __asyncDelegator$1(__asyncValues$1(items))));\n    });\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __asyncValues =  false || function(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n};\nvar __await$1 =  false || function(v) {\n    return this instanceof __await$1 ? (this.v = v, this) : new __await$1(v);\n};\nvar __asyncDelegator =  false || function(o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n        throw e;\n    }), verb(\"return\"), i[Symbol.iterator] = function() {\n        return this;\n    }, i;\n    function verb(n, f) {\n        i[n] = o[n] ? function(v) {\n            return (p = !p) ? {\n                value: __await$1(o[n](v)),\n                done: false\n            } : f ? f(v) : v;\n        } : f;\n    }\n};\nvar __asyncGenerator$1 =  false || function(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await$1 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n};\n/**\n * Create a PromiseClient for the given service, invoking RPCs through the\n * given transport.\n */ function createPromiseClient(service, transport) {\n    return makeAnyClient(service, (method)=>{\n        switch(method.kind){\n            case MethodKind.Unary:\n                return createUnaryFn(transport, service, method);\n            case MethodKind.ServerStreaming:\n                return createServerStreamingFn(transport, service, method);\n            case MethodKind.ClientStreaming:\n                return createClientStreamingFn(transport, service, method);\n            case MethodKind.BiDiStreaming:\n                return createBiDiStreamingFn(transport, service, method);\n            default:\n                return null;\n        }\n    });\n}\nfunction createUnaryFn(transport, service, method) {\n    return async function(input, options) {\n        var _a, _b;\n        const response = await transport.unary(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, input, options === null || options === void 0 ? void 0 : options.contextValues);\n        (_a = options === null || options === void 0 ? void 0 : options.onHeader) === null || _a === void 0 ? void 0 : _a.call(options, response.header);\n        (_b = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _b === void 0 ? void 0 : _b.call(options, response.trailer);\n        return response.message;\n    };\n}\nfunction createServerStreamingFn(transport, service, method) {\n    return function(input, options) {\n        return handleStreamResponse(transport.stream(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, createAsyncIterable([\n            input\n        ]), options === null || options === void 0 ? void 0 : options.contextValues), options);\n    };\n}\nfunction createClientStreamingFn(transport, service, method) {\n    return async function(request, options) {\n        var _a, e_1, _b, _c;\n        var _d, _e;\n        const response = await transport.stream(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, request, options === null || options === void 0 ? void 0 : options.contextValues);\n        (_d = options === null || options === void 0 ? void 0 : options.onHeader) === null || _d === void 0 ? void 0 : _d.call(options, response.header);\n        let singleMessage;\n        try {\n            for(var _f = true, _g = __asyncValues(response.message), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true){\n                _c = _h.value;\n                _f = false;\n                const message = _c;\n                singleMessage = message;\n            }\n        } catch (e_1_1) {\n            e_1 = {\n                error: e_1_1\n            };\n        } finally{\n            try {\n                if (!_f && !_a && (_b = _g.return)) await _b.call(_g);\n            } finally{\n                if (e_1) throw e_1.error;\n            }\n        }\n        if (!singleMessage) {\n            throw new ConnectError(\"protocol error: missing response message\", Code.Internal);\n        }\n        (_e = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _e === void 0 ? void 0 : _e.call(options, response.trailer);\n        return singleMessage;\n    };\n}\nfunction createBiDiStreamingFn(transport, service, method) {\n    return function(request, options) {\n        return handleStreamResponse(transport.stream(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, request, options === null || options === void 0 ? void 0 : options.contextValues), options);\n    };\n}\nfunction handleStreamResponse(stream, options) {\n    const it = (function() {\n        var _a, _b;\n        return __asyncGenerator$1(this, arguments, function*() {\n            const response = yield __await$1(stream);\n            (_a = options === null || options === void 0 ? void 0 : options.onHeader) === null || _a === void 0 ? void 0 : _a.call(options, response.header);\n            yield __await$1((yield* __asyncDelegator(__asyncValues(response.message))));\n            (_b = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _b === void 0 ? void 0 : _b.call(options, response.trailer);\n        });\n    })()[Symbol.asyncIterator]();\n    // Create a new iterable to omit throw/return.\n    return {\n        [Symbol.asyncIterator]: ()=>({\n                next: ()=>it.next()\n            })\n    };\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create an AbortController that is automatically aborted if one of the given\n * signals is aborted.\n *\n * For convenience, the linked AbortSignals can be undefined.\n *\n * If the controller or any of the signals is aborted, all event listeners are\n * removed.\n *\n * @private Internal code, does not follow semantic versioning.\n */ function createLinkedAbortController(...signals) {\n    const controller = new AbortController();\n    const sa = signals.filter((s)=>s !== undefined).concat(controller.signal);\n    for (const signal of sa){\n        if (signal.aborted) {\n            onAbort.apply(signal);\n            break;\n        }\n        signal.addEventListener(\"abort\", onAbort);\n    }\n    function onAbort() {\n        if (!controller.signal.aborted) {\n            controller.abort(getAbortSignalReason(this));\n        }\n        for (const signal of sa){\n            signal.removeEventListener(\"abort\", onAbort);\n        }\n    }\n    return controller;\n}\n/**\n * Create a deadline signal. The returned object contains an AbortSignal, but\n * also a cleanup function to stop the timer, which must be called once the\n * calling code is no longer interested in the signal.\n *\n * Ideally, we would simply use AbortSignal.timeout(), but it is not widely\n * available yet.\n *\n * @private Internal code, does not follow semantic versioning.\n */ function createDeadlineSignal(timeoutMs) {\n    const controller = new AbortController();\n    const listener = ()=>{\n        controller.abort(new ConnectError(\"the operation timed out\", Code.DeadlineExceeded));\n    };\n    let timeoutId;\n    if (timeoutMs !== undefined) {\n        if (timeoutMs <= 0) listener();\n        else timeoutId = setTimeout(listener, timeoutMs);\n    }\n    return {\n        signal: controller.signal,\n        cleanup: ()=>clearTimeout(timeoutId)\n    };\n}\n/**\n * Returns the reason why an AbortSignal was aborted. Returns undefined if the\n * signal has not been aborted.\n *\n * The property AbortSignal.reason is not widely available. This function\n * returns an AbortError if the signal is aborted, but reason is undefined.\n *\n * @private Internal code, does not follow semantic versioning.\n */ function getAbortSignalReason(signal) {\n    if (!signal.aborted) {\n        return undefined;\n    }\n    if (signal.reason !== undefined) {\n        return signal.reason;\n    }\n    // AbortSignal.reason is available in Node.js v16, v18, and later,\n    // and in all browsers since early 2022.\n    const e = new Error(\"This operation was aborted\");\n    e.name = \"AbortError\";\n    return e;\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * createContextValues creates a new ContextValues.\n */ function createContextValues() {\n    return {\n        get (key) {\n            return key.id in this ? this[key.id] : key.defaultValue;\n        },\n        set (key, value) {\n            this[key.id] = value;\n            return this;\n        },\n        delete (key) {\n            delete this[key.id];\n            return this;\n        }\n    };\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a URL for the given RPC. This simply adds the qualified\n * service name, a slash, and the method name to the path of the given\n * baseUrl.\n *\n * For example, the baseUri https://example.com and method \"Say\" from\n * the service example.ElizaService results in:\n * https://example.com/example.ElizaService/Say\n *\n * This format is used by the protocols Connect, gRPC and Twirp.\n *\n * Note that this function also accepts a protocol-relative baseUrl.\n * If given an empty string or \"/\" as a baseUrl, it returns just the\n * path.\n */ function createMethodUrl(baseUrl, service, method) {\n    const s = typeof service == \"string\" ? service : service.typeName;\n    const m = typeof method == \"string\" ? method : method.name;\n    return baseUrl.toString().replace(/\\/?$/, `/${s}/${m}`);\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n *  Takes a partial protobuf messages of the\n *  specified message type as input, and returns full instances.\n */ function normalize(type, message) {\n    return message instanceof Message ? message : new type(message);\n}\n/**\n * Takes an AsyncIterable of partial protobuf messages of the\n * specified message type as input, and yields full instances.\n */ function normalizeIterable(messageType, input) {\n    function transform(result) {\n        if (result.done === true) {\n            return result;\n        }\n        return {\n            done: result.done,\n            value: normalize(messageType, result.value)\n        };\n    }\n    return {\n        [Symbol.asyncIterator] () {\n            const it = input[Symbol.asyncIterator]();\n            const res = {\n                next: ()=>it.next().then(transform)\n            };\n            if (it.throw !== undefined) {\n                res.throw = (e)=>it.throw(e).then(transform); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            }\n            if (it.return !== undefined) {\n                res.return = (v)=>it.return(v).then(transform); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            }\n            return res;\n        }\n    };\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Sets default JSON serialization options for connect-es.\n *\n * With standard protobuf JSON serialization, unknown JSON fields are\n * rejected by default. In connect-es, unknown JSON fields are ignored\n * by default.\n */ function getJsonOptions(options) {\n    var _a;\n    const o = Object.assign({}, options);\n    (_a = o.ignoreUnknownFields) !== null && _a !== void 0 ? _a : o.ignoreUnknownFields = true;\n    return o;\n}\n/**\n * Returns functions to normalize and serialize the input message\n * of an RPC, and to parse the output message of an RPC.\n *\n * @private Internal code, does not follow semantic versioning.\n */ function createClientMethodSerializers(method, useBinaryFormat, jsonOptions, binaryOptions) {\n    const input = useBinaryFormat ? createBinarySerialization(method.I, binaryOptions) : createJsonSerialization(method.I, jsonOptions);\n    const output = useBinaryFormat ? createBinarySerialization(method.O, binaryOptions) : createJsonSerialization(method.O, jsonOptions);\n    return {\n        parse: output.parse,\n        serialize: input.serialize\n    };\n}\n/**\n * Creates a Serialization object for serializing the given protobuf message\n * with the protobuf binary format.\n */ function createBinarySerialization(messageType, options) {\n    return {\n        parse (data) {\n            try {\n                return messageType.fromBinary(data, options);\n            } catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new ConnectError(`parse binary: ${m}`, Code.InvalidArgument);\n            }\n        },\n        serialize (data) {\n            try {\n                return data.toBinary(options);\n            } catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new ConnectError(`serialize binary: ${m}`, Code.Internal);\n            }\n        }\n    };\n}\n/**\n * Creates a Serialization object for serializing the given protobuf message\n * with the protobuf canonical JSON encoding.\n *\n * By default, unknown fields are ignored.\n */ function createJsonSerialization(messageType, options) {\n    var _a, _b;\n    const textEncoder = (_a = options === null || options === void 0 ? void 0 : options.textEncoder) !== null && _a !== void 0 ? _a : new TextEncoder();\n    const textDecoder = (_b = options === null || options === void 0 ? void 0 : options.textDecoder) !== null && _b !== void 0 ? _b : new TextDecoder();\n    const o = getJsonOptions(options);\n    return {\n        parse (data) {\n            try {\n                const json = textDecoder.decode(data);\n                return messageType.fromJsonString(json, o);\n            } catch (e) {\n                throw ConnectError.from(e, Code.InvalidArgument);\n            }\n        },\n        serialize (data) {\n            try {\n                const json = data.toJsonString(o);\n                return textEncoder.encode(json);\n            } catch (e) {\n                throw ConnectError.from(e, Code.Internal);\n            }\n        }\n    };\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Regular Expression that matches any valid Connect Content-Type header value.\n *\n * @private Internal code, does not follow semantic versioning.\n */ const contentTypeRegExp = /^application\\/(connect\\+)?(?:(json)(?:; ?charset=utf-?8)?|(proto))$/i;\nconst contentTypeUnaryProto = \"application/proto\";\nconst contentTypeUnaryJson = \"application/json\";\nconst contentTypeStreamProto = \"application/connect+proto\";\nconst contentTypeStreamJson = \"application/connect+json\";\n/**\n * Parse a Connect Content-Type header.\n *\n * @private Internal code, does not follow semantic versioning.\n */ function parseContentType(contentType) {\n    const match = contentType === null || contentType === void 0 ? void 0 : contentType.match(contentTypeRegExp);\n    if (!match) {\n        return undefined;\n    }\n    const stream = !!match[1];\n    const binary = !!match[3];\n    return {\n        stream,\n        binary\n    };\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n false || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\n/**\n * Parse a Connect error from a JSON value.\n * Will return a ConnectError, and throw the provided fallback if parsing failed.\n *\n * @private Internal code, does not follow semantic versioning.\n */ function errorFromJson(jsonValue, metadata, fallback) {\n    if (metadata) {\n        new Headers(metadata).forEach((value, key)=>fallback.metadata.append(key, value));\n    }\n    if (typeof jsonValue !== \"object\" || jsonValue == null || Array.isArray(jsonValue) || !(\"code\" in jsonValue) || typeof jsonValue.code !== \"string\") {\n        throw fallback;\n    }\n    const code = codeFromString(jsonValue.code);\n    if (code === undefined) {\n        throw fallback;\n    }\n    const message = jsonValue.message;\n    if (message != null && typeof message !== \"string\") {\n        throw fallback;\n    }\n    const error = new ConnectError(message !== null && message !== void 0 ? message : \"\", code, metadata);\n    if (\"details\" in jsonValue && Array.isArray(jsonValue.details)) {\n        for (const detail of jsonValue.details){\n            if (detail === null || typeof detail != \"object\" || Array.isArray(detail) || typeof detail.type != \"string\" || typeof detail.value != \"string\" || \"debug\" in detail && typeof detail.debug != \"object\") {\n                throw fallback;\n            }\n            try {\n                error.details.push({\n                    type: detail.type,\n                    value: protoBase64.dec(detail.value),\n                    debug: detail.debug\n                });\n            } catch (e) {\n                throw fallback;\n            }\n        }\n    }\n    return error;\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * endStreamFlag indicates that the data in a EnvelopedMessage\n * is a EndStreamResponse of the Connect protocol.\n *\n * @private Internal code, does not follow semantic versioning.\n */ const endStreamFlag = 2;\n/**\n * Parse an EndStreamResponse of the Connect protocol.\n * Throws a ConnectError on malformed input.\n *\n * @private Internal code, does not follow semantic versioning.\n */ function endStreamFromJson(data) {\n    const parseErr = new ConnectError(\"invalid end stream\", Code.InvalidArgument);\n    let jsonValue;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        jsonValue = JSON.parse(typeof data == \"string\" ? data : new TextDecoder().decode(data));\n    } catch (e) {\n        throw parseErr;\n    }\n    if (typeof jsonValue != \"object\" || jsonValue == null || Array.isArray(jsonValue)) {\n        throw parseErr;\n    }\n    const metadata = new Headers();\n    if (\"metadata\" in jsonValue) {\n        if (typeof jsonValue.metadata != \"object\" || jsonValue.metadata == null || Array.isArray(jsonValue.metadata)) {\n            throw parseErr;\n        }\n        for (const [key, values] of Object.entries(jsonValue.metadata)){\n            if (!Array.isArray(values) || values.some((value)=>typeof value != \"string\")) {\n                throw parseErr;\n            }\n            for (const value of values){\n                metadata.append(key, value);\n            }\n        }\n    }\n    const error = \"error\" in jsonValue ? errorFromJson(jsonValue.error, metadata, parseErr) : undefined;\n    return {\n        metadata,\n        error\n    };\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @private Internal code, does not follow semantic versioning.\n */ const headerContentType = \"Content-Type\";\nconst headerUnaryContentLength = \"Content-Length\";\nconst headerUnaryEncoding = \"Content-Encoding\";\nconst headerUnaryAcceptEncoding = \"Accept-Encoding\";\nconst headerTimeout = \"Connect-Timeout-Ms\";\nconst headerProtocolVersion = \"Connect-Protocol-Version\";\nconst headerUserAgent = \"User-Agent\";\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Determine the Connect error code for the given HTTP status code.\n * See https://connectrpc.com/docs/protocol#error-codes\n *\n * @private Internal code, does not follow semantic versioning.\n */ function codeFromHttpStatus(httpStatus) {\n    switch(httpStatus){\n        case 400:\n            return Code.InvalidArgument;\n        case 401:\n            return Code.Unauthenticated;\n        case 403:\n            return Code.PermissionDenied;\n        case 404:\n            return Code.Unimplemented;\n        case 408:\n            return Code.DeadlineExceeded;\n        case 409:\n            return Code.Aborted;\n        case 412:\n            return Code.FailedPrecondition;\n        case 413:\n            return Code.ResourceExhausted;\n        case 415:\n            return Code.Internal;\n        case 429:\n            return Code.Unavailable;\n        case 431:\n            return Code.ResourceExhausted;\n        case 502:\n            return Code.Unavailable;\n        case 503:\n            return Code.Unavailable;\n        case 504:\n            return Code.Unavailable;\n        default:\n            return Code.Unknown;\n    }\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * In unary RPCs, Connect transports trailing metadata as response header\n * fields, prefixed with \"trailer-\".\n *\n * This function demuxes headers and trailers into two separate Headers\n * objects.\n *\n * @private Internal code, does not follow semantic versioning.\n */ function trailerDemux(header) {\n    const h = new Headers(), t = new Headers();\n    header.forEach((value, key)=>{\n        if (key.toLowerCase().startsWith(\"trailer-\")) {\n            t.set(key.substring(8), value);\n        } else {\n            h.set(key, value);\n        }\n    });\n    return [\n        h,\n        t\n    ];\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * The only know value for the header Connect-Protocol-Version.\n *\n * @private Internal code, does not follow semantic versioning.\n */ const protocolVersion = \"1\";\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Creates headers for a Connect request.\n *\n * @private Internal code, does not follow semantic versioning.\n */ function requestHeader(methodKind, useBinaryFormat, timeoutMs, userProvidedHeaders) {\n    const result = new Headers(userProvidedHeaders !== null && userProvidedHeaders !== void 0 ? userProvidedHeaders : {});\n    if (timeoutMs !== undefined) {\n        result.set(headerTimeout, `${timeoutMs}`);\n    }\n    result.set(headerContentType, methodKind == MethodKind.Unary ? useBinaryFormat ? contentTypeUnaryProto : contentTypeUnaryJson : useBinaryFormat ? contentTypeStreamProto : contentTypeStreamJson);\n    result.set(headerProtocolVersion, protocolVersion);\n    result.set(headerUserAgent, \"connect-es/1.1.3\");\n    return result;\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Validates response status and header for the Connect protocol.\n * Throws a ConnectError if the header indicates an error, or if\n * the content type is unexpected, with the following exception:\n * For unary RPCs with an HTTP error status, this returns an error\n * derived from the HTTP status instead of throwing it, giving an\n * implementation a chance to parse a Connect error from the wire.\n *\n * @private Internal code, does not follow semantic versioning.\n */ function validateResponse(methodKind, status, headers) {\n    const mimeType = headers.get(\"Content-Type\");\n    const parsedType = parseContentType(mimeType);\n    if (status !== 200) {\n        const errorFromStatus = new ConnectError(`HTTP ${status}`, codeFromHttpStatus(status), headers);\n        // If parsedType is defined and it is not binary, then this is a unary JSON response\n        if (methodKind == MethodKind.Unary && parsedType && !parsedType.binary) {\n            return {\n                isUnaryError: true,\n                unaryError: errorFromStatus\n            };\n        }\n        throw errorFromStatus;\n    }\n    return {\n        isUnaryError: false\n    };\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst contentTypePrefix = \"application/\";\nfunction encodeMessageForUrl(message, useBase64) {\n    if (useBase64) {\n        // TODO(jchadwick-buf): Three regex replaces seems excessive.\n        // Can we make protoBase64.enc more flexible?\n        return protoBase64.enc(message).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n    } else {\n        return encodeURIComponent(new TextDecoder().decode(message));\n    }\n}\n/**\n * @private Internal code, does not follow semantic versioning.\n */ function transformConnectPostToGetRequest(request, message, useBase64) {\n    let query = `?connect=v${protocolVersion}`;\n    const contentType = request.header.get(headerContentType);\n    if ((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(contentTypePrefix)) === 0) {\n        query += \"&encoding=\" + encodeURIComponent(contentType.slice(contentTypePrefix.length));\n    }\n    const compression = request.header.get(headerUnaryEncoding);\n    if (compression !== null && compression !== \"identity\") {\n        query += \"&compression=\" + encodeURIComponent(compression);\n        // Force base64 for compressed payloads.\n        useBase64 = true;\n    }\n    if (useBase64) {\n        query += \"&base64=1\";\n    }\n    query += \"&message=\" + encodeMessageForUrl(message, useBase64);\n    const url = request.url + query;\n    // Omit headers that are not used for unary GET requests.\n    const header = new Headers(request.header);\n    [\n        headerProtocolVersion,\n        headerContentType,\n        headerUnaryContentLength,\n        headerUnaryEncoding,\n        headerUnaryAcceptEncoding\n    ].forEach((h)=>header.delete(h));\n    return Object.assign(Object.assign({}, request), {\n        init: Object.assign(Object.assign({}, request.init), {\n            method: \"GET\"\n        }),\n        url,\n        header\n    });\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Runs a unary method with the given interceptors. Note that this function\n * is only used when implementing a Transport.\n */ function runUnaryCall(opt) {\n    const next = applyInterceptors(opt.next, opt.interceptors);\n    const [signal, abort, done] = setupSignal(opt);\n    const req = Object.assign(Object.assign({}, opt.req), {\n        message: normalize(opt.req.method.I, opt.req.message),\n        signal\n    });\n    return next(req).then((res)=>{\n        done();\n        return res;\n    }, abort);\n}\n/**\n * Runs a server-streaming method with the given interceptors. Note that this\n * function is only used when implementing a Transport.\n */ function runStreamingCall(opt) {\n    const next = applyInterceptors(opt.next, opt.interceptors);\n    const [signal, abort, done] = setupSignal(opt);\n    const req = Object.assign(Object.assign({}, opt.req), {\n        message: normalizeIterable(opt.req.method.I, opt.req.message),\n        signal\n    });\n    let doneCalled = false;\n    // Call return on the request iterable to indicate\n    // that we will no longer consume it and it should\n    // cleanup any allocated resources.\n    signal.addEventListener(\"abort\", function() {\n        var _a, _b;\n        const it = opt.req.message[Symbol.asyncIterator]();\n        // If the signal is aborted due to an error, we want to throw\n        // the error to the request iterator.\n        if (!doneCalled) {\n            (_a = it.throw) === null || _a === void 0 ? void 0 : _a.call(it, this.reason).catch(()=>{\n            // throw returns a promise, which we don't care about.\n            //\n            // Uncaught promises are thrown at sometime/somewhere by the event loop,\n            // this is to ensure error is caught and ignored.\n            });\n        }\n        (_b = it.return) === null || _b === void 0 ? void 0 : _b.call(it).catch(()=>{\n        // return returns a promise, which we don't care about.\n        //\n        // Uncaught promises are thrown at sometime/somewhere by the event loop,\n        // this is to ensure error is caught and ignored.\n        });\n    });\n    return next(req).then((res)=>{\n        return Object.assign(Object.assign({}, res), {\n            message: {\n                [Symbol.asyncIterator] () {\n                    const it = res.message[Symbol.asyncIterator]();\n                    return {\n                        next () {\n                            return it.next().then((r)=>{\n                                if (r.done == true) {\n                                    doneCalled = true;\n                                    done();\n                                }\n                                return r;\n                            }, abort);\n                        }\n                    };\n                }\n            }\n        });\n    }, abort);\n}\n/**\n * Create an AbortSignal for Transport implementations. The signal is available\n * in UnaryRequest and StreamingRequest, and is triggered when the call is\n * aborted (via a timeout or explicit cancellation), errored (e.g. when reading\n * an error from the server from the wire), or finished successfully.\n *\n * Transport implementations can pass the signal to HTTP clients to ensure that\n * there are no unused connections leak.\n *\n * Returns a tuple:\n * [0]: The signal, which is also aborted if the optional deadline is reached.\n * [1]: Function to call if the Transport encountered an error.\n * [2]: Function to call if the Transport finished without an error.\n */ function setupSignal(opt) {\n    const { signal, cleanup } = createDeadlineSignal(opt.timeoutMs);\n    const controller = createLinkedAbortController(opt.signal, signal);\n    return [\n        controller.signal,\n        function abort(reason) {\n            // We peek at the deadline signal because fetch() will throw an error on\n            // abort that discards the signal reason.\n            const e = ConnectError.from(signal.aborted ? getAbortSignalReason(signal) : reason);\n            controller.abort(e);\n            cleanup();\n            return Promise.reject(e);\n        },\n        function done() {\n            cleanup();\n            controller.abort();\n        }\n    ];\n}\n/**\n * applyInterceptors takes the given UnaryFn or ServerStreamingFn, and wraps\n * it with each of the given interceptors, returning a new UnaryFn or\n * ServerStreamingFn.\n */ function applyInterceptors(next, interceptors) {\n    var _a;\n    return (_a = interceptors === null || interceptors === void 0 ? void 0 : interceptors.concat().reverse().reduce(// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    (n, i)=>i(n), next)) !== null && _a !== void 0 ? _a : next;\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Asserts that the fetch API is available.\n */ function assertFetchApi() {\n    try {\n        new Headers();\n    } catch (_) {\n        throw new Error(\"connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.\");\n    }\n}\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __await =  false || function(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n};\nvar __asyncGenerator =  false || function(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n};\n/**\n * Create a Transport for the Connect protocol, which makes unary and\n * server-streaming methods available to web browsers. It uses the fetch\n * API to make HTTP requests.\n */ function createConnectTransport(options) {\n    var _a;\n    assertFetchApi();\n    const useBinaryFormat = (_a = options.useBinaryFormat) !== null && _a !== void 0 ? _a : false;\n    return {\n        async unary (service, method, signal, timeoutMs, header, message, contextValues) {\n            var _a;\n            const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            timeoutMs = timeoutMs === undefined ? options.defaultTimeoutMs : timeoutMs <= 0 ? undefined : timeoutMs;\n            return await runUnaryCall({\n                interceptors: options.interceptors,\n                signal,\n                timeoutMs,\n                req: {\n                    stream: false,\n                    service,\n                    method,\n                    url: createMethodUrl(options.baseUrl, service, method),\n                    init: {\n                        method: \"POST\",\n                        credentials: (_a = options.credentials) !== null && _a !== void 0 ? _a : \"same-origin\",\n                        redirect: \"error\",\n                        mode: \"cors\"\n                    },\n                    header: requestHeader(method.kind, useBinaryFormat, timeoutMs, header),\n                    contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),\n                    message\n                },\n                next: async (req)=>{\n                    var _a;\n                    const useGet = options.useHttpGet === true && method.idempotency === MethodIdempotency.NoSideEffects;\n                    let body = null;\n                    if (useGet) {\n                        req = transformConnectPostToGetRequest(req, serialize(req.message), useBinaryFormat);\n                    } else {\n                        body = serialize(req.message);\n                    }\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const response = await fetch(req.url, Object.assign(Object.assign({}, req.init), {\n                        headers: req.header,\n                        signal: req.signal,\n                        body\n                    }));\n                    const { isUnaryError, unaryError } = validateResponse(method.kind, response.status, response.headers);\n                    if (isUnaryError) {\n                        throw errorFromJson(await response.json(), appendHeaders(...trailerDemux(response.headers)), unaryError);\n                    }\n                    const [demuxedHeader, demuxedTrailer] = trailerDemux(response.headers);\n                    return {\n                        stream: false,\n                        service,\n                        method,\n                        header: demuxedHeader,\n                        message: useBinaryFormat ? parse(new Uint8Array(await response.arrayBuffer())) : method.O.fromJson(await response.json(), getJsonOptions(options.jsonOptions)),\n                        trailer: demuxedTrailer\n                    };\n                }\n            });\n        },\n        async stream (service, method, signal, timeoutMs, header, input, contextValues) {\n            var _a;\n            const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            function parseResponseBody(body, trailerTarget) {\n                return __asyncGenerator(this, arguments, function* parseResponseBody_1() {\n                    const reader = createEnvelopeReadableStream(body).getReader();\n                    let endStreamReceived = false;\n                    for(;;){\n                        const result = yield __await(reader.read());\n                        if (result.done) {\n                            break;\n                        }\n                        const { flags, data } = result.value;\n                        if ((flags & endStreamFlag) === endStreamFlag) {\n                            endStreamReceived = true;\n                            const endStream = endStreamFromJson(data);\n                            if (endStream.error) {\n                                throw endStream.error;\n                            }\n                            endStream.metadata.forEach((value, key)=>trailerTarget.set(key, value));\n                            continue;\n                        }\n                        yield yield __await(parse(data));\n                    }\n                    if (!endStreamReceived) {\n                        throw \"missing EndStreamResponse\";\n                    }\n                });\n            }\n            async function createRequestBody(input) {\n                if (method.kind != MethodKind.ServerStreaming) {\n                    throw \"The fetch API does not support streaming request bodies\";\n                }\n                const r = await input[Symbol.asyncIterator]().next();\n                if (r.done == true) {\n                    throw \"missing request message\";\n                }\n                return encodeEnvelope(0, serialize(r.value));\n            }\n            timeoutMs = timeoutMs === undefined ? options.defaultTimeoutMs : timeoutMs <= 0 ? undefined : timeoutMs;\n            return await runStreamingCall({\n                interceptors: options.interceptors,\n                timeoutMs,\n                signal,\n                req: {\n                    stream: true,\n                    service,\n                    method,\n                    url: createMethodUrl(options.baseUrl, service, method),\n                    init: {\n                        method: \"POST\",\n                        credentials: (_a = options.credentials) !== null && _a !== void 0 ? _a : \"same-origin\",\n                        redirect: \"error\",\n                        mode: \"cors\"\n                    },\n                    header: requestHeader(method.kind, useBinaryFormat, timeoutMs, header),\n                    contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),\n                    message: input\n                },\n                next: async (req)=>{\n                    var _a;\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const fRes = await fetch(req.url, Object.assign(Object.assign({}, req.init), {\n                        headers: req.header,\n                        signal: req.signal,\n                        body: await createRequestBody(req.message)\n                    }));\n                    validateResponse(method.kind, fRes.status, fRes.headers);\n                    if (fRes.body === null) {\n                        throw \"missing response body\";\n                    }\n                    const trailer = new Headers();\n                    const res = Object.assign(Object.assign({}, req), {\n                        header: fRes.headers,\n                        trailer,\n                        message: parseResponseBody(fRes.body, trailer)\n                    });\n                    return res;\n                }\n            });\n        }\n    };\n}\n/**\n * Status of the Codeium AI completions generation.\n */ var Status;\n(function(Status) {\n    Status[\"INACTIVE\"] = \"inactive\";\n    Status[\"PROCESSING\"] = \"processing\";\n    Status[\"SUCCESS\"] = \"success\";\n    Status[\"WARNING\"] = \"warning\";\n    Status[\"ERROR\"] = \"error\";\n})(Status || (Status = {}));\nfunction _defineProperty$1(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _defineProperty$1(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction compose$1() {\n    for(var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++){\n        fns[_key] = arguments[_key];\n    }\n    return function(x) {\n        return fns.reduceRight(function(y, f) {\n            return f(y);\n        }, x);\n    };\n}\nfunction curry$1(fn) {\n    return function curried() {\n        var _this = this;\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        return args.length >= fn.length ? fn.apply(this, args) : function() {\n            for(var _len3 = arguments.length, nextArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n                nextArgs[_key3] = arguments[_key3];\n            }\n            return curried.apply(_this, [].concat(args, nextArgs));\n        };\n    };\n}\nfunction isObject$1(value) {\n    return ({}).toString.call(value).includes(\"Object\");\n}\nfunction isEmpty(obj) {\n    return !Object.keys(obj).length;\n}\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\nfunction hasOwnProperty(object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n}\nfunction validateChanges(initial, changes) {\n    if (!isObject$1(changes)) errorHandler$1(\"changeType\");\n    if (Object.keys(changes).some(function(field) {\n        return !hasOwnProperty(initial, field);\n    })) errorHandler$1(\"changeField\");\n    return changes;\n}\nfunction validateSelector(selector) {\n    if (!isFunction(selector)) errorHandler$1(\"selectorType\");\n}\nfunction validateHandler(handler) {\n    if (!(isFunction(handler) || isObject$1(handler))) errorHandler$1(\"handlerType\");\n    if (isObject$1(handler) && Object.values(handler).some(function(_handler) {\n        return !isFunction(_handler);\n    })) errorHandler$1(\"handlersType\");\n}\nfunction validateInitial(initial) {\n    if (!initial) errorHandler$1(\"initialIsRequired\");\n    if (!isObject$1(initial)) errorHandler$1(\"initialType\");\n    if (isEmpty(initial)) errorHandler$1(\"initialContent\");\n}\nfunction throwError$1(errorMessages, type) {\n    throw new Error(errorMessages[type] || errorMessages[\"default\"]);\n}\nvar errorMessages$1 = {\n    initialIsRequired: \"initial state is required\",\n    initialType: \"initial state should be an object\",\n    initialContent: \"initial state shouldn't be an empty object\",\n    handlerType: \"handler should be an object or a function\",\n    handlersType: \"all handlers should be a functions\",\n    selectorType: \"selector should be a function\",\n    changeType: \"provided value of changes should be an object\",\n    changeField: 'it seams you want to change a field in the state which is not specified in the \"initial\" state',\n    \"default\": \"an unknown error accured in `state-local` package\"\n};\nvar errorHandler$1 = curry$1(throwError$1)(errorMessages$1);\nvar validators$1 = {\n    changes: validateChanges,\n    selector: validateSelector,\n    handler: validateHandler,\n    initial: validateInitial\n};\nfunction create(initial) {\n    var handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    validators$1.initial(initial);\n    validators$1.handler(handler);\n    var state = {\n        current: initial\n    };\n    var didUpdate = curry$1(didStateUpdate)(state, handler);\n    var update = curry$1(updateState)(state);\n    var validate = curry$1(validators$1.changes)(initial);\n    var getChanges = curry$1(extractChanges)(state);\n    function getState() {\n        var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function(state) {\n            return state;\n        };\n        validators$1.selector(selector);\n        return selector(state.current);\n    }\n    function setState(causedChanges) {\n        compose$1(didUpdate, update, validate, getChanges)(causedChanges);\n    }\n    return [\n        getState,\n        setState\n    ];\n}\nfunction extractChanges(state, causedChanges) {\n    return isFunction(causedChanges) ? causedChanges(state.current) : causedChanges;\n}\nfunction updateState(state, changes) {\n    state.current = _objectSpread2(_objectSpread2({}, state.current), changes);\n    return changes;\n}\nfunction didStateUpdate(state, handler, changes) {\n    isFunction(handler) ? handler(state.current) : Object.keys(changes).forEach(function(field) {\n        var _handler$field;\n        return (_handler$field = handler[field]) === null || _handler$field === void 0 ? void 0 : _handler$field.call(handler, state.current[field]);\n    });\n    return changes;\n}\nvar index = {\n    create: create\n};\nvar config$1 = {\n    paths: {\n        vs: \"https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs\"\n    }\n};\nfunction curry(fn) {\n    return function curried() {\n        var _this = this;\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return args.length >= fn.length ? fn.apply(this, args) : function() {\n            for(var _len2 = arguments.length, nextArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n                nextArgs[_key2] = arguments[_key2];\n            }\n            return curried.apply(_this, [].concat(args, nextArgs));\n        };\n    };\n}\nfunction isObject(value) {\n    return ({}).toString.call(value).includes(\"Object\");\n}\n/**\n * validates the configuration object and informs about deprecation\n * @param {Object} config - the configuration object \n * @return {Object} config - the validated configuration object\n */ function validateConfig(config) {\n    if (!config) errorHandler(\"configIsRequired\");\n    if (!isObject(config)) errorHandler(\"configType\");\n    if (config.urls) {\n        informAboutDeprecation();\n        return {\n            paths: {\n                vs: config.urls.monacoBase\n            }\n        };\n    }\n    return config;\n}\n/**\n * logs deprecation message\n */ function informAboutDeprecation() {\n    console.warn(errorMessages.deprecation);\n}\nfunction throwError(errorMessages, type) {\n    throw new Error(errorMessages[type] || errorMessages[\"default\"]);\n}\nvar errorMessages = {\n    configIsRequired: \"the configuration object is required\",\n    configType: \"the configuration object should be an object\",\n    \"default\": \"an unknown error accured in `@monaco-editor/loader` package\",\n    deprecation: \"Deprecation warning!\\n    You are using deprecated way of configuration.\\n\\n    Instead of using\\n      monaco.config({ urls: { monacoBase: '...' } })\\n    use\\n      monaco.config({ paths: { vs: '...' } })\\n\\n    For more please check the link https://github.com/suren-atoyan/monaco-loader#config\\n  \"\n};\nvar errorHandler = curry(throwError)(errorMessages);\nvar validators = {\n    config: validateConfig\n};\nvar compose = function compose() {\n    for(var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++){\n        fns[_key] = arguments[_key];\n    }\n    return function(x) {\n        return fns.reduceRight(function(y, f) {\n            return f(y);\n        }, x);\n    };\n};\nfunction merge(target, source) {\n    Object.keys(source).forEach(function(key) {\n        if (source[key] instanceof Object) {\n            if (target[key]) {\n                Object.assign(source[key], merge(target[key], source[key]));\n            }\n        }\n    });\n    return _objectSpread2$1(_objectSpread2$1({}, target), source);\n}\n// The source (has been changed) is https://github.com/facebook/react/issues/5465#issuecomment-157888325\nvar CANCELATION_MESSAGE = {\n    type: \"cancelation\",\n    msg: \"operation is manually canceled\"\n};\nfunction makeCancelable(promise) {\n    var hasCanceled_ = false;\n    var wrappedPromise = new Promise(function(resolve, reject) {\n        promise.then(function(val) {\n            return hasCanceled_ ? reject(CANCELATION_MESSAGE) : resolve(val);\n        });\n        promise[\"catch\"](reject);\n    });\n    return wrappedPromise.cancel = function() {\n        return hasCanceled_ = true;\n    }, wrappedPromise;\n}\n/** the local state of the module */ var _state$create = index.create({\n    config: config$1,\n    isInitialized: false,\n    resolve: null,\n    reject: null,\n    monaco: null\n}), _state$create2 = _slicedToArray(_state$create, 2), getState = _state$create2[0], setState = _state$create2[1];\n/**\n * set the loader configuration\n * @param {Object} config - the configuration object\n */ function config(globalConfig) {\n    var _validators$config = validators.config(globalConfig), monaco = _validators$config.monaco, config = _objectWithoutProperties(_validators$config, [\n        \"monaco\"\n    ]);\n    setState(function(state) {\n        return {\n            config: merge(state.config, config),\n            monaco: monaco\n        };\n    });\n}\n/**\n * handles the initialization of the monaco-editor\n * @return {Promise} - returns an instance of monaco (with a cancelable promise)\n */ function init() {\n    var state = getState(function(_ref) {\n        var monaco = _ref.monaco, isInitialized = _ref.isInitialized, resolve = _ref.resolve;\n        return {\n            monaco: monaco,\n            isInitialized: isInitialized,\n            resolve: resolve\n        };\n    });\n    if (!state.isInitialized) {\n        setState({\n            isInitialized: true\n        });\n        if (state.monaco) {\n            state.resolve(state.monaco);\n            return makeCancelable(wrapperPromise);\n        }\n        if (window.monaco && window.monaco.editor) {\n            storeMonacoInstance(window.monaco);\n            state.resolve(window.monaco);\n            return makeCancelable(wrapperPromise);\n        }\n        compose(injectScripts, getMonacoLoaderScript)(configureLoader);\n    }\n    return makeCancelable(wrapperPromise);\n}\n/**\n * injects provided scripts into the document.body\n * @param {Object} script - an HTML script element\n * @return {Object} - the injected HTML script element\n */ function injectScripts(script) {\n    return document.body.appendChild(script);\n}\n/**\n * creates an HTML script element with/without provided src\n * @param {string} [src] - the source path of the script\n * @return {Object} - the created HTML script element\n */ function createScript(src) {\n    var script = document.createElement(\"script\");\n    return src && (script.src = src), script;\n}\n/**\n * creates an HTML script element with the monaco loader src\n * @return {Object} - the created HTML script element\n */ function getMonacoLoaderScript(configureLoader) {\n    var state = getState(function(_ref2) {\n        var config = _ref2.config, reject = _ref2.reject;\n        return {\n            config: config,\n            reject: reject\n        };\n    });\n    var loaderScript = createScript(\"\".concat(state.config.paths.vs, \"/loader.js\"));\n    loaderScript.onload = function() {\n        return configureLoader();\n    };\n    loaderScript.onerror = state.reject;\n    return loaderScript;\n}\n/**\n * configures the monaco loader\n */ function configureLoader() {\n    var state = getState(function(_ref3) {\n        var config = _ref3.config, resolve = _ref3.resolve, reject = _ref3.reject;\n        return {\n            config: config,\n            resolve: resolve,\n            reject: reject\n        };\n    });\n    var require = window.require;\n    require.config(state.config);\n    require([\n        \"vs/editor/editor.main\"\n    ], function(monaco) {\n        storeMonacoInstance(monaco);\n        state.resolve(monaco);\n    }, function(error) {\n        state.reject(error);\n    });\n}\n/**\n * store monaco instance in local state\n */ function storeMonacoInstance(monaco) {\n    if (!getState().monaco) {\n        setState({\n            monaco: monaco\n        });\n    }\n}\n/**\n * internal helper function\n * extracts stored monaco instance\n * @return {Object|null} - the monaco instance\n */ function __getMonacoInstance() {\n    return getState(function(_ref4) {\n        var monaco = _ref4.monaco;\n        return monaco;\n    });\n}\nvar wrapperPromise = new Promise(function(resolve, reject) {\n    return setState({\n        resolve: resolve,\n        reject: reject\n    });\n});\nvar loader = {\n    config: config,\n    init: init,\n    __getMonacoInstance: __getMonacoInstance\n};\nvar le = {\n    wrapper: {\n        display: \"flex\",\n        position: \"relative\",\n        textAlign: \"initial\"\n    },\n    fullWidth: {\n        width: \"100%\"\n    },\n    hide: {\n        display: \"none\"\n    }\n}, v = le;\nvar ae = {\n    container: {\n        display: \"flex\",\n        height: \"100%\",\n        width: \"100%\",\n        justifyContent: \"center\",\n        alignItems: \"center\"\n    }\n}, Y = ae;\nfunction Me({ children: e }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        style: Y.container\n    }, e);\n}\nvar Z = Me;\nvar $ = Z;\nfunction Ee({ width: e, height: r, isEditorReady: n, loading: t, _ref: a, className: m, wrapperProps: E }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"section\", {\n        style: {\n            ...v.wrapper,\n            width: e,\n            height: r\n        },\n        ...E\n    }, !n && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement($, null, t), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: a,\n        style: {\n            ...v.fullWidth,\n            ...!n && v.hide\n        },\n        className: m\n    }));\n}\nvar ee = Ee;\nvar H = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(ee);\nfunction Ce(e) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(e, []);\n}\nvar k = Ce;\nfunction he(e, r, n = !0) {\n    let t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!0);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(t.current || !n ? ()=>{\n        t.current = !1;\n    } : e, r);\n}\nvar l = he;\nfunction D() {}\nfunction h(e, r, n, t) {\n    return De(e, t) || be(e, r, n, t);\n}\nfunction De(e, r) {\n    return e.editor.getModel(te(e, r));\n}\nfunction be(e, r, n, t) {\n    return e.editor.createModel(r, n, t ? te(e, t) : void 0);\n}\nfunction te(e, r) {\n    return e.Uri.parse(r);\n}\nfunction Oe({ original: e, modified: r, language: n, originalLanguage: t, modifiedLanguage: a, originalModelPath: m, modifiedModelPath: E, keepCurrentOriginalModel: g = !1, keepCurrentModifiedModel: N = !1, theme: x = \"light\", loading: P = \"Loading...\", options: y = {}, height: V = \"100%\", width: z = \"100%\", className: F, wrapperProps: j = {}, beforeMount: A = D, onMount: q = D }) {\n    let [M, O] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [T, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!0), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), w = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(q), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(A), b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1);\n    k(()=>{\n        let i = loader.init();\n        return i.then((f)=>(c.current = f) && s(!1)).catch((f)=>f?.type !== \"cancelation\" && console.error(\"Monaco initialization: error:\", f)), ()=>u.current ? I() : i.cancel();\n    }), l(()=>{\n        if (u.current && c.current) {\n            let i = u.current.getOriginalEditor(), f = h(c.current, e || \"\", t || n || \"text\", m || \"\");\n            f !== i.getModel() && i.setModel(f);\n        }\n    }, [\n        m\n    ], M), l(()=>{\n        if (u.current && c.current) {\n            let i = u.current.getModifiedEditor(), f = h(c.current, r || \"\", a || n || \"text\", E || \"\");\n            f !== i.getModel() && i.setModel(f);\n        }\n    }, [\n        E\n    ], M), l(()=>{\n        let i = u.current.getModifiedEditor();\n        i.getOption(c.current.editor.EditorOption.readOnly) ? i.setValue(r || \"\") : r !== i.getValue() && (i.executeEdits(\"\", [\n            {\n                range: i.getModel().getFullModelRange(),\n                text: r || \"\",\n                forceMoveMarkers: !0\n            }\n        ]), i.pushUndoStop());\n    }, [\n        r\n    ], M), l(()=>{\n        u.current?.getModel()?.original.setValue(e || \"\");\n    }, [\n        e\n    ], M), l(()=>{\n        let { original: i, modified: f } = u.current.getModel();\n        c.current.editor.setModelLanguage(i, t || n || \"text\"), c.current.editor.setModelLanguage(f, a || n || \"text\");\n    }, [\n        n,\n        t,\n        a\n    ], M), l(()=>{\n        c.current?.editor.setTheme(x);\n    }, [\n        x\n    ], M), l(()=>{\n        u.current?.updateOptions(y);\n    }, [\n        y\n    ], M);\n    let L = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!c.current) return;\n        o.current(c.current);\n        let i = h(c.current, e || \"\", t || n || \"text\", m || \"\"), f = h(c.current, r || \"\", a || n || \"text\", E || \"\");\n        u.current?.setModel({\n            original: i,\n            modified: f\n        });\n    }, [\n        n,\n        r,\n        a,\n        e,\n        t,\n        m,\n        E\n    ]), U = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        !b.current && w.current && (u.current = c.current.editor.createDiffEditor(w.current, {\n            automaticLayout: !0,\n            ...y\n        }), L(), c.current?.editor.setTheme(x), O(!0), b.current = !0);\n    }, [\n        y,\n        x,\n        L\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        M && d.current(u.current, c.current);\n    }, [\n        M\n    ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        !T && !M && U();\n    }, [\n        T,\n        M,\n        U\n    ]);\n    function I() {\n        let i = u.current?.getModel();\n        g || i?.original?.dispose(), N || i?.modified?.dispose(), u.current?.dispose();\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(H, {\n        width: z,\n        height: V,\n        isEditorReady: M,\n        loading: P,\n        _ref: w,\n        className: F,\n        wrapperProps: j\n    });\n}\nvar ie = Oe;\n/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(ie);\nfunction He(e) {\n    let r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        r.current = e;\n    }, [\n        e\n    ]), r.current;\n}\nvar se = He;\nvar _ = new Map;\nfunction Ve({ defaultValue: e, defaultLanguage: r, defaultPath: n, value: t, language: a, path: m, theme: E = \"light\", line: g, loading: N = \"Loading...\", options: x = {}, overrideServices: P = {}, saveViewState: y = !0, keepCurrentModel: V = !1, width: z = \"100%\", height: F = \"100%\", className: j, wrapperProps: A = {}, beforeMount: q = D, onMount: M = D, onChange: O, onValidate: T = D }) {\n    let [s, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [c, w] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!0), d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), L = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(M), U = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(q), I = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(t), f = se(m), Q = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), B = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1);\n    k(()=>{\n        let p = loader.init();\n        return p.then((R)=>(d.current = R) && w(!1)).catch((R)=>R?.type !== \"cancelation\" && console.error(\"Monaco initialization: error:\", R)), ()=>o.current ? pe() : p.cancel();\n    }), l(()=>{\n        let p = h(d.current, e || t || \"\", r || a || \"\", m || n || \"\");\n        p !== o.current?.getModel() && (y && _.set(f, o.current?.saveViewState()), o.current?.setModel(p), y && o.current?.restoreViewState(_.get(m)));\n    }, [\n        m\n    ], s), l(()=>{\n        o.current?.updateOptions(x);\n    }, [\n        x\n    ], s), l(()=>{\n        !o.current || t === void 0 || (o.current.getOption(d.current.editor.EditorOption.readOnly) ? o.current.setValue(t) : t !== o.current.getValue() && (B.current = !0, o.current.executeEdits(\"\", [\n            {\n                range: o.current.getModel().getFullModelRange(),\n                text: t,\n                forceMoveMarkers: !0\n            }\n        ]), o.current.pushUndoStop(), B.current = !1));\n    }, [\n        t\n    ], s), l(()=>{\n        let p = o.current?.getModel();\n        p && a && d.current?.editor.setModelLanguage(p, a);\n    }, [\n        a\n    ], s), l(()=>{\n        g !== void 0 && o.current?.revealLine(g);\n    }, [\n        g\n    ], s), l(()=>{\n        d.current?.editor.setTheme(E);\n    }, [\n        E\n    ], s);\n    let X = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!(!b.current || !d.current) && !Q.current) {\n            U.current(d.current);\n            let p = m || n, R = h(d.current, t || e || \"\", r || a || \"\", p || \"\");\n            o.current = d.current?.editor.create(b.current, {\n                model: R,\n                automaticLayout: !0,\n                ...x\n            }, P), y && o.current.restoreViewState(_.get(p)), d.current.editor.setTheme(E), g !== void 0 && o.current.revealLine(g), u(!0), Q.current = !0;\n        }\n    }, [\n        e,\n        r,\n        n,\n        t,\n        a,\n        m,\n        x,\n        P,\n        y,\n        E,\n        g\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        s && L.current(o.current, d.current);\n    }, [\n        s\n    ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        !c && !s && X();\n    }, [\n        c,\n        s,\n        X\n    ]), i.current = t, (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        s && O && (I.current?.dispose(), I.current = o.current?.onDidChangeModelContent((p)=>{\n            B.current || O(o.current.getValue(), p);\n        }));\n    }, [\n        s,\n        O\n    ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (s) {\n            let p = d.current.editor.onDidChangeMarkers((R)=>{\n                let G = o.current.getModel()?.uri;\n                if (G && R.find((J)=>J.path === G.path)) {\n                    let J = d.current.editor.getModelMarkers({\n                        resource: G\n                    });\n                    T?.(J);\n                }\n            });\n            return ()=>{\n                p?.dispose();\n            };\n        }\n        return ()=>{};\n    }, [\n        s,\n        T\n    ]);\n    function pe() {\n        I.current?.dispose(), V ? y && _.set(m, o.current.saveViewState()) : o.current.getModel()?.dispose(), o.current.dispose();\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(H, {\n        width: z,\n        height: F,\n        isEditorReady: s,\n        loading: N,\n        _ref: b,\n        className: j,\n        wrapperProps: A\n    });\n}\nvar fe = Ve;\nvar de = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(fe);\nvar Ft = de;\nconst getDefaultValue = (language)=>{\n    switch(language){\n        case \"typescript\":\n        case \"tsx\":\n        case \"javascript\":\n        case \"java\":\n            return `// Welcome to Codeium Editor!\n// Press Enter and use Tab to accept AI suggestions. Here's an example:\n\n// fib(n) function to calculate the n-th fibonacci number`;\n        case \"python\":\n            return `# Welcome to Codeium Editor!\n# Press Enter and use Tab to accept AI suggestions. Here's an example:\n\n# fib(n) function to calculate the n-th fibonacci number`;\n        case \"css\":\n            return `/* Welcome to Codeium Editor!\nPress Enter and use Tab to accept AI suggestions. Here's an example:*/\n\n/* .action-button class with a hover effect. */`;\n        default:\n            return \"\";\n    }\n};\n// Copyright Exafunction, Inc.\n/**\n * @generated from enum exa.codeium_common_pb.ExperimentKey\n */ var ExperimentKey;\n(function(ExperimentKey) {\n    /**\n     * @generated from enum value: UNSPECIFIED = 0;\n     */ ExperimentKey[ExperimentKey[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from enum value: JUPYTER_FORMAT = 77;\n     */ ExperimentKey[ExperimentKey[\"JUPYTER_FORMAT\"] = 77] = \"JUPYTER_FORMAT\";\n})(ExperimentKey || (ExperimentKey = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ExperimentKey)\nproto3.util.setEnumType(ExperimentKey, \"exa.codeium_common_pb.ExperimentKey\", [\n    {\n        no: 0,\n        name: \"UNSPECIFIED\"\n    },\n    {\n        no: 77,\n        name: \"JUPYTER_FORMAT\"\n    }\n]);\n/**\n * Authentication source for users on the cloud service.\n *\n * @generated from enum exa.codeium_common_pb.AuthSource\n */ var AuthSource;\n(function(AuthSource) {\n    /**\n     * @generated from enum value: AUTH_SOURCE_CODEIUM = 0;\n     */ AuthSource[AuthSource[\"CODEIUM\"] = 0] = \"CODEIUM\";\n})(AuthSource || (AuthSource = {}));\n// Retrieve enum metadata with: proto3.getEnumType(AuthSource)\nproto3.util.setEnumType(AuthSource, \"exa.codeium_common_pb.AuthSource\", [\n    {\n        no: 0,\n        name: \"AUTH_SOURCE_CODEIUM\"\n    }\n]);\n/**\n * @generated from enum exa.codeium_common_pb.EventType\n */ var EventType;\n(function(EventType) {\n    /**\n     * @generated from enum value: EVENT_TYPE_UNSPECIFIED = 0;\n     */ EventType[EventType[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from enum value: EVENT_TYPE_ENABLE_CODEIUM = 1;\n     */ EventType[EventType[\"ENABLE_CODEIUM\"] = 1] = \"ENABLE_CODEIUM\";\n    /**\n     * @generated from enum value: EVENT_TYPE_DISABLE_CODEIUM = 2;\n     */ EventType[EventType[\"DISABLE_CODEIUM\"] = 2] = \"DISABLE_CODEIUM\";\n    /**\n     * @generated from enum value: EVENT_TYPE_SHOW_PREVIOUS_COMPLETION = 3;\n     */ EventType[EventType[\"SHOW_PREVIOUS_COMPLETION\"] = 3] = \"SHOW_PREVIOUS_COMPLETION\";\n    /**\n     * @generated from enum value: EVENT_TYPE_SHOW_NEXT_COMPLETION = 4;\n     */ EventType[EventType[\"SHOW_NEXT_COMPLETION\"] = 4] = \"SHOW_NEXT_COMPLETION\";\n})(EventType || (EventType = {}));\n// Retrieve enum metadata with: proto3.getEnumType(EventType)\nproto3.util.setEnumType(EventType, \"exa.codeium_common_pb.EventType\", [\n    {\n        no: 0,\n        name: \"EVENT_TYPE_UNSPECIFIED\"\n    },\n    {\n        no: 1,\n        name: \"EVENT_TYPE_ENABLE_CODEIUM\"\n    },\n    {\n        no: 2,\n        name: \"EVENT_TYPE_DISABLE_CODEIUM\"\n    },\n    {\n        no: 3,\n        name: \"EVENT_TYPE_SHOW_PREVIOUS_COMPLETION\"\n    },\n    {\n        no: 4,\n        name: \"EVENT_TYPE_SHOW_NEXT_COMPLETION\"\n    }\n]);\n/**\n * @generated from enum exa.codeium_common_pb.CompletionSource\n */ var CompletionSource;\n(function(CompletionSource) {\n    /**\n     * @generated from enum value: COMPLETION_SOURCE_UNSPECIFIED = 0;\n     */ CompletionSource[CompletionSource[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from enum value: COMPLETION_SOURCE_TYPING_AS_SUGGESTED = 1;\n     */ CompletionSource[CompletionSource[\"TYPING_AS_SUGGESTED\"] = 1] = \"TYPING_AS_SUGGESTED\";\n    /**\n     * @generated from enum value: COMPLETION_SOURCE_CACHE = 2;\n     */ CompletionSource[CompletionSource[\"CACHE\"] = 2] = \"CACHE\";\n    /**\n     * @generated from enum value: COMPLETION_SOURCE_NETWORK = 3;\n     */ CompletionSource[CompletionSource[\"NETWORK\"] = 3] = \"NETWORK\";\n})(CompletionSource || (CompletionSource = {}));\n// Retrieve enum metadata with: proto3.getEnumType(CompletionSource)\nproto3.util.setEnumType(CompletionSource, \"exa.codeium_common_pb.CompletionSource\", [\n    {\n        no: 0,\n        name: \"COMPLETION_SOURCE_UNSPECIFIED\"\n    },\n    {\n        no: 1,\n        name: \"COMPLETION_SOURCE_TYPING_AS_SUGGESTED\"\n    },\n    {\n        no: 2,\n        name: \"COMPLETION_SOURCE_CACHE\"\n    },\n    {\n        no: 3,\n        name: \"COMPLETION_SOURCE_NETWORK\"\n    }\n]);\n/**\n * Every time this list is updated, we should be redeploying the API server\n * since it uses the string representation for BQ.\n *\n * @generated from enum exa.codeium_common_pb.Language\n */ var Language;\n(function(Language) {\n    /**\n     * @generated from enum value: LANGUAGE_UNSPECIFIED = 0;\n     */ Language[Language[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from enum value: LANGUAGE_C = 1;\n     */ Language[Language[\"C\"] = 1] = \"C\";\n    /**\n     * @generated from enum value: LANGUAGE_CLOJURE = 2;\n     */ Language[Language[\"CLOJURE\"] = 2] = \"CLOJURE\";\n    /**\n     * @generated from enum value: LANGUAGE_COFFEESCRIPT = 3;\n     */ Language[Language[\"COFFEESCRIPT\"] = 3] = \"COFFEESCRIPT\";\n    /**\n     * @generated from enum value: LANGUAGE_CPP = 4;\n     */ Language[Language[\"CPP\"] = 4] = \"CPP\";\n    /**\n     * @generated from enum value: LANGUAGE_CSHARP = 5;\n     */ Language[Language[\"CSHARP\"] = 5] = \"CSHARP\";\n    /**\n     * @generated from enum value: LANGUAGE_CSS = 6;\n     */ Language[Language[\"CSS\"] = 6] = \"CSS\";\n    /**\n     * @generated from enum value: LANGUAGE_CUDACPP = 7;\n     */ Language[Language[\"CUDACPP\"] = 7] = \"CUDACPP\";\n    /**\n     * @generated from enum value: LANGUAGE_DOCKERFILE = 8;\n     */ Language[Language[\"DOCKERFILE\"] = 8] = \"DOCKERFILE\";\n    /**\n     * @generated from enum value: LANGUAGE_GO = 9;\n     */ Language[Language[\"GO\"] = 9] = \"GO\";\n    /**\n     * @generated from enum value: LANGUAGE_GROOVY = 10;\n     */ Language[Language[\"GROOVY\"] = 10] = \"GROOVY\";\n    /**\n     * @generated from enum value: LANGUAGE_HANDLEBARS = 11;\n     */ Language[Language[\"HANDLEBARS\"] = 11] = \"HANDLEBARS\";\n    /**\n     * @generated from enum value: LANGUAGE_HASKELL = 12;\n     */ Language[Language[\"HASKELL\"] = 12] = \"HASKELL\";\n    /**\n     * @generated from enum value: LANGUAGE_HCL = 13;\n     */ Language[Language[\"HCL\"] = 13] = \"HCL\";\n    /**\n     * @generated from enum value: LANGUAGE_HTML = 14;\n     */ Language[Language[\"HTML\"] = 14] = \"HTML\";\n    /**\n     * @generated from enum value: LANGUAGE_INI = 15;\n     */ Language[Language[\"INI\"] = 15] = \"INI\";\n    /**\n     * @generated from enum value: LANGUAGE_JAVA = 16;\n     */ Language[Language[\"JAVA\"] = 16] = \"JAVA\";\n    /**\n     * @generated from enum value: LANGUAGE_JAVASCRIPT = 17;\n     */ Language[Language[\"JAVASCRIPT\"] = 17] = \"JAVASCRIPT\";\n    /**\n     * @generated from enum value: LANGUAGE_JSON = 18;\n     */ Language[Language[\"JSON\"] = 18] = \"JSON\";\n    /**\n     * @generated from enum value: LANGUAGE_JULIA = 19;\n     */ Language[Language[\"JULIA\"] = 19] = \"JULIA\";\n    /**\n     * @generated from enum value: LANGUAGE_KOTLIN = 20;\n     */ Language[Language[\"KOTLIN\"] = 20] = \"KOTLIN\";\n    /**\n     * @generated from enum value: LANGUAGE_LATEX = 21;\n     */ Language[Language[\"LATEX\"] = 21] = \"LATEX\";\n    /**\n     * @generated from enum value: LANGUAGE_LESS = 22;\n     */ Language[Language[\"LESS\"] = 22] = \"LESS\";\n    /**\n     * @generated from enum value: LANGUAGE_LUA = 23;\n     */ Language[Language[\"LUA\"] = 23] = \"LUA\";\n    /**\n     * @generated from enum value: LANGUAGE_MAKEFILE = 24;\n     */ Language[Language[\"MAKEFILE\"] = 24] = \"MAKEFILE\";\n    /**\n     * @generated from enum value: LANGUAGE_MARKDOWN = 25;\n     */ Language[Language[\"MARKDOWN\"] = 25] = \"MARKDOWN\";\n    /**\n     * @generated from enum value: LANGUAGE_OBJECTIVEC = 26;\n     */ Language[Language[\"OBJECTIVEC\"] = 26] = \"OBJECTIVEC\";\n    /**\n     * @generated from enum value: LANGUAGE_OBJECTIVECPP = 27;\n     */ Language[Language[\"OBJECTIVECPP\"] = 27] = \"OBJECTIVECPP\";\n    /**\n     * @generated from enum value: LANGUAGE_PERL = 28;\n     */ Language[Language[\"PERL\"] = 28] = \"PERL\";\n    /**\n     * @generated from enum value: LANGUAGE_PHP = 29;\n     */ Language[Language[\"PHP\"] = 29] = \"PHP\";\n    /**\n     * @generated from enum value: LANGUAGE_PLAINTEXT = 30;\n     */ Language[Language[\"PLAINTEXT\"] = 30] = \"PLAINTEXT\";\n    /**\n     * @generated from enum value: LANGUAGE_PROTOBUF = 31;\n     */ Language[Language[\"PROTOBUF\"] = 31] = \"PROTOBUF\";\n    /**\n     * @generated from enum value: LANGUAGE_PBTXT = 32;\n     */ Language[Language[\"PBTXT\"] = 32] = \"PBTXT\";\n    /**\n     * @generated from enum value: LANGUAGE_PYTHON = 33;\n     */ Language[Language[\"PYTHON\"] = 33] = \"PYTHON\";\n    /**\n     * @generated from enum value: LANGUAGE_R = 34;\n     */ Language[Language[\"R\"] = 34] = \"R\";\n    /**\n     * @generated from enum value: LANGUAGE_RUBY = 35;\n     */ Language[Language[\"RUBY\"] = 35] = \"RUBY\";\n    /**\n     * @generated from enum value: LANGUAGE_RUST = 36;\n     */ Language[Language[\"RUST\"] = 36] = \"RUST\";\n    /**\n     * @generated from enum value: LANGUAGE_SASS = 37;\n     */ Language[Language[\"SASS\"] = 37] = \"SASS\";\n    /**\n     * @generated from enum value: LANGUAGE_SCALA = 38;\n     */ Language[Language[\"SCALA\"] = 38] = \"SCALA\";\n    /**\n     * @generated from enum value: LANGUAGE_SCSS = 39;\n     */ Language[Language[\"SCSS\"] = 39] = \"SCSS\";\n    /**\n     * @generated from enum value: LANGUAGE_SHELL = 40;\n     */ Language[Language[\"SHELL\"] = 40] = \"SHELL\";\n    /**\n     * @generated from enum value: LANGUAGE_SQL = 41;\n     */ Language[Language[\"SQL\"] = 41] = \"SQL\";\n    /**\n     * @generated from enum value: LANGUAGE_STARLARK = 42;\n     */ Language[Language[\"STARLARK\"] = 42] = \"STARLARK\";\n    /**\n     * @generated from enum value: LANGUAGE_SWIFT = 43;\n     */ Language[Language[\"SWIFT\"] = 43] = \"SWIFT\";\n    /**\n     * @generated from enum value: LANGUAGE_TSX = 44;\n     */ Language[Language[\"TSX\"] = 44] = \"TSX\";\n    /**\n     * @generated from enum value: LANGUAGE_TYPESCRIPT = 45;\n     */ Language[Language[\"TYPESCRIPT\"] = 45] = \"TYPESCRIPT\";\n    /**\n     * @generated from enum value: LANGUAGE_VISUALBASIC = 46;\n     */ Language[Language[\"VISUALBASIC\"] = 46] = \"VISUALBASIC\";\n    /**\n     * @generated from enum value: LANGUAGE_VUE = 47;\n     */ Language[Language[\"VUE\"] = 47] = \"VUE\";\n    /**\n     * @generated from enum value: LANGUAGE_XML = 48;\n     */ Language[Language[\"XML\"] = 48] = \"XML\";\n    /**\n     * @generated from enum value: LANGUAGE_XSL = 49;\n     */ Language[Language[\"XSL\"] = 49] = \"XSL\";\n    /**\n     * @generated from enum value: LANGUAGE_YAML = 50;\n     */ Language[Language[\"YAML\"] = 50] = \"YAML\";\n    /**\n     * @generated from enum value: LANGUAGE_SVELTE = 51;\n     */ Language[Language[\"SVELTE\"] = 51] = \"SVELTE\";\n    /**\n     * @generated from enum value: LANGUAGE_TOML = 52;\n     */ Language[Language[\"TOML\"] = 52] = \"TOML\";\n    /**\n     * @generated from enum value: LANGUAGE_DART = 53;\n     */ Language[Language[\"DART\"] = 53] = \"DART\";\n    /**\n     * @generated from enum value: LANGUAGE_RST = 54;\n     */ Language[Language[\"RST\"] = 54] = \"RST\";\n    /**\n     * @generated from enum value: LANGUAGE_OCAML = 55;\n     */ Language[Language[\"OCAML\"] = 55] = \"OCAML\";\n    /**\n     * @generated from enum value: LANGUAGE_CMAKE = 56;\n     */ Language[Language[\"CMAKE\"] = 56] = \"CMAKE\";\n    /**\n     * @generated from enum value: LANGUAGE_PASCAL = 57;\n     */ Language[Language[\"PASCAL\"] = 57] = \"PASCAL\";\n    /**\n     * @generated from enum value: LANGUAGE_ELIXIR = 58;\n     */ Language[Language[\"ELIXIR\"] = 58] = \"ELIXIR\";\n    /**\n     * @generated from enum value: LANGUAGE_FSHARP = 59;\n     */ Language[Language[\"FSHARP\"] = 59] = \"FSHARP\";\n    /**\n     * @generated from enum value: LANGUAGE_LISP = 60;\n     */ Language[Language[\"LISP\"] = 60] = \"LISP\";\n    /**\n     * @generated from enum value: LANGUAGE_MATLAB = 61;\n     */ Language[Language[\"MATLAB\"] = 61] = \"MATLAB\";\n    /**\n     * @generated from enum value: LANGUAGE_POWERSHELL = 62;\n     */ Language[Language[\"POWERSHELL\"] = 62] = \"POWERSHELL\";\n    /**\n     * @generated from enum value: LANGUAGE_SOLIDITY = 63;\n     */ Language[Language[\"SOLIDITY\"] = 63] = \"SOLIDITY\";\n    /**\n     * @generated from enum value: LANGUAGE_ADA = 64;\n     */ Language[Language[\"ADA\"] = 64] = \"ADA\";\n    /**\n     * @generated from enum value: LANGUAGE_OCAML_INTERFACE = 65;\n     */ Language[Language[\"OCAML_INTERFACE\"] = 65] = \"OCAML_INTERFACE\";\n})(Language || (Language = {}));\n// Retrieve enum metadata with: proto3.getEnumType(Language)\nproto3.util.setEnumType(Language, \"exa.codeium_common_pb.Language\", [\n    {\n        no: 0,\n        name: \"LANGUAGE_UNSPECIFIED\"\n    },\n    {\n        no: 1,\n        name: \"LANGUAGE_C\"\n    },\n    {\n        no: 2,\n        name: \"LANGUAGE_CLOJURE\"\n    },\n    {\n        no: 3,\n        name: \"LANGUAGE_COFFEESCRIPT\"\n    },\n    {\n        no: 4,\n        name: \"LANGUAGE_CPP\"\n    },\n    {\n        no: 5,\n        name: \"LANGUAGE_CSHARP\"\n    },\n    {\n        no: 6,\n        name: \"LANGUAGE_CSS\"\n    },\n    {\n        no: 7,\n        name: \"LANGUAGE_CUDACPP\"\n    },\n    {\n        no: 8,\n        name: \"LANGUAGE_DOCKERFILE\"\n    },\n    {\n        no: 9,\n        name: \"LANGUAGE_GO\"\n    },\n    {\n        no: 10,\n        name: \"LANGUAGE_GROOVY\"\n    },\n    {\n        no: 11,\n        name: \"LANGUAGE_HANDLEBARS\"\n    },\n    {\n        no: 12,\n        name: \"LANGUAGE_HASKELL\"\n    },\n    {\n        no: 13,\n        name: \"LANGUAGE_HCL\"\n    },\n    {\n        no: 14,\n        name: \"LANGUAGE_HTML\"\n    },\n    {\n        no: 15,\n        name: \"LANGUAGE_INI\"\n    },\n    {\n        no: 16,\n        name: \"LANGUAGE_JAVA\"\n    },\n    {\n        no: 17,\n        name: \"LANGUAGE_JAVASCRIPT\"\n    },\n    {\n        no: 18,\n        name: \"LANGUAGE_JSON\"\n    },\n    {\n        no: 19,\n        name: \"LANGUAGE_JULIA\"\n    },\n    {\n        no: 20,\n        name: \"LANGUAGE_KOTLIN\"\n    },\n    {\n        no: 21,\n        name: \"LANGUAGE_LATEX\"\n    },\n    {\n        no: 22,\n        name: \"LANGUAGE_LESS\"\n    },\n    {\n        no: 23,\n        name: \"LANGUAGE_LUA\"\n    },\n    {\n        no: 24,\n        name: \"LANGUAGE_MAKEFILE\"\n    },\n    {\n        no: 25,\n        name: \"LANGUAGE_MARKDOWN\"\n    },\n    {\n        no: 26,\n        name: \"LANGUAGE_OBJECTIVEC\"\n    },\n    {\n        no: 27,\n        name: \"LANGUAGE_OBJECTIVECPP\"\n    },\n    {\n        no: 28,\n        name: \"LANGUAGE_PERL\"\n    },\n    {\n        no: 29,\n        name: \"LANGUAGE_PHP\"\n    },\n    {\n        no: 30,\n        name: \"LANGUAGE_PLAINTEXT\"\n    },\n    {\n        no: 31,\n        name: \"LANGUAGE_PROTOBUF\"\n    },\n    {\n        no: 32,\n        name: \"LANGUAGE_PBTXT\"\n    },\n    {\n        no: 33,\n        name: \"LANGUAGE_PYTHON\"\n    },\n    {\n        no: 34,\n        name: \"LANGUAGE_R\"\n    },\n    {\n        no: 35,\n        name: \"LANGUAGE_RUBY\"\n    },\n    {\n        no: 36,\n        name: \"LANGUAGE_RUST\"\n    },\n    {\n        no: 37,\n        name: \"LANGUAGE_SASS\"\n    },\n    {\n        no: 38,\n        name: \"LANGUAGE_SCALA\"\n    },\n    {\n        no: 39,\n        name: \"LANGUAGE_SCSS\"\n    },\n    {\n        no: 40,\n        name: \"LANGUAGE_SHELL\"\n    },\n    {\n        no: 41,\n        name: \"LANGUAGE_SQL\"\n    },\n    {\n        no: 42,\n        name: \"LANGUAGE_STARLARK\"\n    },\n    {\n        no: 43,\n        name: \"LANGUAGE_SWIFT\"\n    },\n    {\n        no: 44,\n        name: \"LANGUAGE_TSX\"\n    },\n    {\n        no: 45,\n        name: \"LANGUAGE_TYPESCRIPT\"\n    },\n    {\n        no: 46,\n        name: \"LANGUAGE_VISUALBASIC\"\n    },\n    {\n        no: 47,\n        name: \"LANGUAGE_VUE\"\n    },\n    {\n        no: 48,\n        name: \"LANGUAGE_XML\"\n    },\n    {\n        no: 49,\n        name: \"LANGUAGE_XSL\"\n    },\n    {\n        no: 50,\n        name: \"LANGUAGE_YAML\"\n    },\n    {\n        no: 51,\n        name: \"LANGUAGE_SVELTE\"\n    },\n    {\n        no: 52,\n        name: \"LANGUAGE_TOML\"\n    },\n    {\n        no: 53,\n        name: \"LANGUAGE_DART\"\n    },\n    {\n        no: 54,\n        name: \"LANGUAGE_RST\"\n    },\n    {\n        no: 55,\n        name: \"LANGUAGE_OCAML\"\n    },\n    {\n        no: 56,\n        name: \"LANGUAGE_CMAKE\"\n    },\n    {\n        no: 57,\n        name: \"LANGUAGE_PASCAL\"\n    },\n    {\n        no: 58,\n        name: \"LANGUAGE_ELIXIR\"\n    },\n    {\n        no: 59,\n        name: \"LANGUAGE_FSHARP\"\n    },\n    {\n        no: 60,\n        name: \"LANGUAGE_LISP\"\n    },\n    {\n        no: 61,\n        name: \"LANGUAGE_MATLAB\"\n    },\n    {\n        no: 62,\n        name: \"LANGUAGE_POWERSHELL\"\n    },\n    {\n        no: 63,\n        name: \"LANGUAGE_SOLIDITY\"\n    },\n    {\n        no: 64,\n        name: \"LANGUAGE_ADA\"\n    },\n    {\n        no: 65,\n        name: \"LANGUAGE_OCAML_INTERFACE\"\n    }\n]);\n/**\n * Next ID: 12, Previous field: entropy.\n *\n * @generated from message exa.codeium_common_pb.Completion\n */ class Completion extends Message {\n    constructor(data){\n        super();\n        /**\n         * @generated from field: string completion_id = 1;\n         */ this.completionId = \"\";\n        /**\n         * @generated from field: string text = 2;\n         */ this.text = \"\";\n        /**\n         * @generated from field: string prefix = 3;\n         */ this.prefix = \"\";\n        /**\n         * @generated from field: string stop = 4;\n         */ this.stop = \"\";\n        /**\n         * @generated from field: double score = 5;\n         */ this.score = 0;\n        /**\n         * @generated from field: repeated uint64 tokens = 6;\n         */ this.tokens = [];\n        /**\n         * @generated from field: repeated string decoded_tokens = 7;\n         */ this.decodedTokens = [];\n        /**\n         * @generated from field: repeated double probabilities = 8;\n         */ this.probabilities = [];\n        /**\n         * @generated from field: repeated double adjusted_probabilities = 9;\n         */ this.adjustedProbabilities = [];\n        /**\n         * @generated from field: uint64 generated_length = 10;\n         */ this.generatedLength = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Completion().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Completion().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Completion().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Completion, a, b);\n    }\n}\nCompletion.runtime = proto3;\nCompletion.typeName = \"exa.codeium_common_pb.Completion\";\nCompletion.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"completion_id\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"text\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"prefix\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 4,\n            name: \"stop\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"score\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 6,\n            name: \"tokens\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ ,\n            repeated: true\n        },\n        {\n            no: 7,\n            name: \"decoded_tokens\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 8,\n            name: \"probabilities\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ ,\n            repeated: true\n        },\n        {\n            no: 9,\n            name: \"adjusted_probabilities\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ ,\n            repeated: true\n        },\n        {\n            no: 10,\n            name: \"generated_length\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        }\n    ]);\n/**\n * Next ID: 15, Previous field: url.\n *\n * @generated from message exa.codeium_common_pb.Metadata\n */ class Metadata extends Message {\n    constructor(data){\n        super();\n        /**\n         * @generated from field: string ide_name = 1;\n         */ this.ideName = \"\";\n        /**\n         * @generated from field: string ide_version = 7;\n         */ this.ideVersion = \"\";\n        /**\n         * @generated from field: string extension_name = 12;\n         */ this.extensionName = \"\";\n        /**\n         * @generated from field: string extension_version = 2;\n         */ this.extensionVersion = \"\";\n        /**\n         * @generated from field: string api_key = 3;\n         */ this.apiKey = \"\";\n        /**\n         * Regex derived from https://stackoverflow.com/a/48300605.\n         * TODO(prem): Should this be mandatory?\n         *\n         * @generated from field: string locale = 4;\n         */ this.locale = \"\";\n        /**\n         * UID identifying a single session for the given user.\n         *\n         * @generated from field: string session_id = 10;\n         */ this.sessionId = \"\";\n        /**\n         * Used purely in language server to cancel in flight requests.\n         * If request_id is 0, then the request is not cancelable.\n         * This should be a strictly monotonically increasing number\n         * for the duration of a session.\n         *\n         * @generated from field: uint64 request_id = 9;\n         */ this.requestId = protoInt64.zero;\n        /**\n         * Browser-specific information.\n         *\n         * @generated from field: string user_agent = 13;\n         */ this.userAgent = \"\";\n        /**\n         * @generated from field: string url = 14;\n         */ this.url = \"\";\n        /**\n         * Authentication source information.\n         *\n         * @generated from field: exa.codeium_common_pb.AuthSource auth_source = 15;\n         */ this.authSource = AuthSource.CODEIUM;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Metadata().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Metadata().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Metadata().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Metadata, a, b);\n    }\n}\nMetadata.runtime = proto3;\nMetadata.typeName = \"exa.codeium_common_pb.Metadata\";\nMetadata.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"ide_name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 7,\n            name: \"ide_version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 12,\n            name: \"extension_name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"extension_version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"api_key\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 4,\n            name: \"locale\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: \"session_id\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 9,\n            name: \"request_id\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 13,\n            name: \"user_agent\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 14,\n            name: \"url\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 15,\n            name: \"auth_source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(AuthSource)\n        }\n    ]);\n/**\n * Next ID: 3, Previous field: insert_spaces.\n *\n * @generated from message exa.codeium_common_pb.EditorOptions\n */ class EditorOptions extends Message {\n    constructor(data){\n        super();\n        /**\n         * @generated from field: uint64 tab_size = 1;\n         */ this.tabSize = protoInt64.zero;\n        /**\n         * @generated from field: bool insert_spaces = 2;\n         */ this.insertSpaces = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new EditorOptions().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new EditorOptions().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new EditorOptions().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(EditorOptions, a, b);\n    }\n}\nEditorOptions.runtime = proto3;\nEditorOptions.typeName = \"exa.codeium_common_pb.EditorOptions\";\nEditorOptions.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"tab_size\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 2,\n            name: \"insert_spaces\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message exa.codeium_common_pb.Event\n */ class Event extends Message {\n    constructor(data){\n        super();\n        /**\n         * @generated from field: exa.codeium_common_pb.EventType event_type = 1;\n         */ this.eventType = EventType.UNSPECIFIED;\n        /**\n         * @generated from field: string event_json = 2;\n         */ this.eventJson = \"\";\n        /**\n         * @generated from field: int64 timestamp_unix_ms = 3;\n         */ this.timestampUnixMs = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Event().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Event().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Event().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Event, a, b);\n    }\n}\nEvent.runtime = proto3;\nEvent.typeName = \"exa.codeium_common_pb.Event\";\nEvent.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"event_type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(EventType)\n        },\n        {\n            no: 2,\n            name: \"event_json\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"timestamp_unix_ms\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n// Copyright Exafunction, Inc.\n/**\n * @generated from enum exa.language_server_pb.CodeiumState\n */ var CodeiumState;\n(function(CodeiumState) {\n    /**\n     * @generated from enum value: CODEIUM_STATE_UNSPECIFIED = 0;\n     */ CodeiumState[CodeiumState[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from enum value: CODEIUM_STATE_INACTIVE = 1;\n     */ CodeiumState[CodeiumState[\"INACTIVE\"] = 1] = \"INACTIVE\";\n    /**\n     * @generated from enum value: CODEIUM_STATE_PROCESSING = 2;\n     */ CodeiumState[CodeiumState[\"PROCESSING\"] = 2] = \"PROCESSING\";\n    /**\n     * @generated from enum value: CODEIUM_STATE_SUCCESS = 3;\n     */ CodeiumState[CodeiumState[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    /**\n     * @generated from enum value: CODEIUM_STATE_WARNING = 4;\n     */ CodeiumState[CodeiumState[\"WARNING\"] = 4] = \"WARNING\";\n    /**\n     * @generated from enum value: CODEIUM_STATE_ERROR = 5;\n     */ CodeiumState[CodeiumState[\"ERROR\"] = 5] = \"ERROR\";\n})(CodeiumState || (CodeiumState = {}));\n// Retrieve enum metadata with: proto3.getEnumType(CodeiumState)\nproto3.util.setEnumType(CodeiumState, \"exa.language_server_pb.CodeiumState\", [\n    {\n        no: 0,\n        name: \"CODEIUM_STATE_UNSPECIFIED\"\n    },\n    {\n        no: 1,\n        name: \"CODEIUM_STATE_INACTIVE\"\n    },\n    {\n        no: 2,\n        name: \"CODEIUM_STATE_PROCESSING\"\n    },\n    {\n        no: 3,\n        name: \"CODEIUM_STATE_SUCCESS\"\n    },\n    {\n        no: 4,\n        name: \"CODEIUM_STATE_WARNING\"\n    },\n    {\n        no: 5,\n        name: \"CODEIUM_STATE_ERROR\"\n    }\n]);\n/**\n * @generated from enum exa.language_server_pb.LineType\n */ var LineType;\n(function(LineType) {\n    /**\n     * @generated from enum value: LINE_TYPE_UNSPECIFIED = 0;\n     */ LineType[LineType[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from enum value: LINE_TYPE_SINGLE = 1;\n     */ LineType[LineType[\"SINGLE\"] = 1] = \"SINGLE\";\n    /**\n     * @generated from enum value: LINE_TYPE_MULTI = 2;\n     */ LineType[LineType[\"MULTI\"] = 2] = \"MULTI\";\n})(LineType || (LineType = {}));\n// Retrieve enum metadata with: proto3.getEnumType(LineType)\nproto3.util.setEnumType(LineType, \"exa.language_server_pb.LineType\", [\n    {\n        no: 0,\n        name: \"LINE_TYPE_UNSPECIFIED\"\n    },\n    {\n        no: 1,\n        name: \"LINE_TYPE_SINGLE\"\n    },\n    {\n        no: 2,\n        name: \"LINE_TYPE_MULTI\"\n    }\n]);\n/**\n * @generated from enum exa.language_server_pb.CompletionPartType\n */ var CompletionPartType;\n(function(CompletionPartType) {\n    /**\n     * @generated from enum value: COMPLETION_PART_TYPE_UNSPECIFIED = 0;\n     */ CompletionPartType[CompletionPartType[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * Single-line completion parts that appear within an existing line of text.\n     *\n     * @generated from enum value: COMPLETION_PART_TYPE_INLINE = 1;\n     */ CompletionPartType[CompletionPartType[\"INLINE\"] = 1] = \"INLINE\";\n    /**\n     * Possibly multi-line completion parts that appear below an existing line of text.\n     *\n     * @generated from enum value: COMPLETION_PART_TYPE_BLOCK = 2;\n     */ CompletionPartType[CompletionPartType[\"BLOCK\"] = 2] = \"BLOCK\";\n    /**\n     * Like COMPLETION_PART_TYPE_INLINE, but overwrites the existing text.\n     *\n     * @generated from enum value: COMPLETION_PART_TYPE_INLINE_MASK = 3;\n     */ CompletionPartType[CompletionPartType[\"INLINE_MASK\"] = 3] = \"INLINE_MASK\";\n})(CompletionPartType || (CompletionPartType = {}));\n// Retrieve enum metadata with: proto3.getEnumType(CompletionPartType)\nproto3.util.setEnumType(CompletionPartType, \"exa.language_server_pb.CompletionPartType\", [\n    {\n        no: 0,\n        name: \"COMPLETION_PART_TYPE_UNSPECIFIED\"\n    },\n    {\n        no: 1,\n        name: \"COMPLETION_PART_TYPE_INLINE\"\n    },\n    {\n        no: 2,\n        name: \"COMPLETION_PART_TYPE_BLOCK\"\n    },\n    {\n        no: 3,\n        name: \"COMPLETION_PART_TYPE_INLINE_MASK\"\n    }\n]);\n/**\n * @generated from message exa.language_server_pb.MultilineConfig\n */ class MultilineConfig extends Message {\n    constructor(data){\n        super();\n        /**\n         * Multiline model threshold. 0-1, higher = more single line, lower = more multiline,\n         * 0.0 = only_multiline, default is 0.5\n         *\n         * @generated from field: float threshold = 1;\n         */ this.threshold = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new MultilineConfig().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new MultilineConfig().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new MultilineConfig().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(MultilineConfig, a, b);\n    }\n}\nMultilineConfig.runtime = proto3;\nMultilineConfig.typeName = \"exa.language_server_pb.MultilineConfig\";\nMultilineConfig.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"threshold\",\n            kind: \"scalar\",\n            T: 2 /* ScalarType.FLOAT */ \n        }\n    ]);\n/**\n * Next ID: 9, Previous field: disable_cache.\n *\n * @generated from message exa.language_server_pb.GetCompletionsRequest\n */ class GetCompletionsRequest extends Message {\n    constructor(data){\n        super();\n        /**\n         * @generated from field: repeated exa.language_server_pb.Document other_documents = 5;\n         */ this.otherDocuments = [];\n        /**\n         * @generated from field: string model_name = 10;\n         */ this.modelName = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new GetCompletionsRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new GetCompletionsRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new GetCompletionsRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(GetCompletionsRequest, a, b);\n    }\n}\nGetCompletionsRequest.runtime = proto3;\nGetCompletionsRequest.typeName = \"exa.language_server_pb.GetCompletionsRequest\";\nGetCompletionsRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"metadata\",\n            kind: \"message\",\n            T: Metadata\n        },\n        {\n            no: 2,\n            name: \"document\",\n            kind: \"message\",\n            T: Document$1\n        },\n        {\n            no: 3,\n            name: \"editor_options\",\n            kind: \"message\",\n            T: EditorOptions\n        },\n        {\n            no: 5,\n            name: \"other_documents\",\n            kind: \"message\",\n            T: Document$1,\n            repeated: true\n        },\n        {\n            no: 7,\n            name: \"experiment_config\",\n            kind: \"message\",\n            T: ExperimentConfig\n        },\n        {\n            no: 10,\n            name: \"model_name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 13,\n            name: \"multiline_config\",\n            kind: \"message\",\n            T: MultilineConfig\n        }\n    ]);\n/**\n * Next ID: 5, Previous field: latency_info.\n *\n * @generated from message exa.language_server_pb.GetCompletionsResponse\n */ class GetCompletionsResponse extends Message {\n    constructor(data){\n        super();\n        /**\n         * @generated from field: repeated exa.language_server_pb.CompletionItem completion_items = 2;\n         */ this.completionItems = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new GetCompletionsResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new GetCompletionsResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new GetCompletionsResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(GetCompletionsResponse, a, b);\n    }\n}\nGetCompletionsResponse.runtime = proto3;\nGetCompletionsResponse.typeName = \"exa.language_server_pb.GetCompletionsResponse\";\nGetCompletionsResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"state\",\n            kind: \"message\",\n            T: State\n        },\n        {\n            no: 2,\n            name: \"completion_items\",\n            kind: \"message\",\n            T: CompletionItem,\n            repeated: true\n        }\n    ]);\n/**\n * Next ID: 3, Previous field: completion_id.\n *\n * @generated from message exa.language_server_pb.AcceptCompletionRequest\n */ class AcceptCompletionRequest extends Message {\n    constructor(data){\n        super();\n        /**\n         * @generated from field: string completion_id = 2;\n         */ this.completionId = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new AcceptCompletionRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new AcceptCompletionRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new AcceptCompletionRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(AcceptCompletionRequest, a, b);\n    }\n}\nAcceptCompletionRequest.runtime = proto3;\nAcceptCompletionRequest.typeName = \"exa.language_server_pb.AcceptCompletionRequest\";\nAcceptCompletionRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"metadata\",\n            kind: \"message\",\n            T: Metadata\n        },\n        {\n            no: 2,\n            name: \"completion_id\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * Next ID: 1, Previous field: N/A.\n *\n * @generated from message exa.language_server_pb.AcceptCompletionResponse\n */ class AcceptCompletionResponse extends Message {\n    constructor(data){\n        super();\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new AcceptCompletionResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new AcceptCompletionResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new AcceptCompletionResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(AcceptCompletionResponse, a, b);\n    }\n}\nAcceptCompletionResponse.runtime = proto3;\nAcceptCompletionResponse.typeName = \"exa.language_server_pb.AcceptCompletionResponse\";\nAcceptCompletionResponse.fields = proto3.util.newFieldList(()=>[]);\n/**\n * Next ID: 1, Previous field: N/A.\n *\n * @generated from message exa.language_server_pb.GetAuthTokenRequest\n */ class GetAuthTokenRequest extends Message {\n    constructor(data){\n        super();\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new GetAuthTokenRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new GetAuthTokenRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new GetAuthTokenRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(GetAuthTokenRequest, a, b);\n    }\n}\nGetAuthTokenRequest.runtime = proto3;\nGetAuthTokenRequest.typeName = \"exa.language_server_pb.GetAuthTokenRequest\";\nGetAuthTokenRequest.fields = proto3.util.newFieldList(()=>[]);\n/**\n * Next ID: 3, Previous field: uuid.\n *\n * @generated from message exa.language_server_pb.GetAuthTokenResponse\n */ class GetAuthTokenResponse extends Message {\n    constructor(data){\n        super();\n        /**\n         * @generated from field: string auth_token = 1;\n         */ this.authToken = \"\";\n        /**\n         * @generated from field: string uuid = 2;\n         */ this.uuid = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new GetAuthTokenResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new GetAuthTokenResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new GetAuthTokenResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(GetAuthTokenResponse, a, b);\n    }\n}\nGetAuthTokenResponse.runtime = proto3;\nGetAuthTokenResponse.typeName = \"exa.language_server_pb.GetAuthTokenResponse\";\nGetAuthTokenResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"auth_token\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"uuid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message exa.language_server_pb.DocumentPosition\n */ class DocumentPosition extends Message {\n    constructor(data){\n        super();\n        /**\n         * 0-indexed. Measured in UTF-8 bytes.\n         *\n         * @generated from field: uint64 row = 1;\n         */ this.row = protoInt64.zero;\n        /**\n         * 0-indexed. Measured in UTF-8 bytes.\n         *\n         * @generated from field: uint64 col = 2;\n         */ this.col = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DocumentPosition().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DocumentPosition().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DocumentPosition().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DocumentPosition, a, b);\n    }\n}\nDocumentPosition.runtime = proto3;\nDocumentPosition.typeName = \"exa.language_server_pb.DocumentPosition\";\nDocumentPosition.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"row\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 2,\n            name: \"col\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        }\n    ]);\n/**\n * Next ID: 9, Previous field: cursor_position.\n *\n * @generated from message exa.language_server_pb.Document\n */ let Document$1 = class Document extends Message {\n    constructor(data){\n        super();\n        /**\n         * @generated from field: string absolute_path = 1;\n         */ this.absolutePath = \"\";\n        /**\n         * Path relative to the root of the workspace.\n         *\n         * @generated from field: string relative_path = 2;\n         */ this.relativePath = \"\";\n        /**\n         * @generated from field: string text = 3;\n         */ this.text = \"\";\n        /**\n         * Language ID provided by the editor.\n         *\n         * @generated from field: string editor_language = 4;\n         */ this.editorLanguage = \"\";\n        /**\n         * Language enum standardized across editors.\n         *\n         * @generated from field: exa.codeium_common_pb.Language language = 5;\n         */ this.language = Language.UNSPECIFIED;\n        /**\n         * Measured in number of UTF-8 bytes.\n         *\n         * @generated from field: uint64 cursor_offset = 6;\n         */ this.cursorOffset = protoInt64.zero;\n        /**\n         * \\n or \\r\\n, if known.\n         *\n         * @generated from field: string line_ending = 7;\n         */ this.lineEnding = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Document().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Document().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Document().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Document, a, b);\n    }\n};\nDocument$1.runtime = proto3;\nDocument$1.typeName = \"exa.language_server_pb.Document\";\nDocument$1.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"absolute_path\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"relative_path\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"text\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 4,\n            name: \"editor_language\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"language\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Language)\n        },\n        {\n            no: 6,\n            name: \"cursor_offset\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 8,\n            name: \"cursor_position\",\n            kind: \"message\",\n            T: DocumentPosition\n        },\n        {\n            no: 7,\n            name: \"line_ending\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message exa.language_server_pb.ExperimentConfig\n */ class ExperimentConfig extends Message {\n    constructor(data){\n        super();\n        /**\n         * @generated from field: repeated exa.codeium_common_pb.ExperimentKey force_enable_experiments = 1;\n         */ this.forceEnableExperiments = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ExperimentConfig().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ExperimentConfig().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ExperimentConfig().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ExperimentConfig, a, b);\n    }\n}\nExperimentConfig.runtime = proto3;\nExperimentConfig.typeName = \"exa.language_server_pb.ExperimentConfig\";\nExperimentConfig.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"force_enable_experiments\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ExperimentKey),\n            repeated: true\n        }\n    ]);\n/**\n * Next ID: 3, Previous field: message.\n *\n * @generated from message exa.language_server_pb.State\n */ class State extends Message {\n    constructor(data){\n        super();\n        /**\n         * @generated from field: exa.language_server_pb.CodeiumState state = 1;\n         */ this.state = CodeiumState.UNSPECIFIED;\n        /**\n         * @generated from field: string message = 2;\n         */ this.message = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new State().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new State().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new State().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(State, a, b);\n    }\n}\nState.runtime = proto3;\nState.typeName = \"exa.language_server_pb.State\";\nState.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"state\",\n            kind: \"enum\",\n            T: proto3.getEnumType(CodeiumState)\n        },\n        {\n            no: 2,\n            name: \"message\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * Next ID: 5, Previous field: end_position.\n *\n * @generated from message exa.language_server_pb.Range\n */ let Range$1 = class Range extends Message {\n    constructor(data){\n        super();\n        /**\n         * @generated from field: uint64 start_offset = 1;\n         */ this.startOffset = protoInt64.zero;\n        /**\n         * @generated from field: uint64 end_offset = 2;\n         */ this.endOffset = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Range().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Range().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Range().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Range, a, b);\n    }\n};\nRange$1.runtime = proto3;\nRange$1.typeName = \"exa.language_server_pb.Range\";\nRange$1.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"start_offset\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 2,\n            name: \"end_offset\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 3,\n            name: \"start_position\",\n            kind: \"message\",\n            T: DocumentPosition\n        },\n        {\n            no: 4,\n            name: \"end_position\",\n            kind: \"message\",\n            T: DocumentPosition\n        }\n    ]);\n/**\n * @generated from message exa.language_server_pb.Suffix\n */ class Suffix extends Message {\n    constructor(data){\n        super();\n        /**\n         * Text to insert after the cursor when accepting the completion.\n         *\n         * @generated from field: string text = 1;\n         */ this.text = \"\";\n        /**\n         * Cursor position delta (as signed offset) from the end of the inserted\n         * completion (including the suffix).\n         *\n         * @generated from field: int64 delta_cursor_offset = 2;\n         */ this.deltaCursorOffset = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Suffix().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Suffix().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Suffix().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Suffix, a, b);\n    }\n}\nSuffix.runtime = proto3;\nSuffix.typeName = \"exa.language_server_pb.Suffix\";\nSuffix.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"text\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"delta_cursor_offset\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * Represents a contiguous part of the completion text that is not\n * already in the document.\n * Next ID: 4, Previous field: prefix.\n *\n * @generated from message exa.language_server_pb.CompletionPart\n */ class CompletionPart extends Message {\n    constructor(data){\n        super();\n        /**\n         * @generated from field: string text = 1;\n         */ this.text = \"\";\n        /**\n         * Offset in the original document where the part starts. For block\n         * parts, this is always the end of the line before the block.\n         *\n         * @generated from field: uint64 offset = 2;\n         */ this.offset = protoInt64.zero;\n        /**\n         * @generated from field: exa.language_server_pb.CompletionPartType type = 3;\n         */ this.type = CompletionPartType.UNSPECIFIED;\n        /**\n         * The section of the original line that came before this part. Only valid for\n         * COMPLETION_PART_TYPE_INLINE.\n         *\n         * @generated from field: string prefix = 4;\n         */ this.prefix = \"\";\n        /**\n         * In the case of COMPLETION_PART_TYPE_BLOCK, represents the line it is below.\n         *\n         * @generated from field: uint64 line = 5;\n         */ this.line = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new CompletionPart().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new CompletionPart().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new CompletionPart().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(CompletionPart, a, b);\n    }\n}\nCompletionPart.runtime = proto3;\nCompletionPart.typeName = \"exa.language_server_pb.CompletionPart\";\nCompletionPart.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"text\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"offset\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 3,\n            name: \"type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(CompletionPartType)\n        },\n        {\n            no: 4,\n            name: \"prefix\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"line\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        }\n    ]);\n/**\n * Next ID: 9, Previous field: completion_parts.\n *\n * @generated from message exa.language_server_pb.CompletionItem\n */ class CompletionItem extends Message {\n    constructor(data){\n        super();\n        /**\n         * @generated from field: exa.codeium_common_pb.CompletionSource source = 3;\n         */ this.source = CompletionSource.UNSPECIFIED;\n        /**\n         * @generated from field: repeated exa.language_server_pb.CompletionPart completion_parts = 8;\n         */ this.completionParts = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new CompletionItem().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new CompletionItem().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new CompletionItem().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(CompletionItem, a, b);\n    }\n}\nCompletionItem.runtime = proto3;\nCompletionItem.typeName = \"exa.language_server_pb.CompletionItem\";\nCompletionItem.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"completion\",\n            kind: \"message\",\n            T: Completion\n        },\n        {\n            no: 5,\n            name: \"suffix\",\n            kind: \"message\",\n            T: Suffix\n        },\n        {\n            no: 2,\n            name: \"range\",\n            kind: \"message\",\n            T: Range$1\n        },\n        {\n            no: 3,\n            name: \"source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(CompletionSource)\n        },\n        {\n            no: 8,\n            name: \"completion_parts\",\n            kind: \"message\",\n            T: CompletionPart,\n            repeated: true\n        }\n    ]);\n// Copyright Exafunction, Inc.\n// @generated by protoc-gen-connect-es v1.1.3 with parameter \"target=ts,import_extension=none\"\n// @generated from file exa/language_server_pb/language_server.proto (package exa.language_server_pb, syntax proto3)\n/* eslint-disable */ // @ts-nocheck\n/**\n * @generated from service exa.language_server_pb.LanguageServerService\n */ const LanguageServerService = {\n    typeName: \"exa.language_server_pb.LanguageServerService\",\n    methods: {\n        /**\n         * @generated from rpc exa.language_server_pb.LanguageServerService.GetCompletions\n         */ getCompletions: {\n            name: \"GetCompletions\",\n            I: GetCompletionsRequest,\n            O: GetCompletionsResponse,\n            kind: MethodKind.Unary\n        },\n        /**\n         * @generated from rpc exa.language_server_pb.LanguageServerService.AcceptCompletion\n         */ acceptCompletion: {\n            name: \"AcceptCompletion\",\n            I: AcceptCompletionRequest,\n            O: AcceptCompletionResponse,\n            kind: MethodKind.Unary\n        },\n        /**\n         * @generated from rpc exa.language_server_pb.LanguageServerService.GetAuthToken\n         */ getAuthToken: {\n            name: \"GetAuthToken\",\n            I: GetAuthTokenRequest,\n            O: GetAuthTokenResponse,\n            kind: MethodKind.Unary\n        }\n    }\n};\nclass Position {\n    constructor(line, character){\n        this.line = line;\n        this.character = character;\n        this.lineNumber = line + 1;\n        this.column = character + 1;\n    }\n    static fromMonaco(position) {\n        return new Position(position.lineNumber - 1, position.column - 1);\n    }\n    static fromPosition(position) {\n        return new Position(position.line, position.character);\n    }\n}\nclass Range {\n    constructor(start, end){\n        this.start = start;\n        this.end = end;\n        this.startLineNumber = start.line + 1;\n        this.startColumn = start.character + 1;\n        this.endLineNumber = end.line + 1;\n        this.endColumn = end.character + 1;\n    }\n    static fromMonaco(range) {\n        return new Range(new Position(range.startLineNumber - 1, range.startColumn - 1), new Position(range.endLineNumber - 1, range.endColumn - 1));\n    }\n    static fromRange(range) {\n        return new Range(range.start, range.end);\n    }\n}\nclass Line {\n    constructor(text, range){\n        this.text = text;\n        this.range = range;\n    }\n}\nclass Document {\n    constructor(model){\n        this.model = model;\n        this.uri = model.uri;\n        this.languageId = model.getLanguageId();\n    }\n    get lineCount() {\n        return this.model.getLineCount();\n    }\n    lineAt(positionOrLine) {\n        if (typeof positionOrLine !== \"number\") {\n            positionOrLine = positionOrLine.line;\n        }\n        return new Line(this.model.getLineContent(positionOrLine + 1), new Range(new Position(positionOrLine, 0), new Position(positionOrLine, this.model.getLineLength(positionOrLine + 1))));\n    }\n    offsetAt(position) {\n        return this.model.getOffsetAt(Position.fromPosition(position));\n    }\n    positionAt(offset) {\n        return Position.fromMonaco(this.model.getPositionAt(offset));\n    }\n    getText(range) {\n        if (!range) {\n            return this.model.getValue();\n        }\n        return this.model.getValueInRange(Range.fromRange(range));\n    }\n}\n/**\n * Returns the number of UTF-8 bytes required to represent the given Unicode code point.\n *\n * @param {number} codePointValue - The Unicode code point value.\n * @return {number} The number of UTF-8 bytes needed to represent the code point.\n */ function numUtf8BytesForCodePoint(codePointValue) {\n    if (codePointValue < 0x80) {\n        return 1;\n    }\n    if (codePointValue < 0x800) {\n        return 2;\n    }\n    if (codePointValue < 0x10000) {\n        return 3;\n    }\n    return 4;\n}\n/**\n * Calculates for some prefix of the given text, how many bytes the UTF-8\n * representation would be. Undefined behavior if the number of code units\n * doesn't correspond to a valid UTF-8 sequence.\n * @param text - Text to examine.\n * @param numCodeUnits The number of code units to look at.\n * @returns The number of bytes.\n */ function numCodeUnitsToNumUtf8Bytes(text, numCodeUnits) {\n    if (numCodeUnits === 0) {\n        return 0;\n    }\n    let curNumUtf8Bytes = 0;\n    let curNumCodeUnits = 0;\n    for (const codePoint of text){\n        curNumCodeUnits += codePoint.length;\n        curNumUtf8Bytes += numUtf8BytesForCodePoint(codePoint.codePointAt(0));\n        if (numCodeUnits !== undefined && curNumCodeUnits >= numCodeUnits) {\n            break;\n        }\n    }\n    return curNumUtf8Bytes;\n}\nfunction numUtf8BytesToNumCodeUnits(text, numUtf8Bytes) {\n    if (numUtf8Bytes === 0) {\n        return 0;\n    }\n    let curNumCodeUnits = 0;\n    let curNumUtf8Bytes = 0;\n    for (const codePoint of text){\n        curNumUtf8Bytes += numUtf8BytesForCodePoint(codePoint.codePointAt(0));\n        curNumCodeUnits += codePoint.length;\n        if (numUtf8Bytes !== undefined && curNumUtf8Bytes >= numUtf8Bytes) {\n            break;\n        }\n    }\n    return curNumCodeUnits;\n}\n/**\n * Generates a random UUID.\n */ const uuid = ()=>{\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = Math.random() * 16 | 0;\n        const v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n};\n/**\n * Get the current URL of the window. If this fails, a null string is returned.\n * @returns The current URL\n */ const getCurrentURL = ()=>{\n    try {\n        return window.location.href;\n    } catch (e) {\n        return null;\n    }\n};\n/**\n * Get the current package version. If this fails, a null string is returned.\n */ const getPackageVersion = ()=>{\n    try {\n        // @ts-ignore\n        return window.CODEIUM_REACT_CODE_VERSION ? window.CODEIUM_REACT_CODE_VERSION : null;\n    } catch (e) {\n        return null;\n    }\n};\n/**\n * Converts a language ID to a strongly-typed enum value.\n */ const languageIdToEnum = (languageId)=>{\n    switch(languageId.toLowerCase()){\n        case \"c\":\n            return Language.C;\n        case \"clojure\":\n            return Language.CLOJURE;\n        case \"coffeescript\":\n            return Language.COFFEESCRIPT;\n        case \"cpp\":\n            return Language.CPP;\n        case \"csharp\":\n            return Language.CSHARP;\n        case \"css\":\n            return Language.CSS;\n        case \"cudacpp\":\n            return Language.CUDACPP;\n        case \"dockerfile\":\n            return Language.DOCKERFILE;\n        case \"go\":\n            return Language.GO;\n        case \"groovy\":\n            return Language.GROOVY;\n        case \"handlebars\":\n            return Language.HANDLEBARS;\n        case \"haskell\":\n            return Language.HASKELL;\n        case \"hcl\":\n            return Language.HCL;\n        case \"html\":\n            return Language.HTML;\n        case \"ini\":\n            return Language.INI;\n        case \"java\":\n            return Language.JAVA;\n        case \"javascript\":\n            return Language.JAVASCRIPT;\n        case \"json\":\n            return Language.JSON;\n        case \"julia\":\n            return Language.JULIA;\n        case \"kotlin\":\n            return Language.KOTLIN;\n        case \"latex\":\n            return Language.LATEX;\n        case \"less\":\n            return Language.LESS;\n        case \"lua\":\n            return Language.LUA;\n        case \"makefile\":\n            return Language.MAKEFILE;\n        case \"markdown\":\n            return Language.MARKDOWN;\n        case \"objectivec\":\n            return Language.OBJECTIVEC;\n        case \"objectivecpp\":\n            return Language.OBJECTIVECPP;\n        case \"perl\":\n            return Language.PERL;\n        case \"php\":\n            return Language.PHP;\n        case \"plaintext\":\n            return Language.PLAINTEXT;\n        case \"protobuf\":\n            return Language.PROTOBUF;\n        case \"pbtxt\":\n            return Language.PBTXT;\n        case \"python\":\n            return Language.PYTHON;\n        case \"r\":\n            return Language.R;\n        case \"ruby\":\n            return Language.RUBY;\n        case \"rust\":\n            return Language.RUST;\n        case \"sass\":\n            return Language.SASS;\n        case \"scala\":\n            return Language.SCALA;\n        case \"scss\":\n            return Language.SCSS;\n        case \"shell\":\n            return Language.SHELL;\n        case \"sql\":\n            return Language.SQL;\n        case \"starlark\":\n            return Language.STARLARK;\n        case \"swift\":\n            return Language.SWIFT;\n        case \"tsx\":\n            return Language.TSX;\n        case \"typescript\":\n            return Language.TYPESCRIPT;\n        case \"visualbasic\":\n            return Language.VISUALBASIC;\n        case \"vue\":\n            return Language.VUE;\n        case \"xml\":\n            return Language.XML;\n        case \"xsl\":\n            return Language.XSL;\n        case \"yaml\":\n            return Language.YAML;\n        case \"svelte\":\n            return Language.SVELTE;\n        case \"toml\":\n            return Language.TOML;\n        case \"dart\":\n            return Language.DART;\n        case \"rst\":\n            return Language.RST;\n        case \"ocaml\":\n            return Language.OCAML;\n        case \"cmake\":\n            return Language.CMAKE;\n        case \"pascal\":\n            return Language.PASCAL;\n        case \"elixir\":\n            return Language.ELIXIR;\n        case \"fsharp\":\n            return Language.FSHARP;\n        case \"lisp\":\n            return Language.LISP;\n        case \"matlab\":\n            return Language.MATLAB;\n        case \"powershell\":\n            return Language.POWERSHELL;\n        case \"solidity\":\n            return Language.SOLIDITY;\n        case \"ada\":\n            return Language.ADA;\n        case \"ocaml_interface\":\n            return Language.OCAML_INTERFACE;\n        default:\n            return Language.UNSPECIFIED;\n    }\n};\nclass MonacoInlineCompletion {\n    constructor(insertText, range, completionId){\n        this.insertText = insertText;\n        this.text = insertText;\n        this.range = range;\n        this.command = {\n            id: \"codeium.acceptCompletion\",\n            title: \"Accept Completion\",\n            arguments: [\n                completionId,\n                insertText\n            ]\n        };\n    }\n}\nconst EDITOR_API_KEY = \"d49954eb-cfba-4992-980f-d8fb37f0e942\";\n/**\n * CompletionProvider class for Codeium.\n */ class MonacoCompletionProvider {\n    constructor(grpcClient, setStatus, setMessage, apiKey, multilineModelThreshold){\n        this.setStatus = setStatus;\n        this.setMessage = setMessage;\n        this.apiKey = apiKey;\n        this.multilineModelThreshold = multilineModelThreshold;\n        /**\n         * A list of other documents to include as context in the prompt.\n         */ this.otherDocuments = [];\n        this.sessionId = `react-editor-${uuid()}`;\n        this.client = grpcClient;\n    }\n    getAuthHeader() {\n        const metadata = this.getMetadata();\n        const headers = {\n            Authorization: `Basic ${metadata.apiKey}-${metadata.sessionId}`\n        };\n        return headers;\n    }\n    getMetadata() {\n        var _a, _b, _c;\n        const metadata = new Metadata({\n            ideName: \"web\",\n            ideVersion: (_a = getCurrentURL()) !== null && _a !== void 0 ? _a : \"unknown\",\n            extensionName: \"@codeium/react-code-editor\",\n            extensionVersion: (_b = getPackageVersion()) !== null && _b !== void 0 ? _b : \"unknown\",\n            apiKey: (_c = this.apiKey) !== null && _c !== void 0 ? _c : EDITOR_API_KEY,\n            sessionId: this.sessionId\n        });\n        return metadata;\n    }\n    /**\n     * Generate CompletionAndRanges.\n     *\n     * @param model - Monaco model.\n     * @param token - Cancellation token.\n     * @returns InlineCompletions or undefined\n     */ provideInlineCompletions(model, monacoPosition, token) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const document1 = new Document(model);\n            const position = Position.fromMonaco(monacoPosition);\n            // Pre-register cancellation callback to get around bug in Monaco cancellation tokens breaking\n            // after await.\n            token.onCancellationRequested(()=>{\n                var _a;\n                return (_a = token.cancellationCallback) === null || _a === void 0 ? void 0 : _a.call(token);\n            });\n            const abortController = new AbortController();\n            token.onCancellationRequested(()=>{\n                abortController.abort();\n            });\n            const signal = abortController.signal;\n            this.setStatus(Status.PROCESSING);\n            this.setMessage(\"Generating completions...\");\n            const documentInfo = this.getDocumentInfo(document1, position);\n            const editorOptions = {\n                tabSize: BigInt(model.getOptions().tabSize),\n                insertSpaces: model.getOptions().insertSpaces\n            };\n            let includedOtherDocs = this.otherDocuments;\n            if (includedOtherDocs.length > 10) {\n                console.warn(`Too many other documents: ${includedOtherDocs.length} (max 10)`);\n                includedOtherDocs = includedOtherDocs.slice(0, 10);\n            }\n            let multilineConfig = undefined;\n            if (this.multilineModelThreshold !== undefined) {\n                multilineConfig = new MultilineConfig({\n                    threshold: this.multilineModelThreshold\n                });\n            }\n            // Get completions.\n            let getCompletionsResponse;\n            try {\n                getCompletionsResponse = yield this.client.getCompletions({\n                    metadata: this.getMetadata(),\n                    document: documentInfo,\n                    editorOptions: editorOptions,\n                    otherDocuments: includedOtherDocs,\n                    multilineConfig\n                }, {\n                    signal,\n                    headers: this.getAuthHeader()\n                });\n            } catch (err) {\n                // Handle cancellation.\n                if (err instanceof ConnectError && err.code === Code.Canceled) ;\n                else {\n                    this.setStatus(Status.ERROR);\n                    this.setMessage(\"Something went wrong; please try again.\");\n                }\n                return undefined;\n            }\n            if (!getCompletionsResponse.completionItems) {\n                // TODO(nick): Distinguish warning / error states here.\n                const message = \" No completions were generated\";\n                this.setStatus(Status.SUCCESS);\n                this.setMessage(message);\n                return undefined;\n            }\n            const completionItems = getCompletionsResponse.completionItems;\n            // Create inline completion items from completions.\n            const inlineCompletionItems = completionItems.map((completionItem)=>this.createInlineCompletionItem(completionItem, document1)).filter((item)=>!!item);\n            this.setStatus(Status.SUCCESS);\n            let message = `Generated ${inlineCompletionItems.length} completions`;\n            if (inlineCompletionItems.length === 1) {\n                message = `Generated 1 completion`;\n            }\n            this.setMessage(message);\n            return {\n                items: inlineCompletionItems\n            };\n        });\n    }\n    /**\n     * Record that the last completion shown was accepted by the user.\n     * @param ctx - Codeium context\n     * @param completionId - unique ID of the last completion.\n     */ acceptedLastCompletion(completionId) {\n        new Promise((resolve, reject)=>{\n            this.client.acceptCompletion({\n                metadata: this.getMetadata(),\n                completionId: completionId\n            }, {\n                headers: this.getAuthHeader()\n            }).then(resolve).catch((err)=>{\n                console.log(\"Error: \", err);\n            });\n        });\n    }\n    /**\n     * Gets document info object for the given document.\n     *\n     * @param document - The document to get info for.\n     * @param position - Optional position used to get offset in document.\n     * @returns The document info object and additional UTF-8 byte offset.\n     */ getDocumentInfo(document1, position) {\n        // The offset is measured in bytes.\n        const text = document1.getText();\n        const numCodeUnits = document1.offsetAt(position);\n        const offset = numCodeUnitsToNumUtf8Bytes(text, numCodeUnits);\n        const language = languageIdToEnum(document1.languageId);\n        if (language === Language.UNSPECIFIED) {\n            console.warn(`Unknown language: ${document1.languageId}`);\n        }\n        const documentInfo = new Document$1({\n            text: text,\n            editorLanguage: document1.languageId,\n            language,\n            cursorOffset: BigInt(offset),\n            lineEnding: \"\\n\"\n        });\n        return documentInfo;\n    }\n    /**\n     * Converts the completion and range to inline completion item.\n     *\n     * @param completionItem\n     * @param document\n     * @returns Inline completion item.\n     */ createInlineCompletionItem(completionItem, document1) {\n        if (!completionItem.completion || !completionItem.range) {\n            return undefined;\n        }\n        // Create and return inlineCompletionItem.\n        const text = document1.getText();\n        const startPosition = document1.positionAt(numUtf8BytesToNumCodeUnits(text, Number(completionItem.range.startOffset)));\n        const endPosition = document1.positionAt(numUtf8BytesToNumCodeUnits(text, Number(completionItem.range.endOffset)));\n        const range = new Range(startPosition, endPosition);\n        const inlineCompletionItem = new MonacoInlineCompletion(completionItem.completion.text, range, completionItem.completion.completionId);\n        return inlineCompletionItem;\n    }\n}\nclass InlineCompletionProvider {\n    constructor(grpcClient, setCompletionCount, setCodeiumStatus, setCodeiumStatusMessage, apiKey, multilineModelThreshold){\n        this.setCompletionCount = setCompletionCount;\n        this.numCompletionsProvided = 0;\n        this.completionProvider = new MonacoCompletionProvider(grpcClient, setCodeiumStatus, setCodeiumStatusMessage, apiKey, multilineModelThreshold);\n    }\n    freeInlineCompletions() {\n    // nothing\n    }\n    provideInlineCompletions(model, position, context, token) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const completions = yield this.completionProvider.provideInlineCompletions(model, position, token);\n            // Only count completions provided if non-empty (i.e. exclude cancelled\n            // requests).\n            // TODO(nick): don't count cached results either.\n            // TODO(nick): better distinguish warning and error states.\n            if (completions) {\n                this.numCompletionsProvided += 1;\n                this.setCompletionCount(this.numCompletionsProvided);\n            }\n            return completions;\n        });\n    }\n    acceptedLastCompletion(completionId) {\n        this.completionProvider.acceptedLastCompletion(completionId);\n    }\n    updateOtherDocuments(otherDocuments) {\n        this.completionProvider.otherDocuments = otherDocuments;\n    }\n}\n/**\n * Renders the Codeium logo as an SVG image.\n *\n * @param {Object} props - The component props.\n * @param {string} props.className - The class name to apply to the SVG element.\n * @param {boolean} props.loading - Whether the logo should represent a loading state.\n * @return {JSX.Element} - The JSX element representing the SVG image.\n */ const CodeiumLogo = (_a)=>{\n    var { className, loading = false } = _a, props = __rest(_a, [\n        \"className\",\n        \"loading\"\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", Object.assign({\n        viewBox: \"0 0 124 124\",\n        \"aria-label\": \"Codeium Logo\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, props, {\n        className: className\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"mask\", {\n        id: \"mask0_306_96\",\n        style: {\n            maskType: \"alpha\"\n        },\n        maskUnits: \"userSpaceOnUse\",\n        x: \"0\",\n        y: \"0\",\n        width: \"124\",\n        height: \"124\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M0 10C0 4.47715 4.47715 0 10 0H114C119.523 0 124 4.47715 124 10V114C124 119.523 119.523 124 114 124H10C4.47715 124 0 119.523 0 114V10Z\",\n        fill: \"#D9D9D9\"\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n        mask: \"url(#mask0_306_96)\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M62 62L0 124V0L62 62Z\",\n        fill: \"#60D5C4\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M62 62L124 124V0L62 62Z\",\n        fill: \"#60D5C4\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M62 62L124 124L0 124L62 62Z\",\n        fill: \"#71E9D8\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M62 62L124 0L0 0L62 62Z\",\n        fill: \"#71E9D8\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M107.387 16H16.6133C16.2746 16 16 16.2746 16 16.6133V107.387C16 107.725 16.2746 108 16.6133 108H107.387C107.725 108 108 107.725 108 107.387V16.6133C108 16.2746 107.725 16 107.387 16Z\",\n        fill: \"#09B6A2\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M75.196 77.1134C74.1902 77.1134 73.3102 76.7612 72.5559 76.0566C71.8375 75.3169 71.4783 74.4538 71.4783 73.4675C71.4783 72.4459 71.8375 71.5828 72.5559 70.8783C73.3102 70.1386 74.1902 69.7687 75.196 69.7687C76.2377 69.7687 77.1177 70.1386 77.8361 70.8783C78.5545 71.5828 78.9137 72.4459 78.9137 73.4675C78.9137 74.4538 78.5545 75.3169 77.8361 76.0566C77.1177 76.7612 76.2377 77.1134 75.196 77.1134Z\",\n        fill: \"white\",\n        \"aria-label\": \"right-dot\",\n        className: loading ? \"animate-blink duration-1000\" : \"\",\n        style: {\n            animationDelay: \"666ms\"\n        }\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M62.3573 77.1134C61.3516 77.1134 60.4715 76.7612 59.7172 76.0566C58.9988 75.3169 58.6396 74.4538 58.6396 73.4675C58.6396 72.4459 58.9988 71.5828 59.7172 70.8783C60.4715 70.1386 61.3516 69.7687 62.3573 69.7687C63.399 69.7687 64.2791 70.1386 64.9974 70.8783C65.7158 71.5828 66.075 72.4459 66.075 73.4675C66.075 74.4538 65.7158 75.3169 64.9974 76.0566C64.2791 76.7612 63.399 77.1134 62.3573 77.1134Z\",\n        fill: \"white\",\n        \"aria-label\": \"middle-dot\",\n        className: loading ? \"animate-blink duration-1000\" : \"\",\n        style: {\n            animationDelay: \"333ms\"\n        }\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M49.519 77.1134C48.5132 77.1134 47.6332 76.7612 46.8789 76.0566C46.1605 75.3169 45.8013 74.4538 45.8013 73.4675C45.8013 72.4459 46.1605 71.5828 46.8789 70.8783C47.6332 70.1386 48.5132 69.7687 49.519 69.7687C50.5607 69.7687 51.4407 70.1386 52.1591 70.8783C52.8775 71.5828 53.2367 72.4459 53.2367 73.4675C53.2367 74.4538 52.8775 75.3169 52.1591 76.0566C51.4407 76.7612 50.5607 77.1134 49.519 77.1134Z\",\n        fill: \"white\",\n        \"aria-label\": \"left-dot\",\n        className: loading ? \"animate-blink duration-1000\" : \"\",\n        style: {\n            animationDelay: \"0ms\"\n        }\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M85.9869 88.6325C85.1967 88.6325 84.5501 88.3683 84.0473 87.8399C83.5444 87.3468 83.2929 86.7127 83.2929 85.9377C83.2929 85.1275 83.5444 84.4758 84.0473 83.9826C84.5501 83.4894 85.1967 83.2429 85.9869 83.2429C88.178 83.2429 89.2736 82.1684 89.2736 80.0196V67.7079C89.2736 65.2421 89.8483 63.287 90.9977 61.8427C90.423 61.1029 89.992 60.2399 89.7046 59.2535C89.4173 58.2672 89.2736 57.1575 89.2736 55.9246V43.6129C89.2736 41.4641 88.178 40.3897 85.9869 40.3897C85.1967 40.3897 84.5501 40.1431 84.0473 39.6499C83.5444 39.1567 83.2929 38.5227 83.2929 37.7477C83.2929 36.9727 83.5444 36.321 84.0473 35.7926C84.5501 35.2642 85.1967 35 85.9869 35C91.8419 35 94.7693 37.871 94.7693 43.6129V55.9246C94.7693 58.0734 95.8469 59.1478 98.0021 59.1478C98.7924 59.1478 99.4389 59.3944 99.9418 59.8876C100.481 60.3808 100.75 61.0325 100.75 61.8427C100.75 62.6177 100.481 63.2517 99.9418 63.7449C99.4389 64.2381 98.7924 64.4847 98.0021 64.4847C95.8469 64.4847 94.7693 65.5591 94.7693 67.7079V80.0196C94.7693 85.7616 91.8419 88.6325 85.9869 88.6325Z\",\n        fill: \"white\",\n        \"aria-label\": \"open-bracket\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M38.7631 88.6325C32.9081 88.6325 29.9807 85.7616 29.9807 80.0196V67.7079C29.9807 65.5591 28.9031 64.4847 26.7479 64.4847C25.9576 64.4847 25.2931 64.2381 24.7543 63.7449C24.2514 63.2517 24 62.6177 24 61.8427C24 61.0325 24.2514 60.3808 24.7543 59.8876C25.2931 59.3944 25.9576 59.1478 26.7479 59.1478C28.9031 59.1478 29.9807 58.0734 29.9807 55.9246V43.6129C29.9807 37.871 32.9081 35 38.7631 35C39.5533 35 40.1999 35.2642 40.7027 35.7926C41.2056 36.321 41.4571 36.9727 41.4571 37.7477C41.4571 38.5227 41.2056 39.1567 40.7027 39.6499C40.1999 40.1431 39.5533 40.3897 38.7631 40.3897C36.572 40.3897 35.4764 41.4641 35.4764 43.6129V55.9246C35.4764 57.1575 35.3327 58.2672 35.0454 59.2535C34.758 60.2399 34.327 61.1029 33.7522 61.8427C34.9017 63.287 35.4764 65.2421 35.4764 67.7079V80.0196C35.4764 82.1684 36.572 83.2429 38.7631 83.2429C39.5533 83.2429 40.1999 83.4894 40.7027 83.9826C41.2056 84.4758 41.4571 85.1275 41.4571 85.9377C41.4571 86.7127 41.2056 87.3468 40.7027 87.8399C40.1999 88.3683 39.5533 88.6325 38.7631 88.6325Z\",\n        fill: \"white\",\n        \"aria-label\": \"close-bracket\"\n    })));\n};\n/**\n * Merges a partial object with a fallback object, deeply combining the two.\n *\n * @param {Partial<T>} partial - the partial object to merge (can be undefined)\n * @param {T} fallback - the fallback object to merge with\n * @return {T} the merged object\n */ function deepMerge(partial, fallback) {\n    const merged = Object.assign({}, fallback);\n    for(const key in partial){\n        if (typeof partial[key] === \"object\" && !Array.isArray(partial[key])) {\n            if (fallback[key] && typeof fallback[key] === \"object\" && !Array.isArray(fallback[key])) {\n                merged[key] = deepMerge(partial[key], fallback[key]);\n            } else {\n                merged[key] = Object.assign({}, partial[key]);\n            }\n        } else {\n            merged[key] = partial[key];\n        }\n    }\n    return merged;\n}\n/**\n * Code editor that enables Codeium AI suggestions in the editor.\n * The layout by default is width = 100% and height = 300px. These values can be overridden by passing in a string value to the width and/or height props.\n */ const CodeiumEditor = (_a)=>{\n    var { languageServerAddress = \"https://web-backend.codeium.com\", otherDocuments = [], containerClassName = \"\", containerStyle = {} } = _a, props = __rest(_a, [\n        \"languageServerAddress\",\n        \"otherDocuments\",\n        \"containerClassName\",\n        \"containerStyle\"\n    ]);\n    const editorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const monacoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const inlineCompletionsProviderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [acceptedCompletionCount, setAcceptedCompletionCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(-1);\n    const [completionCount, setCompletionCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [codeiumStatus, setCodeiumStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(Status.INACTIVE);\n    const [codeiumStatusMessage, setCodeiumStatusMessage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const transport = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return createConnectTransport({\n            baseUrl: languageServerAddress,\n            useBinaryFormat: true\n        });\n    }, [\n        languageServerAddress\n    ]);\n    const grpcClient = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return createPromiseClient(LanguageServerService, transport);\n    }, [\n        transport\n    ]);\n    inlineCompletionsProviderRef.current = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return new InlineCompletionProvider(grpcClient, setCompletionCount, setCodeiumStatus, setCodeiumStatusMessage, props.apiKey, props.multilineModelThreshold);\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!(editorRef === null || editorRef === void 0 ? void 0 : editorRef.current) || !monacoRef.current || !inlineCompletionsProviderRef.current) {\n            return;\n        }\n        const monaco = monacoRef.current;\n        const providerDisposable = monaco.languages.registerInlineCompletionsProvider({\n            pattern: \"**\"\n        }, inlineCompletionsProviderRef.current);\n        const completionDisposable = monaco.editor.registerCommand(\"codeium.acceptCompletion\", (_, completionId, insertText)=>{\n            var _a;\n            try {\n                if (props.onAutocomplete) {\n                    props.onAutocomplete(insertText);\n                }\n                setAcceptedCompletionCount(acceptedCompletionCount + 1);\n                (_a = inlineCompletionsProviderRef.current) === null || _a === void 0 ? void 0 : _a.acceptedLastCompletion(completionId);\n            } catch (err) {\n                console.log(\"Err\");\n            }\n        });\n        return ()=>{\n            providerDisposable.dispose();\n            completionDisposable.dispose();\n        };\n    }, [\n        editorRef === null || editorRef === void 0 ? void 0 : editorRef.current,\n        monacoRef === null || monacoRef === void 0 ? void 0 : monacoRef.current,\n        inlineCompletionsProviderRef === null || inlineCompletionsProviderRef === void 0 ? void 0 : inlineCompletionsProviderRef.current,\n        acceptedCompletionCount,\n        mounted\n    ]);\n    const handleEditorDidMount = (editor, monaco)=>__awaiter(void 0, void 0, void 0, function*() {\n            editorRef.current = editor;\n            monacoRef.current = monaco;\n            setMounted(true);\n            // CORS pre-flight cache optimization.\n            try {\n                yield grpcClient.getCompletions({});\n            } catch (e) {\n            // This is expected.\n            }\n            // Pass the editor instance to the user defined onMount prop.\n            if (props.onMount) {\n                props.onMount(editor, monaco);\n            }\n        });\n    // Keep other documents up to date.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a;\n        (_a = inlineCompletionsProviderRef.current) === null || _a === void 0 ? void 0 : _a.updateOtherDocuments(otherDocuments);\n    }, [\n        otherDocuments\n    ]);\n    let defaultLanguageProps = {\n        defaultLanguage: props.language,\n        defaultValue: getDefaultValue(props.language)\n    };\n    const layout = {\n        width: props.width || \"100%\",\n        // The height is set to 300px by default. Otherwise, the editor when\n        // rendered with the default value will not be visible.\n        // The monaco editor's default height is 100% but it requires the user to\n        // define a container with an explicit height.\n        height: props.height || \"300px\"\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        style: Object.assign(Object.assign(Object.assign({}, layout), {\n            position: \"relative\"\n        }), containerStyle),\n        className: containerClassName\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", {\n        href: \"https://codeium.com?referrer=codeium-editor\",\n        target: \"_blank\",\n        rel: \"noreferrer noopener\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CodeiumLogo, {\n        width: 30,\n        height: 30,\n        style: {\n            position: \"absolute\",\n            top: 12,\n            right: 12,\n            zIndex: 1\n        }\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Ft, Object.assign({}, defaultLanguageProps, props, {\n        width: layout.width,\n        height: layout.height,\n        onMount: handleEditorDidMount,\n        options: deepMerge(props.options, {\n            scrollBeyondLastColumn: 0,\n            scrollbar: {\n                alwaysConsumeMouseWheel: false\n            },\n            codeLens: false,\n            // for resizing, but apparently might have \"severe performance impact\"\n            // automaticLayout: true,\n            minimap: {\n                enabled: false\n            },\n            quickSuggestions: false,\n            folding: false,\n            foldingHighlight: false,\n            foldingImportsByDefault: false,\n            links: false,\n            fontSize: 14,\n            wordWrap: \"on\"\n        })\n    })));\n};\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVpdW0vcmVhY3QtY29kZS1lZGl0b3IvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OEVBYUEsR0FDQSx1REE0Qk8sU0FBU0EsT0FBT0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ3ZCLElBQUlDLElBQUk7SUFDUixJQUFLLElBQUlDLEtBQUtILEVBQUcsSUFBSUksT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1AsR0FBR0csTUFBTUYsRUFBRU8sT0FBTyxDQUFDTCxLQUFLLEdBQzlFRCxDQUFDLENBQUNDLEVBQUUsR0FBR0gsQ0FBQyxDQUFDRyxFQUFFO0lBQ2YsSUFBSUgsS0FBSyxRQUFRLE9BQU9JLE9BQU9LLHFCQUFxQixLQUFLLFlBQ3JELElBQUssSUFBSUMsSUFBSSxHQUFHUCxJQUFJQyxPQUFPSyxxQkFBcUIsQ0FBQ1QsSUFBSVUsSUFBSVAsRUFBRVEsTUFBTSxFQUFFRCxJQUFLO1FBQ3BFLElBQUlULEVBQUVPLE9BQU8sQ0FBQ0wsQ0FBQyxDQUFDTyxFQUFFLElBQUksS0FBS04sT0FBT0MsU0FBUyxDQUFDTyxvQkFBb0IsQ0FBQ0wsSUFBSSxDQUFDUCxHQUFHRyxDQUFDLENBQUNPLEVBQUUsR0FDekVSLENBQUMsQ0FBQ0MsQ0FBQyxDQUFDTyxFQUFFLENBQUMsR0FBR1YsQ0FBQyxDQUFDRyxDQUFDLENBQUNPLEVBQUUsQ0FBQztJQUN4QjtJQUNMLE9BQU9SO0FBQ1g7QUE4RE8sU0FBU1csVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUN2RCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFPO0lBQU07SUFDNUcsT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFPLEdBQUcsU0FBVUQs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QSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0lBRUE7O0tBRUcsR0FDSEEsUUFBQSxDQUFBQSxRQUFBO0FBQ0Ys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Qy9CcFMsY0FBYzBYLGdCQUFnQnVPLE1BQU03VCxRQUFROztJQUc5QyxNQUFNb1csU0FBUztRQUNiNVksT0FBT3FXLE1BQU1yVyxLQUFLLElBQUk7Ozs7O1FBS3RCSSxRQUFRaVcsTUFBTWpXLE1BQU0sSUFBSTs7SUFHMUIscUJBQ0VrVyxnREFBQTtRQUNFM1YsT0FBS2wwQixPQUFBd0UsTUFBQSxDQUFBeEUsT0FBQXdFLE1BQUEsQ0FBQXhFLE9BQUF3RSxNQUFBLEtBQ0EybkMsU0FDSDtZQUFBL1ksVUFBVTtRQUNQLElBQUFzWDtRQUVMbFcsV0FBV2lXO0lBQWtCLGlCQUU3QlosZ0RBQ0U7UUFBQXJILE1BQU07UUFDTnB2QixRQUFPO1FBQ1BnNUIsS0FBSTtJQUFxQixpQkFFekJ2QyxnREFBQSxDQUFDRixhQUFXO1FBQ1ZwVyxPQUFPO1FBQ1BJLFFBQVE7UUFDUk8sT0FBTztZQUFFZCxVQUFVO1lBQVlpWixLQUFLO1lBQUlDLE9BQU87WUFBSUMsUUFBUTtRQUFHO0lBQUEsbUJBR2xFMUMsZ0RBQUEsQ0FBQzJDLElBQU14c0MsT0FBQXdFLE1BQUEsS0FDRDBuQyxzQkFDQXRDLE9BQUs7UUFDVHJXLE9BQU80WSxPQUFPNVksS0FBSztRQUNuQkksUUFBUXdZLE9BQU94WSxNQUFNO1FBQ3JCa0QsU0FBU29WO1FBQ1QvbUMsU0FBU21sQyxVQUNQVCxNQUFNMWtDLE9BQU8sRUFDYjtZQUNFdW5DLHdCQUF3QjtZQUN4QkMsV0FBVztnQkFDVEMseUJBQXlCO1lBQzFCO1lBQ0RDLFVBQVU7OztZQUdWQyxTQUFTO2dCQUNQQyxTQUFTO1lBQ1Y7WUFDREMsa0JBQWtCO1lBQ2xCQyxTQUFTO1lBQ1RDLGtCQUFrQjtZQUNsQkMseUJBQXlCO1lBQ3pCQyxPQUFPO1lBQ1BDLFVBQVU7WUFDVkMsVUFBVTs7SUFFYjtBQUlUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHJvbGx1cCtwbHVnaW4tdHlwZXNjcmlwdEAxMS4xLjVfcm9sbHVwQDQuNy4wX3RzbGliQDIuNi4yX3R5cGVzY3JpcHRANS4zLjMvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz82MzU1Iiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvYXNzZXJ0LmpzPzI2OWQiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9lbnVtLmpzPzM5ZmEiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vbWVzc2FnZS5qcz80MmNiIiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvbWVzc2FnZS10eXBlLmpzPzBiY2YiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9wcm90by1ydW50aW1lLmpzP2JiMmEiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vZmllbGQuanM/NDNhYSIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9nb29nbGUvdmFyaW50LmpzP2JkYjgiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJvdG8taW50NjQuanM/MDVlNiIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9iaW5hcnktZW5jb2RpbmcuanM/MTI1OCIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2ZpZWxkLXdyYXBwZXIuanM/ZGFhYyIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL3NjYWxhcnMuanM/MTc3YSIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2JpbmFyeS1mb3JtYXQtY29tbW9uLmpzPzY2MDUiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9iaW5hcnktZm9ybWF0LXByb3RvMy5qcz83YjIzIiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3Byb3RvLWJhc2U2NC5qcz9mOTZmIiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvanNvbi1mb3JtYXQtY29tbW9uLmpzPzNlOWEiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9qc29uLWZvcm1hdC1wcm90bzMuanM/MjUzNiIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL3V0aWwtY29tbW9uLmpzPzQwZWYiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9maWVsZC1saXN0LmpzPzFkMjgiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9uYW1lcy5qcz9kNjlhIiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvZmllbGQuanM/YjQ5ZCIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcm90bzMuanM/Mjk5NSIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9zZXJ2aWNlLXR5cGUuanM/ZjU5YiIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29ubmVjdHJwYytjb25uZWN0QDEuMS4zX0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9jb2RlLmpzP2NlNzciLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvbm5lY3RycGMrY29ubmVjdEAxLjEuM19AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtY29ubmVjdC9jb2RlLXN0cmluZy5qcz81NzBlIiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb25uZWN0cnBjK2Nvbm5lY3RAMS4xLjNfQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL2Nvbm5lY3QtZXJyb3IuanM/N2U2MiIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29ubmVjdHJwYytjb25uZWN0QDEuMS4zX0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9odHRwLWhlYWRlcnMuanM/MzhhNyIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29ubmVjdHJwYytjb25uZWN0QDEuMS4zX0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9hbnktY2xpZW50LmpzPzc5YWYiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvbm5lY3RycGMrY29ubmVjdEAxLjEuM19AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wvZW52ZWxvcGUuanM/MTNkMiIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29ubmVjdHJwYytjb25uZWN0QDEuMS4zX0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9hc3luYy1pdGVyYWJsZS5qcz8xYTQ3Iiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb25uZWN0cnBjK2Nvbm5lY3RAMS4xLjNfQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb21pc2UtY2xpZW50LmpzP2VkZWEiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvbm5lY3RycGMrY29ubmVjdEAxLjEuM19AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wvc2lnbmFscy5qcz82NWVkIiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb25uZWN0cnBjK2Nvbm5lY3RAMS4xLjNfQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL2NvbnRleHQtdmFsdWVzLmpzPzEyNjUiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvbm5lY3RycGMrY29ubmVjdEAxLjEuM19AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wvY3JlYXRlLW1ldGhvZC11cmwuanM/ZjQxYiIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29ubmVjdHJwYytjb25uZWN0QDEuMS4zX0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9ub3JtYWxpemUuanM/YWYxYiIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29ubmVjdHJwYytjb25uZWN0QDEuMS4zX0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9zZXJpYWxpemF0aW9uLmpzP2YzOWIiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvbm5lY3RycGMrY29ubmVjdEAxLjEuM19AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtY29ubmVjdC9jb250ZW50LXR5cGUuanM/MWZkMyIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29ubmVjdHJwYytjb25uZWN0QDEuMS4zX0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L2Vycm9yLWpzb24uanM/YTQ5MiIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29ubmVjdHJwYytjb25uZWN0QDEuMS4zX0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L2VuZC1zdHJlYW0uanM/MzY5OCIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29ubmVjdHJwYytjb25uZWN0QDEuMS4zX0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L2hlYWRlcnMuanM/NzNiZiIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29ubmVjdHJwYytjb25uZWN0QDEuMS4zX0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L2h0dHAtc3RhdHVzLmpzP2E0MjIiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvbm5lY3RycGMrY29ubmVjdEAxLjEuM19AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtY29ubmVjdC90cmFpbGVyLW11eC5qcz85ZThjIiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb25uZWN0cnBjK2Nvbm5lY3RAMS4xLjNfQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvdmVyc2lvbi5qcz9lNWJmIiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb25uZWN0cnBjK2Nvbm5lY3RAMS4xLjNfQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvcmVxdWVzdC1oZWFkZXIuanM/NmE1YiIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29ubmVjdHJwYytjb25uZWN0QDEuMS4zX0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L3ZhbGlkYXRlLXJlc3BvbnNlLmpzP2MxODQiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvbm5lY3RycGMrY29ubmVjdEAxLjEuM19AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtY29ubmVjdC9nZXQtcmVxdWVzdC5qcz8zNDI0Iiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb25uZWN0cnBjK2Nvbm5lY3RAMS4xLjNfQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL3J1bi1jYWxsLmpzPzFmODEiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvbm5lY3RycGMrY29ubmVjdC13ZWJAMS4xLjNfQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yX0Bjb25uZWN0cnBjK2Nvbm5lY3RAMS4xLjMvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3Qtd2ViL2Rpc3QvZXNtL2Fzc2VydC1mZXRjaC1hcGkuanM/ZjQwNSIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29ubmVjdHJwYytjb25uZWN0LXdlYkAxLjEuM19AYnVmYnVpbGQrcHJvdG9idWZAMS40LjJfQGNvbm5lY3RycGMrY29ubmVjdEAxLjEuMy9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC13ZWIvZGlzdC9lc20vY29ubmVjdC10cmFuc3BvcnQuanM/M2UwMSIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL3NyYy9jb21wb25lbnRzL0NvZGVpdW1FZGl0b3IvU3RhdHVzLnRzPzE4MDgiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vbmFjby1lZGl0b3IrbG9hZGVyQDEuNC4wX21vbmFjby1lZGl0b3JAMC40NS4wL25vZGVfbW9kdWxlcy9AbW9uYWNvLWVkaXRvci9sb2FkZXIvbGliL2VzL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanM/MWNhMyIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdGF0ZS1sb2NhbEAxLjAuNy9ub2RlX21vZHVsZXMvc3RhdGUtbG9jYWwvbGliL2VzL3N0YXRlLWxvY2FsLmpzPzk5NTIiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vbmFjby1lZGl0b3IrbG9hZGVyQDEuNC4wX21vbmFjby1lZGl0b3JAMC40NS4wL25vZGVfbW9kdWxlcy9AbW9uYWNvLWVkaXRvci9sb2FkZXIvbGliL2VzL2NvbmZpZy9pbmRleC5qcz9jNGY5Iiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Btb25hY28tZWRpdG9yK2xvYWRlckAxLjQuMF9tb25hY28tZWRpdG9yQDAuNDUuMC9ub2RlX21vZHVsZXMvQG1vbmFjby1lZGl0b3IvbG9hZGVyL2xpYi9lcy91dGlscy9jdXJyeS5qcz81ZWJkIiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Btb25hY28tZWRpdG9yK2xvYWRlckAxLjQuMF9tb25hY28tZWRpdG9yQDAuNDUuMC9ub2RlX21vZHVsZXMvQG1vbmFjby1lZGl0b3IvbG9hZGVyL2xpYi9lcy91dGlscy9pc09iamVjdC5qcz82NjNhIiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Btb25hY28tZWRpdG9yK2xvYWRlckAxLjQuMF9tb25hY28tZWRpdG9yQDAuNDUuMC9ub2RlX21vZHVsZXMvQG1vbmFjby1lZGl0b3IvbG9hZGVyL2xpYi9lcy92YWxpZGF0b3JzL2luZGV4LmpzPzk0YmQiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vbmFjby1lZGl0b3IrbG9hZGVyQDEuNC4wX21vbmFjby1lZGl0b3JAMC40NS4wL25vZGVfbW9kdWxlcy9AbW9uYWNvLWVkaXRvci9sb2FkZXIvbGliL2VzL3V0aWxzL2NvbXBvc2UuanM/ZWE4MyIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbW9uYWNvLWVkaXRvcitsb2FkZXJAMS40LjBfbW9uYWNvLWVkaXRvckAwLjQ1LjAvbm9kZV9tb2R1bGVzL0Btb25hY28tZWRpdG9yL2xvYWRlci9saWIvZXMvdXRpbHMvZGVlcE1lcmdlLmpzP2JiNzgiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vbmFjby1lZGl0b3IrbG9hZGVyQDEuNC4wX21vbmFjby1lZGl0b3JAMC40NS4wL25vZGVfbW9kdWxlcy9AbW9uYWNvLWVkaXRvci9sb2FkZXIvbGliL2VzL3V0aWxzL21ha2VDYW5jZWxhYmxlLmpzPzM1OTQiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1vbmFjby1lZGl0b3IrbG9hZGVyQDEuNC4wX21vbmFjby1lZGl0b3JAMC40NS4wL25vZGVfbW9kdWxlcy9AbW9uYWNvLWVkaXRvci9sb2FkZXIvbGliL2VzL2xvYWRlci9pbmRleC5qcz8wNjhkIiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Btb25hY28tZWRpdG9yK3JlYWN0QDQuNi4wX21vbmFjby1lZGl0b3JAMC40NS4wX3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AbW9uYWNvLWVkaXRvci9yZWFjdC9kaXN0L2luZGV4Lm1qcz83MzgyIiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vc3JjL2NvbXBvbmVudHMvQ29kZWl1bUVkaXRvci9kZWZhdWx0VmFsdWVzLnRzPzFkM2MiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9zcmMvYXBpL3Byb3RvL2V4YS9jb2RlaXVtX2NvbW1vbl9wYi9jb2RlaXVtX2NvbW1vbl9wYi50cz8yMDJlIiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vc3JjL2FwaS9wcm90by9leGEvbGFuZ3VhZ2Vfc2VydmVyX3BiL2xhbmd1YWdlX3NlcnZlcl9wYi50cz84YjlkIiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vc3JjL2FwaS9wcm90by9leGEvbGFuZ3VhZ2Vfc2VydmVyX3BiL2xhbmd1YWdlX3NlcnZlcl9jb25uZWN0LnRzPzlhYWQiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9zcmMvY29tcG9uZW50cy9Db2RlaXVtRWRpdG9yL0xvY2F0aW9uLnRzPzA2NmYiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9zcmMvY29tcG9uZW50cy9Db2RlaXVtRWRpdG9yL0xpbmUudHM/ZDAwMSIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL3NyYy9jb21wb25lbnRzL0NvZGVpdW1FZGl0b3IvRG9jdW1lbnQudHM/OTc3YiIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL3NyYy91dGlscy91dGYudHM/ZDA0NyIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL3NyYy91dGlscy91dWlkLnRzPzE1ZmEiLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9zcmMvdXRpbHMvaWRlbnRpdHkudHM/YWFlMCIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL3NyYy91dGlscy9sYW5ndWFnZS50cz9kMmNmIiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vc3JjL2NvbXBvbmVudHMvQ29kZWl1bUVkaXRvci9Db21wbGV0aW9uUHJvdmlkZXIudHM/ODMwYiIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL3NyYy9jb21wb25lbnRzL0NvZGVpdW1FZGl0b3IvSW5saW5lQ29tcGxldGlvblByb3ZpZGVyLnRzPzNmNTciLCJ3ZWJwYWNrOi8vY2xpZW50MC8uLi8uLi9zcmMvY29tcG9uZW50cy9Db2RlaXVtTG9nby9Db2RlaXVtTG9nby50c3g/N2JhMCIsIndlYnBhY2s6Ly9jbGllbnQwLy4uLy4uL3NyYy91dGlscy9tZXJnZS50cz9jYmE4Iiwid2VicGFjazovL2NsaWVudDAvLi4vLi4vc3JjL2NvbXBvbmVudHMvQ29kZWl1bUVkaXRvci9Db2RlaXVtRWRpdG9yLnRzeD80ODE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXNEZWNvcmF0ZShjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xyXG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XHJcbiAgICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xyXG4gICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XHJcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcclxuICAgIHZhciBfLCBkb25lID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XHJcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcclxuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcclxuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcclxuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xyXG4gICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xyXG4gICAgZG9uZSA9IHRydWU7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19ydW5Jbml0aWFsaXplcnModGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xyXG4gICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcHJvcEtleSh4KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zZXRGdW5jdGlvbk5hbWUoZiwgbmFtZSwgcHJlZml4KSB7XHJcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIG5hbWUgPSBuYW1lLmRlc2NyaXB0aW9uID8gXCJbXCIuY29uY2F0KG5hbWUuZGVzY3JpcHRpb24sIFwiXVwiKSA6IFwiXCI7XHJcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IGZhbHNlIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEluKHN0YXRlLCByZWNlaXZlcikge1xyXG4gICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52LCB2YWx1ZSwgYXN5bmMpIHtcclxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZC5cIik7XHJcbiAgICAgICAgdmFyIGRpc3Bvc2U7XHJcbiAgICAgICAgaWYgKGFzeW5jKSB7XHJcbiAgICAgICAgICAgIGlmICghU3ltYm9sLmFzeW5jRGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0Rpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmFzeW5jRGlzcG9zZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXNwb3NlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgaWYgKCFTeW1ib2wuZGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5kaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkaXNwb3NlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qgbm90IGRpc3Bvc2FibGUuXCIpO1xyXG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhc3luYykge1xyXG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbnZhciBfU3VwcHJlc3NlZEVycm9yID0gdHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kaXNwb3NlUmVzb3VyY2VzKGVudikge1xyXG4gICAgZnVuY3Rpb24gZmFpbChlKSB7XHJcbiAgICAgICAgZW52LmVycm9yID0gZW52Lmhhc0Vycm9yID8gbmV3IF9TdXBwcmVzc2VkRXJyb3IoZSwgZW52LmVycm9yLCBcIkFuIGVycm9yIHdhcyBzdXBwcmVzc2VkIGR1cmluZyBkaXNwb3NhbC5cIikgOiBlO1xyXG4gICAgICAgIGVudi5oYXNFcnJvciA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgICAgIHdoaWxlIChlbnYuc3RhY2subGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciByZWMgPSBlbnYuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVjLmRpc3Bvc2UgJiYgcmVjLmRpc3Bvc2UuY2FsbChyZWMudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlYy5hc3luYykgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4obmV4dCwgZnVuY3Rpb24oZSkgeyBmYWlsKGUpOyByZXR1cm4gbmV4dCgpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgZmFpbChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW52Lmhhc0Vycm9yKSB0aHJvdyBlbnYuZXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV4dCgpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBfX2V4dGVuZHM6IF9fZXh0ZW5kcyxcclxuICAgIF9fYXNzaWduOiBfX2Fzc2lnbixcclxuICAgIF9fcmVzdDogX19yZXN0LFxyXG4gICAgX19kZWNvcmF0ZTogX19kZWNvcmF0ZSxcclxuICAgIF9fcGFyYW06IF9fcGFyYW0sXHJcbiAgICBfX21ldGFkYXRhOiBfX21ldGFkYXRhLFxyXG4gICAgX19hd2FpdGVyOiBfX2F3YWl0ZXIsXHJcbiAgICBfX2dlbmVyYXRvcjogX19nZW5lcmF0b3IsXHJcbiAgICBfX2NyZWF0ZUJpbmRpbmc6IF9fY3JlYXRlQmluZGluZyxcclxuICAgIF9fZXhwb3J0U3RhcjogX19leHBvcnRTdGFyLFxyXG4gICAgX192YWx1ZXM6IF9fdmFsdWVzLFxyXG4gICAgX19yZWFkOiBfX3JlYWQsXHJcbiAgICBfX3NwcmVhZDogX19zcHJlYWQsXHJcbiAgICBfX3NwcmVhZEFycmF5czogX19zcHJlYWRBcnJheXMsXHJcbiAgICBfX3NwcmVhZEFycmF5OiBfX3NwcmVhZEFycmF5LFxyXG4gICAgX19hd2FpdDogX19hd2FpdCxcclxuICAgIF9fYXN5bmNHZW5lcmF0b3I6IF9fYXN5bmNHZW5lcmF0b3IsXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yOiBfX2FzeW5jRGVsZWdhdG9yLFxyXG4gICAgX19hc3luY1ZhbHVlczogX19hc3luY1ZhbHVlcyxcclxuICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0OiBfX21ha2VUZW1wbGF0ZU9iamVjdCxcclxuICAgIF9faW1wb3J0U3RhcjogX19pbXBvcnRTdGFyLFxyXG4gICAgX19pbXBvcnREZWZhdWx0OiBfX2ltcG9ydERlZmF1bHQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0OiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldDogX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRJbjogX19jbGFzc1ByaXZhdGVGaWVsZEluLFxyXG4gICAgX19hZGREaXNwb3NhYmxlUmVzb3VyY2U6IF9fYWRkRGlzcG9zYWJsZVJlc291cmNlLFxyXG4gICAgX19kaXNwb3NlUmVzb3VyY2VzOiBfX2Rpc3Bvc2VSZXNvdXJjZXMsXHJcbn07XHJcbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEFzc2VydCB0aGF0IGNvbmRpdGlvbiBpcyB0cnV0aHkgb3IgdGhyb3cgZXJyb3IgKHdpdGggbWVzc2FnZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBib29sZWFuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuY29uc3QgRkxPQVQzMl9NQVggPSAzLjQwMjgyMzQ2NjM4NTI4ODZlMzgsIEZMT0FUMzJfTUlOID0gLTMuNDAyODIzNDY2Mzg1Mjg4NmUzOCwgVUlOVDMyX01BWCA9IDB4ZmZmZmZmZmYsIElOVDMyX01BWCA9IDB4N2ZmZmZmZmYsIElOVDMyX01JTiA9IC0weDgwMDAwMDAwO1xuLyoqXG4gKiBBc3NlcnQgYSB2YWxpZCBzaWduZWQgcHJvdG9idWYgMzItYml0IGludGVnZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRJbnQzMihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnQgMzI6IFwiICsgdHlwZW9mIGFyZyk7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFyZykgfHwgYXJnID4gSU5UMzJfTUFYIHx8IGFyZyA8IElOVDMyX01JTilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnQgMzI6IFwiICsgYXJnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAtLSB3ZSB3YW50IHRoZSBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIHN0cmluZ1xufVxuLyoqXG4gKiBBc3NlcnQgYSB2YWxpZCB1bnNpZ25lZCBwcm90b2J1ZiAzMi1iaXQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFVJbnQzMihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50IDMyOiBcIiArIHR5cGVvZiBhcmcpO1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihhcmcpIHx8IGFyZyA+IFVJTlQzMl9NQVggfHwgYXJnIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cbi8qKlxuICogQXNzZXJ0IGEgdmFsaWQgcHJvdG9idWYgZmxvYXQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRGbG9hdDMyKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZsb2F0IDMyOiBcIiArIHR5cGVvZiBhcmcpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGFyZykpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoYXJnID4gRkxPQVQzMl9NQVggfHwgYXJnIDwgRkxPQVQzMl9NSU4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmxvYXQgMzI6IFwiICsgYXJnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAtLSB3ZSB3YW50IHRoZSBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIHN0cmluZ1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuL2Fzc2VydC5qc1wiO1xuY29uc3QgZW51bVR5cGVTeW1ib2wgPSBTeW1ib2woXCJAYnVmYnVpbGQvcHJvdG9idWYvZW51bS10eXBlXCIpO1xuLyoqXG4gKiBHZXQgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiBmcm9tIGEgZ2VuZXJhdGVkIGVudW0uXG4gKiBJZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIGdlbmVyYXRlZFxuICogZW51bSwgaXQgcmFpc2VzIGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW51bVR5cGUoZW51bU9iamVjdCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdCB0ID0gZW51bU9iamVjdFtlbnVtVHlwZVN5bWJvbF07XG4gICAgYXNzZXJ0KHQsIFwibWlzc2luZyBlbnVtIHR5cGUgb24gZW51bSBvYmplY3RcIik7XG4gICAgcmV0dXJuIHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbn1cbi8qKlxuICogU2V0cyByZWZsZWN0aW9uIGluZm9ybWF0aW9uIG9uIGEgZ2VuZXJhdGVkIGVudW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbnVtVHlwZShlbnVtT2JqZWN0LCB0eXBlTmFtZSwgdmFsdWVzLCBvcHQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZW51bU9iamVjdFtlbnVtVHlwZVN5bWJvbF0gPSBtYWtlRW51bVR5cGUodHlwZU5hbWUsIHZhbHVlcy5tYXAoKHYpID0+ICh7XG4gICAgICAgIG5vOiB2Lm5vLFxuICAgICAgICBuYW1lOiB2Lm5hbWUsXG4gICAgICAgIGxvY2FsTmFtZTogZW51bU9iamVjdFt2Lm5vXSxcbiAgICB9KSksIG9wdCk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBFbnVtVHlwZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRW51bVR5cGUodHlwZU5hbWUsIHZhbHVlcywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5fb3B0KSB7XG4gICAgY29uc3QgbmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IG51bWJlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IG5vcm1hbFZhbHVlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXG4gICAgICAgIC8vIGNvbnN0IHZhbHVlOiBFbnVtVmFsdWVJbmZvID0gey4uLnYsIG9wdGlvbnM6IHYub3B0aW9ucyA/PyBlbXB0eVJlYWRvbmx5T2JqZWN0fTtcbiAgICAgICAgY29uc3QgbiA9IG5vcm1hbGl6ZUVudW1WYWx1ZSh2YWx1ZSk7XG4gICAgICAgIG5vcm1hbFZhbHVlcy5wdXNoKG4pO1xuICAgICAgICBuYW1lc1t2YWx1ZS5uYW1lXSA9IG47XG4gICAgICAgIG51bWJlcnNbdmFsdWUubm9dID0gbjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWUsXG4gICAgICAgIHZhbHVlczogbm9ybWFsVmFsdWVzLFxuICAgICAgICAvLyBXZSBkbyBub3Qgc3VyZmFjZSBvcHRpb25zIGF0IHRoaXMgdGltZVxuICAgICAgICAvLyBvcHRpb25zOiBvcHQ/Lm9wdGlvbnMgPz8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgZmluZE5hbWUobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVzW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kTnVtYmVyKG5vKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyc1tub107XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGVudW0gb2JqZWN0IHdpdGggdGhlIGdpdmVuIHZhbHVlcy5cbiAqIFNldHMgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFbnVtKHR5cGVOYW1lLCB2YWx1ZXMsIG9wdCkge1xuICAgIGNvbnN0IGVudW1PYmplY3QgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICBjb25zdCBuID0gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKTtcbiAgICAgICAgZW51bU9iamVjdFtuLmxvY2FsTmFtZV0gPSBuLm5vO1xuICAgICAgICBlbnVtT2JqZWN0W24ubm9dID0gbi5sb2NhbE5hbWU7XG4gICAgfVxuICAgIHNldEVudW1UeXBlKGVudW1PYmplY3QsIHR5cGVOYW1lLCB2YWx1ZXMsIG9wdCk7XG4gICAgcmV0dXJuIGVudW1PYmplY3Q7XG59XG5mdW5jdGlvbiBub3JtYWxpemVFbnVtVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoXCJsb2NhbE5hbWVcIiBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKSwgeyBsb2NhbE5hbWU6IHZhbHVlLm5hbWUgfSk7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBNZXNzYWdlIGlzIHRoZSBiYXNlIGNsYXNzIG9mIGV2ZXJ5IG1lc3NhZ2UsIGdlbmVyYXRlZCwgb3IgY3JlYXRlZCBhdFxuICogcnVudGltZS5cbiAqXG4gKiBJdCBpcyBfbm90XyBzYWZlIHRvIGV4dGVuZCB0aGlzIGNsYXNzLiBJZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBtZXNzYWdlIGF0XG4gKiBydW4gdGltZSwgdXNlIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoKS5cbiAqL1xuZXhwb3J0IGNsYXNzIE1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIENvbXBhcmUgd2l0aCBhIG1lc3NhZ2Ugb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAgKi9cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpLnJ1bnRpbWUudXRpbC5lcXVhbHModGhpcy5nZXRUeXBlKCksIHRoaXMsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGVlcCBjb3B5LlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkucnVudGltZS51dGlsLmNsb25lKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBmcm9tIGJpbmFyeSBkYXRhLCBtZXJnaW5nIGZpZWxkcy5cbiAgICAgKlxuICAgICAqIFJlcGVhdGVkIGZpZWxkcyBhcmUgYXBwZW5kZWQuIE1hcCBlbnRyaWVzIGFyZSBhZGRlZCwgb3ZlcndyaXRpbmdcbiAgICAgKiBleGlzdGluZyBrZXlzLlxuICAgICAqXG4gICAgICogSWYgYSBtZXNzYWdlIGZpZWxkIGlzIGFscmVhZHkgcHJlc2VudCwgaXQgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcbiAgICAgKiBuZXcgZGF0YS5cbiAgICAgKi9cbiAgICBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSwgZm9ybWF0ID0gdHlwZS5ydW50aW1lLmJpbiwgb3B0ID0gZm9ybWF0Lm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgZm9ybWF0LnJlYWRNZXNzYWdlKHRoaXMsIG9wdC5yZWFkZXJGYWN0b3J5KGJ5dGVzKSwgYnl0ZXMuYnl0ZUxlbmd0aCwgb3B0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgbWVzc2FnZSBmcm9tIGEgSlNPTiB2YWx1ZS5cbiAgICAgKi9cbiAgICBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLCBmb3JtYXQgPSB0eXBlLnJ1bnRpbWUuanNvbiwgb3B0ID0gZm9ybWF0Lm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgZm9ybWF0LnJlYWRNZXNzYWdlKHR5cGUsIGpzb25WYWx1ZSwgb3B0LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgbWVzc2FnZSBmcm9tIGEgSlNPTiBzdHJpbmcuXG4gICAgICovXG4gICAgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICBsZXQganNvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgJHt0aGlzLmdldFR5cGUoKS50eXBlTmFtZX0gZnJvbSBKU09OOiAke2UgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tSnNvbihqc29uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIGJpbmFyeSBkYXRhLlxuICAgICAqL1xuICAgIHRvQmluYXJ5KG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLCBiaW4gPSB0eXBlLnJ1bnRpbWUuYmluLCBvcHQgPSBiaW4ubWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKSwgd3JpdGVyID0gb3B0LndyaXRlckZhY3RvcnkoKTtcbiAgICAgICAgYmluLndyaXRlTWVzc2FnZSh0aGlzLCB3cml0ZXIsIG9wdCk7XG4gICAgICAgIHJldHVybiB3cml0ZXIuZmluaXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBhIEpTT04gdmFsdWUsIGEgSmF2YVNjcmlwdCB2YWx1ZSB0aGF0IGNhbiBiZVxuICAgICAqIHBhc3NlZCB0byBKU09OLnN0cmluZ2lmeSgpLlxuICAgICAqL1xuICAgIHRvSnNvbihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSwganNvbiA9IHR5cGUucnVudGltZS5qc29uLCBvcHQgPSBqc29uLm1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBqc29uLndyaXRlTWVzc2FnZSh0aGlzLCBvcHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIG1lc3NhZ2UgdG8gYSBKU09OIHN0cmluZy5cbiAgICAgKi9cbiAgICB0b0pzb25TdHJpbmcob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy50b0pzb24ob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXR0eVNwYWNlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGZvciBzZXJpYWxpemF0aW9uIGJlaGF2aW9yLiBUaGlzIHdpbGwgYmUgaW52b2tlZCB3aGVuIGNhbGxpbmdcbiAgICAgKiBKU09OLnN0cmluZ2lmeSBvbiB0aGlzIG1lc3NhZ2UgKGkuZS4gSlNPTi5zdHJpbmdpZnkobXNnKSkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBzZXJpYWxpemUgZ29vZ2xlLnByb3RvYnVmLkFueSB3aXRoIGEgcGFja2VkXG4gICAgICogbWVzc2FnZSBiZWNhdXNlIHRoZSBwcm90b2J1ZiBKU09OIGZvcm1hdCBzcGVjaWZpZXMgdGhhdCBpdCBuZWVkcyB0byBiZVxuICAgICAqIHVucGFja2VkLCBhbmQgdGhpcyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggYSB0eXBlIHJlZ2lzdHJ5IHRvIGxvb2sgdXAgdGhlXG4gICAgICogbWVzc2FnZSB0eXBlLiAgQXMgYSByZXN1bHQsIGF0dGVtcHRpbmcgdG8gc2VyaWFsaXplIGEgbWVzc2FnZSB3aXRoIHRoaXNcbiAgICAgKiB0eXBlIHdpbGwgdGhyb3cgYW4gRXJyb3IuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBwcm90ZWN0ZWQgYmVjYXVzZSB5b3Ugc2hvdWxkIG5vdCBuZWVkIHRvIGludm9rZSBpdFxuICAgICAqIGRpcmVjdGx5IC0tIGluc3RlYWQgdXNlIEpTT04uc3RyaW5naWZ5IG9yIHRvSnNvblN0cmluZyBmb3JcbiAgICAgKiBzdHJpbmdpZmllZCBKU09OLiAgQWx0ZXJuYXRpdmVseSwgaWYgYWN0dWFsIEpTT04gaXMgZGVzaXJlZCwgeW91IHNob3VsZFxuICAgICAqIHVzZSB0b0pzb24uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0pzb24oe1xuICAgICAgICAgICAgZW1pdERlZmF1bHRWYWx1ZXM6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgTWVzc2FnZVR5cGUgb2YgdGhpcyBtZXNzYWdlIC0gYSBzaW5nbGV0b24gdGhhdCByZXByZXNlbnRzXG4gICAgICogdGhlIHByb3RvYnVmIG1lc3NhZ2UgZGVjbGFyYXRpb24gYW5kIHByb3ZpZGVzIG1ldGFkYXRhIGZvciByZWZsZWN0aW9uLVxuICAgICAqIGJhc2VkIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgLy8gQW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBNZXNzYWdlIF9tdXN0XyBwcm92aWRlIGEgY29tcGxldGUgc3RhdGljXG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIE1lc3NhZ2VUeXBlLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZS5qc1wiO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWVzc2FnZSB0eXBlIHVzaW5nIHRoZSBnaXZlbiBydW50aW1lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZU1lc3NhZ2VUeXBlKHJ1bnRpbWUsIHR5cGVOYW1lLCBmaWVsZHMsIG9wdCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2NhbE5hbWUgPSAoX2EgPSBvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQubG9jYWxOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0eXBlTmFtZS5zdWJzdHJpbmcodHlwZU5hbWUubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XG4gICAgY29uc3QgdHlwZSA9IHtcbiAgICAgICAgW2xvY2FsTmFtZV06IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBydW50aW1lLnV0aWwuaW5pdEZpZWxkcyh0aGlzKTtcbiAgICAgICAgICAgIHJ1bnRpbWUudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICAgICAgfSxcbiAgICB9W2xvY2FsTmFtZV07XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHR5cGUucHJvdG90eXBlLCBuZXcgTWVzc2FnZSgpKTtcbiAgICBPYmplY3QuYXNzaWduKHR5cGUsIHtcbiAgICAgICAgcnVudGltZSxcbiAgICAgICAgdHlwZU5hbWUsXG4gICAgICAgIGZpZWxkczogcnVudGltZS51dGlsLm5ld0ZpZWxkTGlzdChmaWVsZHMpLFxuICAgICAgICBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBydW50aW1lLnV0aWwuZXF1YWxzKHR5cGUsIGEsIGIpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiB0eXBlO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IGdldEVudW1UeXBlLCBtYWtlRW51bSwgbWFrZUVudW1UeXBlIH0gZnJvbSBcIi4vZW51bS5qc1wiO1xuaW1wb3J0IHsgbWFrZU1lc3NhZ2VUeXBlIH0gZnJvbSBcIi4vbWVzc2FnZS10eXBlLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gbWFrZVByb3RvUnVudGltZShzeW50YXgsIGpzb24sIGJpbiwgdXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN5bnRheCxcbiAgICAgICAganNvbixcbiAgICAgICAgYmluLFxuICAgICAgICB1dGlsLFxuICAgICAgICBtYWtlTWVzc2FnZVR5cGUodHlwZU5hbWUsIGZpZWxkcywgb3B0KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZU1lc3NhZ2VUeXBlKHRoaXMsIHR5cGVOYW1lLCBmaWVsZHMsIG9wdCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1ha2VFbnVtLFxuICAgICAgICBtYWtlRW51bVR5cGUsXG4gICAgICAgIGdldEVudW1UeXBlLFxuICAgIH07XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBTY2FsYXIgdmFsdWUgdHlwZXMuIFRoaXMgaXMgYSBzdWJzZXQgb2YgZmllbGQgdHlwZXMgZGVjbGFyZWQgYnkgcHJvdG9idWZcbiAqIGVudW0gZ29vZ2xlLnByb3RvYnVmLkZpZWxkRGVzY3JpcHRvclByb3RvLlR5cGUgVGhlIHR5cGVzIEdST1VQIGFuZCBNRVNTQUdFXG4gKiBhcmUgb21pdHRlZCwgYnV0IHRoZSBudW1lcmljYWwgdmFsdWVzIGFyZSBpZGVudGljYWwuXG4gKi9cbmV4cG9ydCB2YXIgU2NhbGFyVHlwZTtcbihmdW5jdGlvbiAoU2NhbGFyVHlwZSkge1xuICAgIC8vIDAgaXMgcmVzZXJ2ZWQgZm9yIGVycm9ycy5cbiAgICAvLyBPcmRlciBpcyB3ZWlyZCBmb3IgaGlzdG9yaWNhbCByZWFzb25zLlxuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkRPVUJMRVwiXSA9IDFdID0gXCJET1VCTEVcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGTE9BVFwiXSA9IDJdID0gXCJGTE9BVFwiO1xuICAgIC8vIE5vdCBaaWdaYWcgZW5jb2RlZC4gIE5lZ2F0aXZlIG51bWJlcnMgdGFrZSAxMCBieXRlcy4gIFVzZSBUWVBFX1NJTlQ2NCBpZlxuICAgIC8vIG5lZ2F0aXZlIHZhbHVlcyBhcmUgbGlrZWx5LlxuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIklOVDY0XCJdID0gM10gPSBcIklOVDY0XCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiVUlOVDY0XCJdID0gNF0gPSBcIlVJTlQ2NFwiO1xuICAgIC8vIE5vdCBaaWdaYWcgZW5jb2RlZC4gIE5lZ2F0aXZlIG51bWJlcnMgdGFrZSAxMCBieXRlcy4gIFVzZSBUWVBFX1NJTlQzMiBpZlxuICAgIC8vIG5lZ2F0aXZlIHZhbHVlcyBhcmUgbGlrZWx5LlxuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIklOVDMyXCJdID0gNV0gPSBcIklOVDMyXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRklYRUQ2NFwiXSA9IDZdID0gXCJGSVhFRDY0XCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRklYRUQzMlwiXSA9IDddID0gXCJGSVhFRDMyXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiQk9PTFwiXSA9IDhdID0gXCJCT09MXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU1RSSU5HXCJdID0gOV0gPSBcIlNUUklOR1wiO1xuICAgIC8vIFRhZy1kZWxpbWl0ZWQgYWdncmVnYXRlLlxuICAgIC8vIEdyb3VwIHR5cGUgaXMgZGVwcmVjYXRlZCBhbmQgbm90IHN1cHBvcnRlZCBpbiBwcm90bzMuIEhvd2V2ZXIsIFByb3RvM1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBzaG91bGQgc3RpbGwgYmUgYWJsZSB0byBwYXJzZSB0aGUgZ3JvdXAgd2lyZSBmb3JtYXQgYW5kXG4gICAgLy8gdHJlYXQgZ3JvdXAgZmllbGRzIGFzIHVua25vd24gZmllbGRzLlxuICAgIC8vIFRZUEVfR1JPVVAgPSAxMCxcbiAgICAvLyBUWVBFX01FU1NBR0UgPSAxMSwgIC8vIExlbmd0aC1kZWxpbWl0ZWQgYWdncmVnYXRlLlxuICAgIC8vIE5ldyBpbiB2ZXJzaW9uIDIuXG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiQllURVNcIl0gPSAxMl0gPSBcIkJZVEVTXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiVUlOVDMyXCJdID0gMTNdID0gXCJVSU5UMzJcIjtcbiAgICAvLyBUWVBFX0VOVU0gPSAxNCxcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTRklYRUQzMlwiXSA9IDE1XSA9IFwiU0ZJWEVEMzJcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTRklYRUQ2NFwiXSA9IDE2XSA9IFwiU0ZJWEVENjRcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTSU5UMzJcIl0gPSAxN10gPSBcIlNJTlQzMlwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNJTlQ2NFwiXSA9IDE4XSA9IFwiU0lOVDY0XCI7XG59KShTY2FsYXJUeXBlIHx8IChTY2FsYXJUeXBlID0ge30pKTtcbi8qKlxuICogSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiBmaWVsZHMgd2l0aCA2NCBiaXQgaW50ZWdyYWwgdHlwZXMgKGludDY0LCB1aW50NjQsXG4gKiBzaW50NjQsIGZpeGVkNjQsIHNmaXhlZDY0KS5cbiAqXG4gKiBUaGlzIGlzIGEgc3Vic2V0IG9mIGdvb2dsZS5wcm90b2J1Zi5GaWVsZE9wdGlvbnMuSlNUeXBlLCB3aGljaCBkZWZpbmVzIEpTX05PUk1BTCxcbiAqIEpTX1NUUklORywgYW5kIEpTX05VTUJFUi4gUHJvdG9idWYtRVMgdXNlcyBCaWdJbnQgYnkgZGVmYXVsdCwgYnV0IHdpbGwgdXNlXG4gKiBTdHJpbmcgaWYgYFtqc3R5cGUgPSBKU19TVFJJTkddYCBpcyBzcGVjaWZpZWQuXG4gKlxuICogYGBgcHJvdG9idWZcbiAqIHVpbnQ2NCBmaWVsZF9hID0gMTsgLy8gQmlnSW50XG4gKiB1aW50NjQgZmllbGRfYiA9IDIgW2pzdHlwZSA9IEpTX05PUk1BTF07IC8vIEJpZ0ludFxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19OVU1CRVJdOyAvLyBCaWdJbnRcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfU1RSSU5HXTsgLy8gU3RyaW5nXG4gKiBgYGBcbiAqL1xuZXhwb3J0IHZhciBMb25nVHlwZTtcbihmdW5jdGlvbiAoTG9uZ1R5cGUpIHtcbiAgICAvKipcbiAgICAgKiBVc2UgSmF2YVNjcmlwdCBCaWdJbnQuXG4gICAgICovXG4gICAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJCSUdJTlRcIl0gPSAwXSA9IFwiQklHSU5UXCI7XG4gICAgLyoqXG4gICAgICogVXNlIEphdmFTY3JpcHQgU3RyaW5nLlxuICAgICAqXG4gICAgICogRmllbGQgb3B0aW9uIGBbanN0eXBlID0gSlNfU1RSSU5HXWAuXG4gICAgICovXG4gICAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJTVFJJTkdcIl0gPSAxXSA9IFwiU1RSSU5HXCI7XG59KShMb25nVHlwZSB8fCAoTG9uZ1R5cGUgPSB7fSkpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgUHJvdG9jb2wgQnVmZmVyIGNvbXBpbGVyIGlzIG93bmVkIGJ5IHRoZSBvd25lclxuLy8gb2YgdGhlIGlucHV0IGZpbGUgdXNlZCB3aGVuIGdlbmVyYXRpbmcgaXQuICBUaGlzIGNvZGUgaXMgbm90XG4vLyBzdGFuZGFsb25lIGFuZCByZXF1aXJlcyBhIHN1cHBvcnQgbGlicmFyeSB0byBiZSBsaW5rZWQgd2l0aCBpdC4gIFRoaXNcbi8vIHN1cHBvcnQgbGlicmFyeSBpcyBpdHNlbGYgY292ZXJlZCBieSB0aGUgYWJvdmUgbGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xuLyoqXG4gKiBSZWFkIGEgNjQgYml0IHZhcmludCBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBSZXR1cm5zIHR1cGxlOlxuICogWzBdOiBsb3cgYml0c1xuICogWzFdOiBoaWdoIGJpdHNcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL2J1ZmZlcl9kZWNvZGVyLmpzI0wxNzVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhcmludDY0cmVhZCgpIHtcbiAgICBsZXQgbG93Qml0cyA9IDA7XG4gICAgbGV0IGhpZ2hCaXRzID0gMDtcbiAgICBmb3IgKGxldCBzaGlmdCA9IDA7IHNoaWZ0IDwgMjg7IHNoaWZ0ICs9IDcpIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICAgICAgbG93Qml0cyB8PSAoYiAmIDB4N2YpIDw8IHNoaWZ0O1xuICAgICAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1pZGRsZUJ5dGUgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICAvLyBsYXN0IGZvdXIgYml0cyBvZiB0aGUgZmlyc3QgMzIgYml0IG51bWJlclxuICAgIGxvd0JpdHMgfD0gKG1pZGRsZUJ5dGUgJiAweDBmKSA8PCAyODtcbiAgICAvLyAzIHVwcGVyIGJpdHMgYXJlIHBhcnQgb2YgdGhlIG5leHQgMzIgYml0IG51bWJlclxuICAgIGhpZ2hCaXRzID0gKG1pZGRsZUJ5dGUgJiAweDcwKSA+PiA0O1xuICAgIGlmICgobWlkZGxlQnl0ZSAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gICAgfVxuICAgIGZvciAobGV0IHNoaWZ0ID0gMzsgc2hpZnQgPD0gMzE7IHNoaWZ0ICs9IDcpIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICAgICAgaGlnaEJpdHMgfD0gKGIgJiAweDdmKSA8PCBzaGlmdDtcbiAgICAgICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xufVxuLyoqXG4gKiBXcml0ZSBhIDY0IGJpdCB2YXJpbnQsIGdpdmVuIGFzIHR3byBKUyBudW1iZXJzLCB0byB0aGUgZ2l2ZW4gYnl0ZXMgYXJyYXkuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC93cml0ZXIuanMjTDM0NFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFyaW50NjR3cml0ZShsbywgaGksIGJ5dGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyODsgaSA9IGkgKyA3KSB7XG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gbG8gPj4+IGk7XG4gICAgICAgIGNvbnN0IGhhc05leHQgPSAhKHNoaWZ0ID4+PiA3ID09IDAgJiYgaGkgPT0gMCk7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSAoaGFzTmV4dCA/IHNoaWZ0IHwgMHg4MCA6IHNoaWZ0KSAmIDB4ZmY7XG4gICAgICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgICAgIGlmICghaGFzTmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNwbGl0Qml0cyA9ICgobG8gPj4+IDI4KSAmIDB4MGYpIHwgKChoaSAmIDB4MDcpIDw8IDQpO1xuICAgIGNvbnN0IGhhc01vcmVCaXRzID0gIShoaSA+PiAzID09IDApO1xuICAgIGJ5dGVzLnB1c2goKGhhc01vcmVCaXRzID8gc3BsaXRCaXRzIHwgMHg4MCA6IHNwbGl0Qml0cykgJiAweGZmKTtcbiAgICBpZiAoIWhhc01vcmVCaXRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDM7IGkgPCAzMTsgaSA9IGkgKyA3KSB7XG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gaGkgPj4+IGk7XG4gICAgICAgIGNvbnN0IGhhc05leHQgPSAhKHNoaWZ0ID4+PiA3ID09IDApO1xuICAgICAgICBjb25zdCBieXRlID0gKGhhc05leHQgPyBzaGlmdCB8IDB4ODAgOiBzaGlmdCkgJiAweGZmO1xuICAgICAgICBieXRlcy5wdXNoKGJ5dGUpO1xuICAgICAgICBpZiAoIWhhc05leHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBieXRlcy5wdXNoKChoaSA+Pj4gMzEpICYgMHgwMSk7XG59XG4vLyBjb25zdGFudHMgZm9yIGJpbmFyeSBtYXRoXG5jb25zdCBUV09fUFdSXzMyX0RCTCA9IDB4MTAwMDAwMDAwO1xuLyoqXG4gKiBQYXJzZSBkZWNpbWFsIHN0cmluZyBvZiA2NCBiaXQgaW50ZWdlciB2YWx1ZSBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludDY0RnJvbVN0cmluZyhkZWMpIHtcbiAgICAvLyBDaGVjayBmb3IgbWludXMgc2lnbi5cbiAgICBjb25zdCBtaW51cyA9IGRlY1swXSA9PT0gXCItXCI7XG4gICAgaWYgKG1pbnVzKSB7XG4gICAgICAgIGRlYyA9IGRlYy5zbGljZSgxKTtcbiAgICB9XG4gICAgLy8gV29yayA2IGRlY2ltYWwgZGlnaXRzIGF0IGEgdGltZSwgYWN0aW5nIGxpa2Ugd2UncmUgY29udmVydGluZyBiYXNlIDFlNlxuICAgIC8vIGRpZ2l0cyB0byBiaW5hcnkuIFRoaXMgaXMgc2FmZSB0byBkbyB3aXRoIGZsb2F0aW5nIHBvaW50IG1hdGggYmVjYXVzZVxuICAgIC8vIE51bWJlci5pc1NhZmVJbnRlZ2VyKEFMTF8zMl9CSVRTICogMWU2KSA9PSB0cnVlLlxuICAgIGNvbnN0IGJhc2UgPSAxZTY7XG4gICAgbGV0IGxvd0JpdHMgPSAwO1xuICAgIGxldCBoaWdoQml0cyA9IDA7XG4gICAgZnVuY3Rpb24gYWRkMWU2ZGlnaXQoYmVnaW4sIGVuZCkge1xuICAgICAgICAvLyBOb3RlOiBOdW1iZXIoJycpIGlzIDAuXG4gICAgICAgIGNvbnN0IGRpZ2l0MWU2ID0gTnVtYmVyKGRlYy5zbGljZShiZWdpbiwgZW5kKSk7XG4gICAgICAgIGhpZ2hCaXRzICo9IGJhc2U7XG4gICAgICAgIGxvd0JpdHMgPSBsb3dCaXRzICogYmFzZSArIGRpZ2l0MWU2O1xuICAgICAgICAvLyBDYXJyeSBiaXRzIGZyb20gbG93Qml0cyB0b1xuICAgICAgICBpZiAobG93Qml0cyA+PSBUV09fUFdSXzMyX0RCTCkge1xuICAgICAgICAgICAgaGlnaEJpdHMgPSBoaWdoQml0cyArICgobG93Qml0cyAvIFRXT19QV1JfMzJfREJMKSB8IDApO1xuICAgICAgICAgICAgbG93Qml0cyA9IGxvd0JpdHMgJSBUV09fUFdSXzMyX0RCTDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGQxZTZkaWdpdCgtMjQsIC0xOCk7XG4gICAgYWRkMWU2ZGlnaXQoLTE4LCAtMTIpO1xuICAgIGFkZDFlNmRpZ2l0KC0xMiwgLTYpO1xuICAgIGFkZDFlNmRpZ2l0KC02KTtcbiAgICByZXR1cm4gbWludXMgPyBuZWdhdGUobG93Qml0cywgaGlnaEJpdHMpIDogbmV3Qml0cyhsb3dCaXRzLCBoaWdoQml0cyk7XG59XG4vKipcbiAqIExvc3NsZXNzbHkgY29udmVydHMgYSA2NC1iaXQgc2lnbmVkIGludGVnZXIgaW4gMzI6MzIgc3BsaXQgcmVwcmVzZW50YXRpb25cbiAqIGludG8gYSBkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludDY0VG9TdHJpbmcobG8sIGhpKSB7XG4gICAgbGV0IGJpdHMgPSBuZXdCaXRzKGxvLCBoaSk7XG4gICAgLy8gSWYgd2UncmUgdHJlYXRpbmcgdGhlIGlucHV0IGFzIGEgc2lnbmVkIHZhbHVlIGFuZCB0aGUgaGlnaCBiaXQgaXMgc2V0LCBkb1xuICAgIC8vIGEgbWFudWFsIHR3bydzIGNvbXBsZW1lbnQgY29udmVyc2lvbiBiZWZvcmUgdGhlIGRlY2ltYWwgY29udmVyc2lvbi5cbiAgICBjb25zdCBuZWdhdGl2ZSA9IChiaXRzLmhpICYgMHg4MDAwMDAwMCk7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIGJpdHMgPSBuZWdhdGUoYml0cy5sbywgYml0cy5oaSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHVJbnQ2NFRvU3RyaW5nKGJpdHMubG8sIGJpdHMuaGkpO1xuICAgIHJldHVybiBuZWdhdGl2ZSA/IFwiLVwiICsgcmVzdWx0IDogcmVzdWx0O1xufVxuLyoqXG4gKiBMb3NzbGVzc2x5IGNvbnZlcnRzIGEgNjQtYml0IHVuc2lnbmVkIGludGVnZXIgaW4gMzI6MzIgc3BsaXQgcmVwcmVzZW50YXRpb25cbiAqIGludG8gYSBkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSkge1xuICAgICh7IGxvLCBoaSB9ID0gdG9VbnNpZ25lZChsbywgaGkpKTtcbiAgICAvLyBTa2lwIHRoZSBleHBlbnNpdmUgY29udmVyc2lvbiBpZiB0aGUgbnVtYmVyIGlzIHNtYWxsIGVub3VnaCB0byB1c2UgdGhlXG4gICAgLy8gYnVpbHQtaW4gY29udmVyc2lvbnMuXG4gICAgLy8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgPSAweDAwMUZGRkZGIEZGRkZGRkZGLCB0aHVzIGFueSBudW1iZXIgd2l0aFxuICAgIC8vIGhpZ2hCaXRzIDw9IDB4MUZGRkZGIGNhbiBiZSBzYWZlbHkgZXhwcmVzc2VkIHdpdGggYSBkb3VibGUgYW5kIHJldGFpblxuICAgIC8vIGludGVnZXIgcHJlY2lzaW9uLlxuICAgIC8vIFByb3ZlbiBieTogTnVtYmVyLmlzU2FmZUludGVnZXIoMHgxRkZGRkYgKiAyKiozMiArIDB4RkZGRkZGRkYpID09IHRydWUuXG4gICAgaWYgKGhpIDw9IDB4MUZGRkZGKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoVFdPX1BXUl8zMl9EQkwgKiBoaSArIGxvKTtcbiAgICB9XG4gICAgLy8gV2hhdCB0aGlzIGNvZGUgaXMgZG9pbmcgaXMgZXNzZW50aWFsbHkgY29udmVydGluZyB0aGUgaW5wdXQgbnVtYmVyIGZyb21cbiAgICAvLyBiYXNlLTIgdG8gYmFzZS0xZTcsIHdoaWNoIGFsbG93cyB1cyB0byByZXByZXNlbnQgdGhlIDY0LWJpdCByYW5nZSB3aXRoXG4gICAgLy8gb25seSAzICh2ZXJ5IGxhcmdlKSBkaWdpdHMuIFRob3NlIGRpZ2l0cyBhcmUgdGhlbiB0cml2aWFsIHRvIGNvbnZlcnQgdG9cbiAgICAvLyBhIGJhc2UtMTAgc3RyaW5nLlxuICAgIC8vIFRoZSBtYWdpYyBudW1iZXJzIHVzZWQgaGVyZSBhcmUgLVxuICAgIC8vIDJeMjQgPSAxNjc3NzIxNiA9ICgxLDY3NzcyMTYpIGluIGJhc2UtMWU3LlxuICAgIC8vIDJeNDggPSAyODE0NzQ5NzY3MTA2NTYgPSAoMiw4MTQ3NDk3LDY3MTA2NTYpIGluIGJhc2UtMWU3LlxuICAgIC8vIFNwbGl0IDMyOjMyIHJlcHJlc2VudGF0aW9uIGludG8gMTY6MjQ6MjQgcmVwcmVzZW50YXRpb24gc28gb3VyXG4gICAgLy8gaW50ZXJtZWRpYXRlIGRpZ2l0cyBkb24ndCBvdmVyZmxvdy5cbiAgICBjb25zdCBsb3cgPSBsbyAmIDB4RkZGRkZGO1xuICAgIGNvbnN0IG1pZCA9ICgobG8gPj4+IDI0KSB8IChoaSA8PCA4KSkgJiAweEZGRkZGRjtcbiAgICBjb25zdCBoaWdoID0gKGhpID4+IDE2KSAmIDB4RkZGRjtcbiAgICAvLyBBc3NlbWJsZSBvdXIgdGhyZWUgYmFzZS0xZTcgZGlnaXRzLCBpZ25vcmluZyBjYXJyaWVzLiBUaGUgbWF4aW11bVxuICAgIC8vIHZhbHVlIGluIGEgZGlnaXQgYXQgdGhpcyBzdGVwIGlzIHJlcHJlc2VudGFibGUgYXMgYSA0OC1iaXQgaW50ZWdlciwgd2hpY2hcbiAgICAvLyBjYW4gYmUgc3RvcmVkIGluIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICBsZXQgZGlnaXRBID0gbG93ICsgKG1pZCAqIDY3NzcyMTYpICsgKGhpZ2ggKiA2NzEwNjU2KTtcbiAgICBsZXQgZGlnaXRCID0gbWlkICsgKGhpZ2ggKiA4MTQ3NDk3KTtcbiAgICBsZXQgZGlnaXRDID0gKGhpZ2ggKiAyKTtcbiAgICAvLyBBcHBseSBjYXJyaWVzIGZyb20gQSB0byBCIGFuZCBmcm9tIEIgdG8gQy5cbiAgICBjb25zdCBiYXNlID0gMTAwMDAwMDA7XG4gICAgaWYgKGRpZ2l0QSA+PSBiYXNlKSB7XG4gICAgICAgIGRpZ2l0QiArPSBNYXRoLmZsb29yKGRpZ2l0QSAvIGJhc2UpO1xuICAgICAgICBkaWdpdEEgJT0gYmFzZTtcbiAgICB9XG4gICAgaWYgKGRpZ2l0QiA+PSBiYXNlKSB7XG4gICAgICAgIGRpZ2l0QyArPSBNYXRoLmZsb29yKGRpZ2l0QiAvIGJhc2UpO1xuICAgICAgICBkaWdpdEIgJT0gYmFzZTtcbiAgICB9XG4gICAgLy8gSWYgZGlnaXRDIGlzIDAsIHRoZW4gd2Ugc2hvdWxkIGhhdmUgcmV0dXJuZWQgaW4gdGhlIHRyaXZpYWwgY29kZSBwYXRoXG4gICAgLy8gYXQgdGhlIHRvcCBmb3Igbm9uLXNhZmUgaW50ZWdlcnMuIEdpdmVuIHRoaXMsIHdlIGNhbiBhc3N1bWUgYm90aCBkaWdpdEJcbiAgICAvLyBhbmQgZGlnaXRBIG5lZWQgbGVhZGluZyB6ZXJvcy5cbiAgICByZXR1cm4gZGlnaXRDLnRvU3RyaW5nKCkgKyBkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MoZGlnaXRCKSArXG4gICAgICAgIGRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyhkaWdpdEEpO1xufVxuZnVuY3Rpb24gdG9VbnNpZ25lZChsbywgaGkpIHtcbiAgICByZXR1cm4geyBsbzogbG8gPj4+IDAsIGhpOiBoaSA+Pj4gMCB9O1xufVxuZnVuY3Rpb24gbmV3Qml0cyhsbywgaGkpIHtcbiAgICByZXR1cm4geyBsbzogbG8gfCAwLCBoaTogaGkgfCAwIH07XG59XG4vKipcbiAqIFJldHVybnMgdHdvJ3MgY29tcGxpbWVudCBuZWdhdGlvbiBvZiBpbnB1dC5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0JpdHdpc2VfT3BlcmF0b3JzI1NpZ25lZF8zMi1iaXRfaW50ZWdlcnNcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKGxvd0JpdHMsIGhpZ2hCaXRzKSB7XG4gICAgaGlnaEJpdHMgPSB+aGlnaEJpdHM7XG4gICAgaWYgKGxvd0JpdHMpIHtcbiAgICAgICAgbG93Qml0cyA9IH5sb3dCaXRzICsgMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIGxvd0JpdHMgaXMgMCwgdGhlbiBiaXR3aXNlLW5vdCBpcyAweEZGRkZGRkZGLFxuICAgICAgICAvLyBhZGRpbmcgMSB0byB0aGF0LCByZXN1bHRzIGluIDB4MTAwMDAwMDAwLCB3aGljaCBsZWF2ZXNcbiAgICAgICAgLy8gdGhlIGxvdyBiaXRzIDB4MCBhbmQgc2ltcGx5IGFkZHMgb25lIHRvIHRoZSBoaWdoIGJpdHMuXG4gICAgICAgIGhpZ2hCaXRzICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBuZXdCaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKTtcbn1cbi8qKlxuICogUmV0dXJucyBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGRpZ2l0MWU3IHdpdGggbGVhZGluZyB6ZXJvcy5cbiAqL1xuY29uc3QgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zID0gKGRpZ2l0MWU3KSA9PiB7XG4gICAgY29uc3QgcGFydGlhbCA9IFN0cmluZyhkaWdpdDFlNyk7XG4gICAgcmV0dXJuIFwiMDAwMDAwMFwiLnNsaWNlKHBhcnRpYWwubGVuZ3RoKSArIHBhcnRpYWw7XG59O1xuLyoqXG4gKiBXcml0ZSBhIDMyIGJpdCB2YXJpbnQsIHNpZ25lZCBvciB1bnNpZ25lZC4gU2FtZSBhcyBgdmFyaW50NjR3cml0ZSgwLCB2YWx1ZSwgYnl0ZXMpYFxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvMWIxODgzM2Y0ZjJhMmY2ODFmNGU0YTI1Y2RmM2IwYTQzMTE1ZWMyNi9qcy9iaW5hcnkvZW5jb2Rlci5qcyNMMTQ0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpbnQzMndyaXRlKHZhbHVlLCBieXRlcykge1xuICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgIC8vIHdyaXRlIHZhbHVlIGFzIHZhcmludCAzMlxuICAgICAgICB3aGlsZSAodmFsdWUgPiAweDdmKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKCh2YWx1ZSAmIDB4N2YpIHwgMHg4MCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goKHZhbHVlICYgMTI3KSB8IDEyOCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDc7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMucHVzaCgxKTtcbiAgICB9XG59XG4vKipcbiAqIFJlYWQgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL2J1ZmZlcl9kZWNvZGVyLmpzI0wyMjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhcmludDMycmVhZCgpIHtcbiAgICBsZXQgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIGxldCByZXN1bHQgPSBiICYgMHg3ZjtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCA3O1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDE0O1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDIxO1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRXh0cmFjdCBvbmx5IGxhc3QgNCBiaXRzXG4gICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIHJlc3VsdCB8PSAoYiAmIDB4MGYpIDw8IDI4O1xuICAgIGZvciAobGV0IHJlYWRCeXRlcyA9IDU7IChiICYgMHg4MCkgIT09IDAgJiYgcmVhZEJ5dGVzIDwgMTA7IHJlYWRCeXRlcysrKVxuICAgICAgICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgaWYgKChiICYgMHg4MCkgIT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YXJpbnRcIik7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAvLyBSZXN1bHQgY2FuIGhhdmUgMzIgYml0cywgY29udmVydCBpdCB0byB1bnNpZ25lZFxuICAgIHJldHVybiByZXN1bHQgPj4+IDA7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4vcHJpdmF0ZS9hc3NlcnQuanNcIjtcbmltcG9ydCB7IGludDY0RnJvbVN0cmluZywgaW50NjRUb1N0cmluZywgdUludDY0VG9TdHJpbmcsIH0gZnJvbSBcIi4vZ29vZ2xlL3ZhcmludC5qc1wiO1xuZnVuY3Rpb24gbWFrZUludDY0U3VwcG9ydCgpIHtcbiAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoOCkpO1xuICAgIC8vIG5vdGUgdGhhdCBTYWZhcmkgMTQgaW1wbGVtZW50cyBCaWdJbnQsIGJ1dCBub3QgdGhlIERhdGFWaWV3IG1ldGhvZHNcbiAgICBjb25zdCBvayA9IHR5cGVvZiBCaWdJbnQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZHYuZ2V0QmlnSW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZHYuZ2V0QmlnVWludDY0ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIGR2LnNldEJpZ0ludDY0ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIGR2LnNldEJpZ1VpbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICh0eXBlb2YgcHJvY2VzcyAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgcHJvY2Vzcy5lbnYgIT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuQlVGX0JJR0lOVF9ESVNBQkxFICE9PSBcIjFcIik7XG4gICAgaWYgKG9rKSB7XG4gICAgICAgIGNvbnN0IE1JTiA9IEJpZ0ludChcIi05MjIzMzcyMDM2ODU0Nzc1ODA4XCIpLCBNQVggPSBCaWdJbnQoXCI5MjIzMzcyMDM2ODU0Nzc1ODA3XCIpLCBVTUlOID0gQmlnSW50KFwiMFwiKSwgVU1BWCA9IEJpZ0ludChcIjE4NDQ2NzQ0MDczNzA5NTUxNjE1XCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgemVybzogQmlnSW50KDApLFxuICAgICAgICAgICAgc3VwcG9ydGVkOiB0cnVlLFxuICAgICAgICAgICAgcGFyc2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaSA9IHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiID8gdmFsdWUgOiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChiaSA+IE1BWCB8fCBiaSA8IE1JTikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludDY0IGludmFsaWQ6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiaTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1UGFyc2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaSA9IHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiID8gdmFsdWUgOiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChiaSA+IFVNQVggfHwgYmkgPCBVTUlOKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdWludDY0IGludmFsaWQ6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiaTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkdi5zZXRCaWdJbnQ2NCgwLCB0aGlzLnBhcnNlKHZhbHVlKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbG86IGR2LmdldEludDMyKDAsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICBoaTogZHYuZ2V0SW50MzIoNCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1RW5jKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZHYuc2V0QmlnSW50NjQoMCwgdGhpcy51UGFyc2UodmFsdWUpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBsbzogZHYuZ2V0SW50MzIoMCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIGhpOiBkdi5nZXRJbnQzMig0LCB0cnVlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYyhsbywgaGkpIHtcbiAgICAgICAgICAgICAgICBkdi5zZXRJbnQzMigwLCBsbywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZHYuc2V0SW50MzIoNCwgaGksIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkdi5nZXRCaWdJbnQ2NCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1RGVjKGxvLCBoaSkge1xuICAgICAgICAgICAgICAgIGR2LnNldEludDMyKDAsIGxvLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkdi5zZXRJbnQzMig0LCBoaSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGR2LmdldEJpZ1VpbnQ2NCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGFzc2VydEludDY0U3RyaW5nID0gKHZhbHVlKSA9PiBhc3NlcnQoL14tP1swLTldKyQvLnRlc3QodmFsdWUpLCBgaW50NjQgaW52YWxpZDogJHt2YWx1ZX1gKTtcbiAgICBjb25zdCBhc3NlcnRVSW50NjRTdHJpbmcgPSAodmFsdWUpID0+IGFzc2VydCgvXlswLTldKyQvLnRlc3QodmFsdWUpLCBgdWludDY0IGludmFsaWQ6ICR7dmFsdWV9YCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgemVybzogXCIwXCIsXG4gICAgICAgIHN1cHBvcnRlZDogZmFsc2UsXG4gICAgICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHVQYXJzZSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0VUludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5jKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gaW50NjRGcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdUVuYyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0VUludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBpbnQ2NEZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBkZWMobG8sIGhpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50NjRUb1N0cmluZyhsbywgaGkpO1xuICAgICAgICB9LFxuICAgICAgICB1RGVjKGxvLCBoaSkge1xuICAgICAgICAgICAgcmV0dXJuIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBwcm90b0ludDY0ID0gbWFrZUludDY0U3VwcG9ydCgpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IHZhcmludDMycmVhZCwgdmFyaW50MzJ3cml0ZSwgdmFyaW50NjRyZWFkLCB2YXJpbnQ2NHdyaXRlLCB9IGZyb20gXCIuL2dvb2dsZS92YXJpbnQuanNcIjtcbmltcG9ydCB7IGFzc2VydEZsb2F0MzIsIGFzc2VydEludDMyLCBhc3NlcnRVSW50MzIgfSBmcm9tIFwiLi9wcml2YXRlL2Fzc2VydC5qc1wiO1xuaW1wb3J0IHsgcHJvdG9JbnQ2NCB9IGZyb20gXCIuL3Byb3RvLWludDY0LmpzXCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItY29uc3Qsbm8tY2FzZS1kZWNsYXJhdGlvbnMsQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgKi9cbi8qKlxuICogUHJvdG9idWYgYmluYXJ5IGZvcm1hdCB3aXJlIHR5cGVzLlxuICpcbiAqIEEgd2lyZSB0eXBlIHByb3ZpZGVzIGp1c3QgZW5vdWdoIGluZm9ybWF0aW9uIHRvIGZpbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAqIGZvbGxvd2luZyB2YWx1ZS5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL2VuY29kaW5nI3N0cnVjdHVyZVxuICovXG5leHBvcnQgdmFyIFdpcmVUeXBlO1xuKGZ1bmN0aW9uIChXaXJlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGludDMyLCBpbnQ2NCwgdWludDMyLCB1aW50NjQsIHNpbnQzMiwgc2ludDY0LCBib29sLCBlbnVtXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJWYXJpbnRcIl0gPSAwXSA9IFwiVmFyaW50XCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgZml4ZWQ2NCwgc2ZpeGVkNjQsIGRvdWJsZS5cbiAgICAgKiBBbHdheXMgOCBieXRlcyB3aXRoIGxpdHRsZS1lbmRpYW4gYnl0ZSBvcmRlci5cbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIkJpdDY0XCJdID0gMV0gPSBcIkJpdDY0XCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3Igc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcbiAgICAgKlxuICAgICAqIE9ubHkgcmVwZWF0ZWQgbnVtZXJpYyB0eXBlcyAodHlwZXMgd2hpY2ggdXNlIHRoZSB2YXJpbnQsIDMyLWJpdCxcbiAgICAgKiBvciA2NC1iaXQgd2lyZSB0eXBlcykgY2FuIGJlIHBhY2tlZC4gSW4gcHJvdG8zLCBzdWNoIGZpZWxkcyBhcmVcbiAgICAgKiBwYWNrZWQgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIkxlbmd0aERlbGltaXRlZFwiXSA9IDJdID0gXCJMZW5ndGhEZWxpbWl0ZWRcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBncm91cHNcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiU3RhcnRHcm91cFwiXSA9IDNdID0gXCJTdGFydEdyb3VwXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgZ3JvdXBzXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIkVuZEdyb3VwXCJdID0gNF0gPSBcIkVuZEdyb3VwXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgZml4ZWQzMiwgc2ZpeGVkMzIsIGZsb2F0LlxuICAgICAqIEFsd2F5cyA0IGJ5dGVzIHdpdGggbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiQml0MzJcIl0gPSA1XSA9IFwiQml0MzJcIjtcbn0pKFdpcmVUeXBlIHx8IChXaXJlVHlwZSA9IHt9KSk7XG5leHBvcnQgY2xhc3MgQmluYXJ5V3JpdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0RW5jb2Rlcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJldmlvdXMgZm9yayBzdGF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIHRoaXMudGV4dEVuY29kZXIgPSB0ZXh0RW5jb2RlciAhPT0gbnVsbCAmJiB0ZXh0RW5jb2RlciAhPT0gdm9pZCAwID8gdGV4dEVuY29kZXIgOiBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5idWYgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFsbCBieXRlcyB3cml0dGVuIGFuZCByZXNldCB0aGlzIHdyaXRlci5cbiAgICAgKi9cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IFVpbnQ4QXJyYXkodGhpcy5idWYpKTsgLy8gZmx1c2ggdGhlIGJ1ZmZlclxuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGxlbiArPSB0aGlzLmNodW5rc1tpXS5sZW5ndGg7XG4gICAgICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBieXRlcy5zZXQodGhpcy5jaHVua3NbaV0sIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdGhpcy5jaHVua3NbaV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgYSBuZXcgZm9yayBmb3IgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGxpa2UgYSBtZXNzYWdlXG4gICAgICogb3IgYSBwYWNrZWQgcmVwZWF0ZWQgZmllbGQuXG4gICAgICpcbiAgICAgKiBNdXN0IGJlIGpvaW5lZCBsYXRlciB3aXRoIGBqb2luKClgLlxuICAgICAqL1xuICAgIGZvcmsoKSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh7IGNodW5rczogdGhpcy5jaHVua3MsIGJ1ZjogdGhpcy5idWYgfSk7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuYnVmID0gW107XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBKb2luIHRoZSBsYXN0IGZvcmsuIFdyaXRlIGl0cyBsZW5ndGggYW5kIGJ5dGVzLCB0aGVuXG4gICAgICogcmV0dXJuIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgICAgKi9cbiAgICBqb2luKCkge1xuICAgICAgICAvLyBnZXQgY2h1bmsgb2YgZm9ya1xuICAgICAgICBsZXQgY2h1bmsgPSB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAvLyByZXN0b3JlIHByZXZpb3VzIHN0YXRlXG4gICAgICAgIGxldCBwcmV2ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFwcmV2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzdGF0ZSwgZm9yayBzdGFjayBlbXB0eVwiKTtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBwcmV2LmNodW5rcztcbiAgICAgICAgdGhpcy5idWYgPSBwcmV2LmJ1ZjtcbiAgICAgICAgLy8gd3JpdGUgbGVuZ3RoIG9mIGNodW5rIGFzIHZhcmludFxuICAgICAgICB0aGlzLnVpbnQzMihjaHVuay5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgdGFnIChmaWVsZCBudW1iZXIgYW5kIHdpcmUgdHlwZSkuXG4gICAgICpcbiAgICAgKiBFcXVpdmFsZW50IHRvIGB1aW50MzIoIChmaWVsZE5vIDw8IDMgfCB0eXBlKSA+Pj4gMCApYC5cbiAgICAgKlxuICAgICAqIEdlbmVyYXRlZCBjb2RlIHNob3VsZCBjb21wdXRlIHRoZSB0YWcgYWhlYWQgb2YgdGltZSBhbmQgY2FsbCBgdWludDMyKClgLlxuICAgICAqL1xuICAgIHRhZyhmaWVsZE5vLCB0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQzMigoKGZpZWxkTm8gPDwgMykgfCB0eXBlKSA+Pj4gMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgY2h1bmsgb2YgcmF3IGJ5dGVzLlxuICAgICAqL1xuICAgIHJhdyhjaHVuaykge1xuICAgICAgICBpZiAodGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmKSk7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgdWludDMyYCB2YWx1ZSwgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cbiAgICAgKi9cbiAgICB1aW50MzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0VUludDMyKHZhbHVlKTtcbiAgICAgICAgLy8gd3JpdGUgdmFsdWUgYXMgdmFyaW50IDMyLCBpbmxpbmVkIGZvciBzcGVlZFxuICAgICAgICB3aGlsZSAodmFsdWUgPiAweDdmKSB7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5wdXNoKCh2YWx1ZSAmIDB4N2YpIHwgMHg4MCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgaW50MzJgIHZhbHVlLCBhIHNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAqL1xuICAgIGludDMyKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEludDMyKHZhbHVlKTtcbiAgICAgICAgdmFyaW50MzJ3cml0ZSh2YWx1ZSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgYm9vbGAgdmFsdWUsIGEgdmFyaWFudC5cbiAgICAgKi9cbiAgICBib29sKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnVmLnB1c2godmFsdWUgPyAxIDogMCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBieXRlc2AgdmFsdWUsIGxlbmd0aC1kZWxpbWl0ZWQgYXJiaXRyYXJ5IGRhdGEuXG4gICAgICovXG4gICAgYnl0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy51aW50MzIodmFsdWUuYnl0ZUxlbmd0aCk7IC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgc3RyaW5nYCB2YWx1ZSwgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGNvbnZlcnRlZCB0byBVVEYtOCB0ZXh0LlxuICAgICAqL1xuICAgIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2h1bmsgPSB0aGlzLnRleHRFbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMudWludDMyKGNodW5rLmJ5dGVMZW5ndGgpOyAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGZsb2F0YCB2YWx1ZSwgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBmbG9hdCh2YWx1ZSkge1xuICAgICAgICBhc3NlcnRGbG9hdDMyKHZhbHVlKTtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEZsb2F0MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBkb3VibGVgIHZhbHVlLCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAgICovXG4gICAgZG91YmxlKHZhbHVlKSB7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRGbG9hdDY0KDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgZml4ZWQzMmAgdmFsdWUsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgZml4ZWQzMih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0VWludDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgc2ZpeGVkMzJgIHZhbHVlLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHNmaXhlZDMyKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEludDMyKHZhbHVlKTtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEludDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgc2ludDMyYCB2YWx1ZSwgYSBzaWduZWQsIHppZ3phZy1lbmNvZGVkIDMyLWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgc2ludDMyKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEludDMyKHZhbHVlKTtcbiAgICAgICAgLy8gemlnemFnIGVuY29kZVxuICAgICAgICB2YWx1ZSA9ICgodmFsdWUgPDwgMSkgXiAodmFsdWUgPj4gMzEpKSA+Pj4gMDtcbiAgICAgICAgdmFyaW50MzJ3cml0ZSh2YWx1ZSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgZml4ZWQ2NGAgdmFsdWUsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQtYml0IGludGVnZXIuXG4gICAgICovXG4gICAgc2ZpeGVkNjQodmFsdWUpIHtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCksIHZpZXcgPSBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKSwgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGMubG8sIHRydWUpO1xuICAgICAgICB2aWV3LnNldEludDMyKDQsIHRjLmhpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgZml4ZWQ2NGAgdmFsdWUsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQgYml0IGludGVnZXIuXG4gICAgICovXG4gICAgZml4ZWQ2NCh2YWx1ZSkge1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg4KSwgdmlldyA9IG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLCB0YyA9IHByb3RvSW50NjQudUVuYyh2YWx1ZSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGMubG8sIHRydWUpO1xuICAgICAgICB2aWV3LnNldEludDMyKDQsIHRjLmhpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgaW50NjRgIHZhbHVlLCBhIHNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIGludDY0KHZhbHVlKSB7XG4gICAgICAgIGxldCB0YyA9IHByb3RvSW50NjQuZW5jKHZhbHVlKTtcbiAgICAgICAgdmFyaW50NjR3cml0ZSh0Yy5sbywgdGMuaGksIHRoaXMuYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYHNpbnQ2NGAgdmFsdWUsIGEgc2lnbmVkLCB6aWctemFnLWVuY29kZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50NjQodmFsdWUpIHtcbiAgICAgICAgbGV0IHRjID0gcHJvdG9JbnQ2NC5lbmModmFsdWUpLCBcbiAgICAgICAgLy8gemlnemFnIGVuY29kZVxuICAgICAgICBzaWduID0gdGMuaGkgPj4gMzEsIGxvID0gKHRjLmxvIDw8IDEpIF4gc2lnbiwgaGkgPSAoKHRjLmhpIDw8IDEpIHwgKHRjLmxvID4+PiAzMSkpIF4gc2lnbjtcbiAgICAgICAgdmFyaW50NjR3cml0ZShsbywgaGksIHRoaXMuYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYHVpbnQ2NGAgdmFsdWUsIGFuIHVuc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgdWludDY0KHZhbHVlKSB7XG4gICAgICAgIGxldCB0YyA9IHByb3RvSW50NjQudUVuYyh2YWx1ZSk7XG4gICAgICAgIHZhcmludDY0d3JpdGUodGMubG8sIHRjLmhpLCB0aGlzLmJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCaW5hcnlSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGJ1ZiwgdGV4dERlY29kZXIpIHtcbiAgICAgICAgdGhpcy52YXJpbnQ2NCA9IHZhcmludDY0cmVhZDsgLy8gZGlydHkgY2FzdCBmb3IgYHRoaXNgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIGEgYHVpbnQzMmAgZmllbGQsIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVpbnQzMiA9IHZhcmludDMycmVhZDsgLy8gZGlydHkgY2FzdCBmb3IgYHRoaXNgIGFuZCBhY2Nlc3MgdG8gcHJvdGVjdGVkIGBidWZgXG4gICAgICAgIHRoaXMuYnVmID0gYnVmO1xuICAgICAgICB0aGlzLmxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMudGV4dERlY29kZXIgPSB0ZXh0RGVjb2RlciAhPT0gbnVsbCAmJiB0ZXh0RGVjb2RlciAhPT0gdm9pZCAwID8gdGV4dERlY29kZXIgOiBuZXcgVGV4dERlY29kZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSB0YWcgLSBmaWVsZCBudW1iZXIgYW5kIHdpcmUgdHlwZS5cbiAgICAgKi9cbiAgICB0YWcoKSB7XG4gICAgICAgIGxldCB0YWcgPSB0aGlzLnVpbnQzMigpLCBmaWVsZE5vID0gdGFnID4+PiAzLCB3aXJlVHlwZSA9IHRhZyAmIDc7XG4gICAgICAgIGlmIChmaWVsZE5vIDw9IDAgfHwgd2lyZVR5cGUgPCAwIHx8IHdpcmVUeXBlID4gNSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdGFnOiBmaWVsZCBubyBcIiArIGZpZWxkTm8gKyBcIiB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSk7XG4gICAgICAgIHJldHVybiBbZmllbGRObywgd2lyZVR5cGVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTa2lwIG9uZSBlbGVtZW50IG9uIHRoZSB3aXJlIGFuZCByZXR1cm4gdGhlIHNraXBwZWQgZGF0YS5cbiAgICAgKiBTdXBwb3J0cyBXaXJlVHlwZS5TdGFydEdyb3VwIHNpbmNlIHYyLjAuMC1hbHBoYS4yMy5cbiAgICAgKi9cbiAgICBza2lwKHdpcmVUeXBlKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLlZhcmludDpcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLkJpdDY0OlxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5CaXQzMjpcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ6XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMudWludDMyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gbGVuO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5TdGFydEdyb3VwOlxuICAgICAgICAgICAgICAgIC8vIEZyb20gZGVzY3JpcHRvci5wcm90bzogR3JvdXAgdHlwZSBpcyBkZXByZWNhdGVkLCBub3Qgc3VwcG9ydGVkIGluIHByb3RvMy5cbiAgICAgICAgICAgICAgICAvLyBCdXQgd2UgbXVzdCBzdGlsbCBiZSBhYmxlIHRvIHBhcnNlIGFuZCB0cmVhdCBhcyB1bmtub3duLlxuICAgICAgICAgICAgICAgIGxldCB0O1xuICAgICAgICAgICAgICAgIHdoaWxlICgodCA9IHRoaXMudGFnKClbMV0pICE9PSBXaXJlVHlwZS5FbmRHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNraXAodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW50IHNraXAgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheShzdGFydCwgdGhpcy5wb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaHJvd3MgZXJyb3IgaWYgcG9zaXRpb24gaW4gYnl0ZSBhcnJheSBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICovXG4gICAgYXNzZXJ0Qm91bmRzKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwicHJlbWF0dXJlIEVPRlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBpbnQzMmAgZmllbGQsIGEgc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgaW50MzIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBzaW50MzJgIGZpZWxkLCBhIHNpZ25lZCwgemlnemFnLWVuY29kZWQgMzItYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50MzIoKSB7XG4gICAgICAgIGxldCB6emUgPSB0aGlzLnVpbnQzMigpO1xuICAgICAgICAvLyBkZWNvZGUgemlnemFnXG4gICAgICAgIHJldHVybiAoenplID4+PiAxKSBeIC0oenplICYgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgaW50NjRgIGZpZWxkLCBhIHNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIGludDY0KCkge1xuICAgICAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWMoLi4udGhpcy52YXJpbnQ2NCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGB1aW50NjRgIGZpZWxkLCBhbiB1bnNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHVpbnQ2NCgpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvSW50NjQudURlYyguLi50aGlzLnZhcmludDY0KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHNpbnQ2NGAgZmllbGQsIGEgc2lnbmVkLCB6aWctemFnLWVuY29kZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50NjQoKSB7XG4gICAgICAgIGxldCBbbG8sIGhpXSA9IHRoaXMudmFyaW50NjQoKTtcbiAgICAgICAgLy8gZGVjb2RlIHppZyB6YWdcbiAgICAgICAgbGV0IHMgPSAtKGxvICYgMSk7XG4gICAgICAgIGxvID0gKChsbyA+Pj4gMSkgfCAoKGhpICYgMSkgPDwgMzEpKSBeIHM7XG4gICAgICAgIGhpID0gKGhpID4+PiAxKSBeIHM7XG4gICAgICAgIHJldHVybiBwcm90b0ludDY0LmRlYyhsbywgaGkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGJvb2xgIGZpZWxkLCBhIHZhcmlhbnQuXG4gICAgICovXG4gICAgYm9vbCgpIHtcbiAgICAgICAgbGV0IFtsbywgaGldID0gdGhpcy52YXJpbnQ2NCgpO1xuICAgICAgICByZXR1cm4gbG8gIT09IDAgfHwgaGkgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgZml4ZWQzMmAgZmllbGQsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgZml4ZWQzMigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRVaW50MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgc2ZpeGVkMzJgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHNmaXhlZDMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldEludDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZpeGVkNjRgIGZpZWxkLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0IGJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGZpeGVkNjQoKSB7XG4gICAgICAgIHJldHVybiBwcm90b0ludDY0LnVEZWModGhpcy5zZml4ZWQzMigpLCB0aGlzLnNmaXhlZDMyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZpeGVkNjRgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0LWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHNmaXhlZDY0KCkge1xuICAgICAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWModGhpcy5zZml4ZWQzMigpLCB0aGlzLnNmaXhlZDMyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZsb2F0YCBmaWVsZCwgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBmbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRGbG9hdDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGRvdWJsZWAgZmllbGQsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCgodGhpcy5wb3MgKz0gOCkgLSA4LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBieXRlc2AgZmllbGQsIGxlbmd0aC1kZWxpbWl0ZWQgYXJiaXRyYXJ5IGRhdGEuXG4gICAgICovXG4gICAgYnl0ZXMoKSB7XG4gICAgICAgIGxldCBsZW4gPSB0aGlzLnVpbnQzMigpLCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHN0cmluZ2AgZmllbGQsIGxlbmd0aC1kZWxpbWl0ZWQgZGF0YSBjb252ZXJ0ZWQgdG8gVVRGLTggdGV4dC5cbiAgICAgKi9cbiAgICBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHREZWNvZGVyLmRlY29kZSh0aGlzLmJ5dGVzKCkpO1xuICAgIH1cbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBNZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2UuanNcIjtcbmltcG9ydCB7IFNjYWxhclR5cGUgfSBmcm9tIFwiLi4vZmllbGQuanNcIjtcbi8qKlxuICogV3JhcCBhIHByaW1pdGl2ZSBtZXNzYWdlIGZpZWxkIHZhbHVlIGluIGl0cyBjb3JyZXNwb25kaW5nIHdyYXBwZXJcbiAqIG1lc3NhZ2UuIFRoaXMgZnVuY3Rpb24gaXMgaWRlbXBvdGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBGaWVsZCh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1lc3NhZ2UgfHwgIXR5cGUuZmllbGRXcmFwcGVyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGUuZmllbGRXcmFwcGVyLndyYXBGaWVsZCh2YWx1ZSk7XG59XG4vKipcbiAqIElmIHRoZSBnaXZlbiBmaWVsZCB1c2VzIG9uZSBvZiB0aGUgd2VsbC1rbm93biB3cmFwcGVyIHR5cGVzLCByZXR1cm5cbiAqIHRoZSBwcmltaXRpdmUgdHlwZSBpdCB3cmFwcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVud3JhcHBlZEZpZWxkVHlwZShmaWVsZCkge1xuICAgIGlmIChmaWVsZC5maWVsZEtpbmQgIT09IFwibWVzc2FnZVwiKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoZmllbGQub25lb2YgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB3a3RXcmFwcGVyVG9TY2FsYXJUeXBlW2ZpZWxkLm1lc3NhZ2UudHlwZU5hbWVdO1xufVxuY29uc3Qgd2t0V3JhcHBlclRvU2NhbGFyVHlwZSA9IHtcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5Eb3VibGVWYWx1ZVwiOiBTY2FsYXJUeXBlLkRPVUJMRSxcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5GbG9hdFZhbHVlXCI6IFNjYWxhclR5cGUuRkxPQVQsXG4gICAgXCJnb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZVwiOiBTY2FsYXJUeXBlLklOVDY0LFxuICAgIFwiZ29vZ2xlLnByb3RvYnVmLlVJbnQ2NFZhbHVlXCI6IFNjYWxhclR5cGUuVUlOVDY0LFxuICAgIFwiZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWVcIjogU2NhbGFyVHlwZS5JTlQzMixcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZVwiOiBTY2FsYXJUeXBlLlVJTlQzMixcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWVcIjogU2NhbGFyVHlwZS5CT09MLFxuICAgIFwiZ29vZ2xlLnByb3RvYnVmLlN0cmluZ1ZhbHVlXCI6IFNjYWxhclR5cGUuU1RSSU5HLFxuICAgIFwiZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWVcIjogU2NhbGFyVHlwZS5CWVRFUyxcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgTG9uZ1R5cGUsIFNjYWxhclR5cGUgfSBmcm9tIFwiLi4vZmllbGQuanNcIjtcbmltcG9ydCB7IFdpcmVUeXBlIH0gZnJvbSBcIi4uL2JpbmFyeS1lbmNvZGluZy5qc1wiO1xuaW1wb3J0IHsgcHJvdG9JbnQ2NCB9IGZyb20gXCIuLi9wcm90by1pbnQ2NC5qc1wiO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYm90aCBzY2FsYXIgdmFsdWVzIGFyZSBlcXVhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxhckVxdWFscyh0eXBlLCBhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgLy8gVGhpcyBjb3JyZWN0bHkgbWF0Y2hlcyBlcXVhbCB2YWx1ZXMgZXhjZXB0IEJZVEVTIGFuZCAocG9zc2libHkpIDY0LWJpdCBpbnRlZ2Vycy5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFNwZWNpYWwgY2FzZSBCWVRFUyAtIHdlIG5lZWQgdG8gY29tcGFyZSBlYWNoIGJ5dGUgaW5kaXZpZHVhbGx5XG4gICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgICAgICBpZiAoIShhIGluc3RhbmNlb2YgVWludDhBcnJheSkgfHwgIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gU3BlY2lhbCBjYXNlIDY0LWJpdCBpbnRlZ2VycyAtIHdlIHN1cHBvcnQgbnVtYmVyLCBzdHJpbmcgYW5kIGJpZ2ludCByZXByZXNlbnRhdGlvbi5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVja1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICAvLyBMb29zZSBjb21wYXJpc29uIHdpbGwgbWF0Y2ggYmV0d2VlbiAwbiwgMCBhbmQgXCIwXCIuXG4gICAgICAgICAgICByZXR1cm4gYSA9PSBiO1xuICAgIH1cbiAgICAvLyBBbnl0aGluZyB0aGF0IGhhc24ndCBiZWVuIGNhdWdodCBieSBzdHJpY3QgY29tcGFyaXNvbiBvciBzcGVjaWFsIGNhc2VkXG4gICAgLy8gQllURVMgYW5kIDY0LWJpdCBpbnRlZ2VycyBpcyBub3QgZXF1YWwuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgZ2l2ZW4gc2NhbGFyIHR5cGUsIGZvbGxvd2luZ1xuICogcHJvdG8zIHNlbWFudGljcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxhckRlZmF1bHRWYWx1ZSh0eXBlLCBsb25nVHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uIC0tIGFjY2VwdGFibGUgc2luY2UgaXQncyBjb3ZlcmVkIGJ5IHRlc3RzXG4gICAgICAgICAgICByZXR1cm4gbG9uZ1R5cGUgPT0gMCA/IHByb3RvSW50NjQuemVybyA6IFwiMFwiO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIEhhbmRsZXMgSU5UMzIsIFVJTlQzMiwgU0lOVDMyLCBGSVhFRDMyLCBTRklYRUQzMi5cbiAgICAgICAgICAgIC8vIFdlIGRvIG5vdCB1c2UgaW5kaXZpZHVhbCBjYXNlcyB0byBzYXZlIGEgZmV3IGJ5dGVzIGNvZGUgc2l6ZS5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbi8qKlxuICogR2V0IGluZm9ybWF0aW9uIGZvciB3cml0aW5nIGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIFJldHVybnMgdHVwbGU6XG4gKiBbMF06IGFwcHJvcHJpYXRlIFdpcmVUeXBlXG4gKiBbMV06IG5hbWUgb2YgdGhlIGFwcHJvcHJpYXRlIG1ldGhvZCBvZiBJQmluYXJ5V3JpdGVyXG4gKiBbMl06IHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvdG8zIHNlbWFudGljc1xuICpcbiAqIElmIGFyZ3VtZW50IGB2YWx1ZWAgaXMgb21pdHRlZCwgWzJdIGlzIGFsd2F5cyBmYWxzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxhclR5cGVJbmZvKHR5cGUsIHZhbHVlKSB7XG4gICAgY29uc3QgaXNVbmRlZmluZWQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIGxldCB3aXJlVHlwZSA9IFdpcmVUeXBlLlZhcmludDtcbiAgICBsZXQgaXNJbnRyaW5zaWNEZWZhdWx0ID0gdmFsdWUgPT09IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gSU5UMzIsIFVJTlQzMiwgU0lOVDMyIGFyZSBjb3ZlcmVkIGJ5IHRoZSBkZWZhdWx0c1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgaXNJbnRyaW5zaWNEZWZhdWx0ID0gaXNVbmRlZmluZWQgfHwgIXZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgaXNJbnRyaW5zaWNEZWZhdWx0ID0gdmFsdWUgPT09IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICAgICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDY0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgICAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuQml0MzI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICAgICAgaXNJbnRyaW5zaWNEZWZhdWx0ID0gaXNVbmRlZmluZWQgfHwgdmFsdWUgPT0gMDsgLy8gTG9vc2UgY29tcGFyaXNvbiBtYXRjaGVzIDBuLCAwIGFuZCBcIjBcIlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCB2YWx1ZSA9PSAwOyAvLyBMb29zZSBjb21wYXJpc29uIG1hdGNoZXMgMG4sIDAgYW5kIFwiMFwiXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICAgICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCB2YWx1ZSA9PSAwOyAvLyBMb29zZSBjb21wYXJpc29uIG1hdGNoZXMgMG4sIDAgYW5kIFwiMFwiXG4gICAgICAgICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDY0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgICAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8ICF2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICAgICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDMyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICAgICAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuQml0MzI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICAgICAgaXNJbnRyaW5zaWNEZWZhdWx0ID0gaXNVbmRlZmluZWQgfHwgdmFsdWUgPT0gMDtcbiAgICAgICAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuQml0NjQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgICAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gU2NhbGFyVHlwZVt0eXBlXS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBbd2lyZVR5cGUsIG1ldGhvZCwgaXNVbmRlZmluZWQgfHwgaXNJbnRyaW5zaWNEZWZhdWx0XTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBCaW5hcnlSZWFkZXIsIEJpbmFyeVdyaXRlciwgV2lyZVR5cGUgfSBmcm9tIFwiLi4vYmluYXJ5LWVuY29kaW5nLmpzXCI7XG5pbXBvcnQgeyBNZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2UuanNcIjtcbmltcG9ydCB7IExvbmdUeXBlLCBTY2FsYXJUeXBlIH0gZnJvbSBcIi4uL2ZpZWxkLmpzXCI7XG5pbXBvcnQgeyB3cmFwRmllbGQgfSBmcm9tIFwiLi9maWVsZC13cmFwcGVyLmpzXCI7XG5pbXBvcnQgeyBzY2FsYXJEZWZhdWx0VmFsdWUsIHNjYWxhclR5cGVJbmZvIH0gZnJvbSBcIi4vc2NhbGFycy5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4vYXNzZXJ0LmpzXCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiwgbm8tY2FzZS1kZWNsYXJhdGlvbnMsIHByZWZlci1jb25zdCAqL1xuY29uc3QgdW5rbm93bkZpZWxkc1N5bWJvbCA9IFN5bWJvbChcIkBidWZidWlsZC9wcm90b2J1Zi91bmtub3duLWZpZWxkc1wiKTtcbi8vIERlZmF1bHQgb3B0aW9ucyBmb3IgcGFyc2luZyBiaW5hcnkgZGF0YS5cbmNvbnN0IHJlYWREZWZhdWx0cyA9IHtcbiAgICByZWFkVW5rbm93bkZpZWxkczogdHJ1ZSxcbiAgICByZWFkZXJGYWN0b3J5OiAoYnl0ZXMpID0+IG5ldyBCaW5hcnlSZWFkZXIoYnl0ZXMpLFxufTtcbi8vIERlZmF1bHQgb3B0aW9ucyBmb3Igc2VyaWFsaXppbmcgYmluYXJ5IGRhdGEuXG5jb25zdCB3cml0ZURlZmF1bHRzID0ge1xuICAgIHdyaXRlVW5rbm93bkZpZWxkczogdHJ1ZSxcbiAgICB3cml0ZXJGYWN0b3J5OiAoKSA9PiBuZXcgQmluYXJ5V3JpdGVyKCksXG59O1xuZnVuY3Rpb24gbWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVhZERlZmF1bHRzKSwgb3B0aW9ucykgOiByZWFkRGVmYXVsdHM7XG59XG5mdW5jdGlvbiBtYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd3JpdGVEZWZhdWx0cyksIG9wdGlvbnMpIDogd3JpdGVEZWZhdWx0cztcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQmluYXJ5Rm9ybWF0Q29tbW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1ha2VSZWFkT3B0aW9ucyxcbiAgICAgICAgbWFrZVdyaXRlT3B0aW9ucyxcbiAgICAgICAgbGlzdFVua25vd25GaWVsZHMobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIChfYSA9IG1lc3NhZ2VbdW5rbm93bkZpZWxkc1N5bWJvbF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICB9LFxuICAgICAgICBkaXNjYXJkVW5rbm93bkZpZWxkcyhtZXNzYWdlKSB7XG4gICAgICAgICAgICBkZWxldGUgbWVzc2FnZVt1bmtub3duRmllbGRzU3ltYm9sXTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGVVbmtub3duRmllbGRzKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgY29uc3QgbSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBjb25zdCBjID0gbVt1bmtub3duRmllbGRzU3ltYm9sXTtcbiAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIGMpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnRhZyhmLm5vLCBmLndpcmVUeXBlKS5yYXcoZi5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIG5vLCB3aXJlVHlwZSwgZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgbSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobVt1bmtub3duRmllbGRzU3ltYm9sXSkpIHtcbiAgICAgICAgICAgICAgICBtW3Vua25vd25GaWVsZHNTeW1ib2xdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtW3Vua25vd25GaWVsZHNTeW1ib2xdLnB1c2goeyBubywgd2lyZVR5cGUsIGRhdGEgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRNZXNzYWdlKG1lc3NhZ2UsIHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpLCBmaWVsZCA9IHR5cGUuZmllbGRzLmZpbmQoZmllbGRObyk7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblVua25vd25GaWVsZChtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBtZXNzYWdlLCByZXBlYXRlZCA9IGZpZWxkLnJlcGVhdGVkLCBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldFtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmNhc2UgIT0gbG9jYWxOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5jYXNlID0gbG9jYWxOYW1lO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbE5hbWUgPSBcInZhbHVlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2FsYXJUeXBlID0gZmllbGQua2luZCA9PSBcImVudW1cIiA/IFNjYWxhclR5cGUuSU5UMzIgOiBmaWVsZC5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYWQgPSByZWFkU2NhbGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uIC0tIGFjY2VwdGFibGUgc2luY2UgaXQncyBjb3ZlcmVkIGJ5IHRlc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQua2luZCA9PSBcInNjYWxhclwiICYmIGZpZWxkLkwgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZCA9IHJlYWRTY2FsYXJMVFN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhcnIgPSB0YXJnZXRbbG9jYWxOYW1lXTsgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgYXJyYXksIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGFyVHlwZSAhPSBTY2FsYXJUeXBlLlNUUklORyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsYXJUeXBlICE9IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGUgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKHJlYWQocmVhZGVyLCBzY2FsYXJUeXBlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKHJlYWQocmVhZGVyLCBzY2FsYXJUeXBlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSByZWFkKHJlYWRlciwgc2NhbGFyVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gZmllbGQuVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhZmUgdG8gYXNzdW1lIHByZXNlbmNlIG9mIGFycmF5LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXS5wdXNoKHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBuZXcgbWVzc2FnZVR5cGUoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFtsb2NhbE5hbWVdIGluc3RhbmNlb2YgTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgdGFyZ2V0W2xvY2FsTmFtZV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbmV3IG1lc3NhZ2VUeXBlKCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZmllbGQub25lb2YgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIudW53cmFwRmllbGQodGFyZ2V0W2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBbbWFwS2V5LCBtYXBWYWxdID0gcmVhZE1hcEVudHJ5KGZpZWxkLCByZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgbWFwIG9iamVjdCwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXVttYXBLZXldID0gbWFwVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG4vLyBSZWFkIGEgbWVzc2FnZSwgYXZvaWRpbmcgTWVzc2FnZVR5cGUuZnJvbUJpbmFyeSgpIHRvIHJlLXVzZSB0aGVcbi8vIEJpbmFyeVJlYWRPcHRpb25zIGFuZCB0aGUgSUJpbmFyeVJlYWRlci5cbmZ1bmN0aW9uIHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW47XG4gICAgZm9ybWF0LnJlYWRNZXNzYWdlKG1lc3NhZ2UsIHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbn1cbi8vIFJlYWQgYSBtYXAgZmllbGQsIGV4cGVjdGluZyBrZXkgZmllbGQgPSAxLCB2YWx1ZSBmaWVsZCA9IDJcbmZ1bmN0aW9uIHJlYWRNYXBFbnRyeShmaWVsZCwgcmVhZGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gcmVhZGVyLnVpbnQzMigpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGxldCBrZXksIHZhbDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICBsZXQgW2ZpZWxkTm9dID0gcmVhZGVyLnRhZygpO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBrZXkgPSByZWFkU2NhbGFyKHJlYWRlciwgZmllbGQuSyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmVhZFNjYWxhcihyZWFkZXIsIGZpZWxkLlYuVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbmV3IGZpZWxkLlYuVCgpLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGtleVJhdyA9IHNjYWxhckRlZmF1bHRWYWx1ZShmaWVsZC5LLCBMb25nVHlwZS5CSUdJTlQpO1xuICAgICAgICBrZXkgPVxuICAgICAgICAgICAgZmllbGQuSyA9PSBTY2FsYXJUeXBlLkJPT0xcbiAgICAgICAgICAgICAgICA/IGtleVJhdy50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgOiBrZXlSYXc7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yga2V5ICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIGtleSAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgIGtleSA9IGtleS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICB2YWwgPSBzY2FsYXJEZWZhdWx0VmFsdWUoZmllbGQuVi5ULCBMb25nVHlwZS5CSUdJTlQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICB2YWwgPSBuZXcgZmllbGQuVi5UKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtrZXksIHZhbF07XG59XG4vLyBSZWFkIGEgc2NhbGFyIHZhbHVlLCBidXQgcmV0dXJuIDY0IGJpdCBpbnRlZ3JhbCB0eXBlcyAoaW50NjQsIHVpbnQ2NCxcbi8vIHNpbnQ2NCwgZml4ZWQ2NCwgc2ZpeGVkNjQpIGFzIHN0cmluZyBpbnN0ZWFkIG9mIGJpZ2ludC5cbmV4cG9ydCBmdW5jdGlvbiByZWFkU2NhbGFyTFRTdHJpbmcocmVhZGVyLCB0eXBlKSB7XG4gICAgY29uc3QgdiA9IHJlYWRTY2FsYXIocmVhZGVyLCB0eXBlKTtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT0gXCJiaWdpbnRcIiA/IHYudG9TdHJpbmcoKSA6IHY7XG59XG4vLyBEb2VzIG5vdCB1c2Ugc2NhbGFyVHlwZUluZm8oKSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuZnVuY3Rpb24gcmVhZFNjYWxhcihyZWFkZXIsIHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5ib29sKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmZpeGVkNjQoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5ieXRlcygpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuZml4ZWQzMigpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnNmaXhlZDMyKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuc2ZpeGVkNjQoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuc2ludDY0KCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5zaW50MzIoKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gd3JpdGVNYXBFbnRyeSh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCBrZXksIHZhbHVlKSB7XG4gICAgd3JpdGVyLnRhZyhmaWVsZC5ubywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKTtcbiAgICB3cml0ZXIuZm9yaygpO1xuICAgIC8vIGphdmFzY3JpcHQgb25seSBhbGxvd3MgbnVtYmVyIG9yIHN0cmluZyBmb3Igb2JqZWN0IHByb3BlcnRpZXNcbiAgICAvLyB3ZSBjb252ZXJ0IGZyb20gb3VyIHJlcHJlc2VudGF0aW9uIHRvIHRoZSBwcm90b2J1ZiB0eXBlXG4gICAgbGV0IGtleVZhbHVlID0ga2V5O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIHdlIGRlbGliZXJhdGVseSBoYW5kbGUganVzdCB0aGUgc3BlY2lhbCBjYXNlcyBmb3IgbWFwIGtleXNcbiAgICBzd2l0Y2ggKGZpZWxkLkspIHtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgICAgICAga2V5VmFsdWUgPSBOdW1iZXIucGFyc2VJbnQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgICAgICAgIGFzc2VydChrZXkgPT0gXCJ0cnVlXCIgfHwga2V5ID09IFwiZmFsc2VcIik7XG4gICAgICAgICAgICBrZXlWYWx1ZSA9IGtleSA9PSBcInRydWVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyB3cml0ZSBrZXksIGV4cGVjdGluZyBrZXkgZmllbGQgbnVtYmVyID0gMVxuICAgIHdyaXRlU2NhbGFyKHdyaXRlciwgZmllbGQuSywgMSwga2V5VmFsdWUsIHRydWUpO1xuICAgIC8vIHdyaXRlIHZhbHVlLCBleHBlY3RpbmcgdmFsdWUgZmllbGQgbnVtYmVyID0gMlxuICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgIHdyaXRlU2NhbGFyKHdyaXRlciwgZmllbGQuVi5ULCAyLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIHdyaXRlU2NhbGFyKHdyaXRlciwgU2NhbGFyVHlwZS5JTlQzMiwgMiwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLlYuVCwgMiwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHdyaXRlci5qb2luKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCB0eXBlLCBmaWVsZE5vLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB3cmFwRmllbGQodHlwZSwgdmFsdWUpO1xuICAgICAgICB3cml0ZXJcbiAgICAgICAgICAgIC50YWcoZmllbGRObywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKVxuICAgICAgICAgICAgLmJ5dGVzKG1lc3NhZ2UudG9CaW5hcnkob3B0aW9ucykpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVNjYWxhcih3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlLCBlbWl0SW50cmluc2ljRGVmYXVsdCkge1xuICAgIGxldCBbd2lyZVR5cGUsIG1ldGhvZCwgaXNJbnRyaW5zaWNEZWZhdWx0XSA9IHNjYWxhclR5cGVJbmZvKHR5cGUsIHZhbHVlKTtcbiAgICBpZiAoIWlzSW50cmluc2ljRGVmYXVsdCB8fCBlbWl0SW50cmluc2ljRGVmYXVsdCkge1xuICAgICAgICB3cml0ZXIudGFnKGZpZWxkTm8sIHdpcmVUeXBlKVttZXRob2RdKHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gd3JpdGVQYWNrZWQod3JpdGVyLCB0eXBlLCBmaWVsZE5vLCB2YWx1ZSkge1xuICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd3JpdGVyLnRhZyhmaWVsZE5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKTtcbiAgICBsZXQgWywgbWV0aG9kXSA9IHNjYWxhclR5cGVJbmZvKHR5cGUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd3JpdGVyW21ldGhvZF0odmFsdWVbaV0pO1xuICAgIH1cbiAgICB3cml0ZXIuam9pbigpO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IFNjYWxhclR5cGUgfSBmcm9tIFwiLi4vZmllbGQuanNcIjtcbmltcG9ydCB7IG1ha2VCaW5hcnlGb3JtYXRDb21tb24sIHdyaXRlTWFwRW50cnksIHdyaXRlTWVzc2FnZUZpZWxkLCB3cml0ZVBhY2tlZCwgd3JpdGVTY2FsYXIsIH0gZnJvbSBcIi4vYmluYXJ5LWZvcm1hdC1jb21tb24uanNcIjtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnMsIHByZWZlci1jb25zdCwgbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQmluYXJ5Rm9ybWF0UHJvdG8zKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1ha2VCaW5hcnlGb3JtYXRDb21tb24oKSksIHsgd3JpdGVNZXNzYWdlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlLmZpZWxkcy5ieU51bWJlcigpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlLCAvLyB0aGlzIHdpbGwgYmUgb3VyIGZpZWxkIHZhbHVlLCB3aGV0aGVyIGl0IGlzIG1lbWJlciBvZiBhIG9uZW9mIG9yIHJlZ3VsYXIgZmllbGRcbiAgICAgICAgICAgICAgICByZXBlYXRlZCA9IGZpZWxkLnJlcGVhdGVkLCBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uZW9mID0gbWVzc2FnZVtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25lb2YuY2FzZSAhPT0gbG9jYWxOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gZmllbGQgaXMgbm90IHNlbGVjdGVkLCBza2lwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvbmVvZi52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWVzc2FnZVtsb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNjYWxhclR5cGUgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gU2NhbGFyVHlwZS5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQucGFja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlUGFja2VkKHdyaXRlciwgc2NhbGFyVHlwZSwgZmllbGQubm8sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBzY2FsYXJUeXBlLCBmaWVsZC5ubywgaXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZVNjYWxhcih3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCB2YWx1ZSwgISFmaWVsZC5vbmVvZiB8fCBmaWVsZC5vcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgZmllbGQuVCwgZmllbGQubm8sIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgZmllbGQuVCwgZmllbGQubm8sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVNYXBFbnRyeSh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCBrZXksIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy53cml0ZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfSB9KTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIHByZWZlci1jb25zdCAqL1xuLy8gbG9va3VwIHRhYmxlIGZyb20gYmFzZTY0IGNoYXJhY3RlciB0byBieXRlXG5sZXQgZW5jVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5zcGxpdChcIlwiKTtcbi8vIGxvb2t1cCB0YWJsZSBmcm9tIGJhc2U2NCBjaGFyYWN0ZXIgKmNvZGUqIHRvIGJ5dGUgYmVjYXVzZSBsb29rdXAgYnkgbnVtYmVyIGlzIGZhc3RcbmxldCBkZWNUYWJsZSA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNUYWJsZS5sZW5ndGg7IGkrKylcbiAgICBkZWNUYWJsZVtlbmNUYWJsZVtpXS5jaGFyQ29kZUF0KDApXSA9IGk7XG4vLyBzdXBwb3J0IGJhc2U2NHVybCB2YXJpYW50c1xuZGVjVGFibGVbXCItXCIuY2hhckNvZGVBdCgwKV0gPSBlbmNUYWJsZS5pbmRleE9mKFwiK1wiKTtcbmRlY1RhYmxlW1wiX1wiLmNoYXJDb2RlQXQoMCldID0gZW5jVGFibGUuaW5kZXhPZihcIi9cIik7XG5leHBvcnQgY29uc3QgcHJvdG9CYXNlNjQgPSB7XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIGJhc2U2NCBzdHJpbmcgdG8gYSBieXRlIGFycmF5LlxuICAgICAqXG4gICAgICogLSBpZ25vcmVzIHdoaXRlLXNwYWNlLCBpbmNsdWRpbmcgbGluZSBicmVha3MgYW5kIHRhYnNcbiAgICAgKiAtIGFsbG93cyBpbm5lciBwYWRkaW5nIChjYW4gZGVjb2RlIGNvbmNhdGVuYXRlZCBiYXNlNjQgc3RyaW5ncylcbiAgICAgKiAtIGRvZXMgbm90IHJlcXVpcmUgcGFkZGluZ1xuICAgICAqIC0gdW5kZXJzdGFuZHMgYmFzZTY0dXJsIGVuY29kaW5nOlxuICAgICAqICAgXCItXCIgaW5zdGVhZCBvZiBcIitcIixcbiAgICAgKiAgIFwiX1wiIGluc3RlYWQgb2YgXCIvXCIsXG4gICAgICogICBubyBwYWRkaW5nXG4gICAgICovXG4gICAgZGVjKGJhc2U2NFN0cikge1xuICAgICAgICAvLyBlc3RpbWF0ZSBieXRlIHNpemUsIG5vdCBhY2NvdW50aW5nIGZvciBpbm5lciBwYWRkaW5nIGFuZCB3aGl0ZXNwYWNlXG4gICAgICAgIGxldCBlcyA9IChiYXNlNjRTdHIubGVuZ3RoICogMykgLyA0O1xuICAgICAgICBpZiAoYmFzZTY0U3RyW2Jhc2U2NFN0ci5sZW5ndGggLSAyXSA9PSBcIj1cIilcbiAgICAgICAgICAgIGVzIC09IDI7XG4gICAgICAgIGVsc2UgaWYgKGJhc2U2NFN0cltiYXNlNjRTdHIubGVuZ3RoIC0gMV0gPT0gXCI9XCIpXG4gICAgICAgICAgICBlcyAtPSAxO1xuICAgICAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShlcyksIGJ5dGVQb3MgPSAwLCAvLyBwb3NpdGlvbiBpbiBieXRlIGFycmF5XG4gICAgICAgIGdyb3VwUG9zID0gMCwgLy8gcG9zaXRpb24gaW4gYmFzZTY0IGdyb3VwXG4gICAgICAgIGIsIC8vIGN1cnJlbnQgYnl0ZVxuICAgICAgICBwID0gMDsgLy8gcHJldmlvdXMgYnl0ZVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2U2NFN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYiA9IGRlY1RhYmxlW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGJhc2U2NFN0cltpXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMDsgLy8gcmVzZXQgc3RhdGUgd2hlbiBwYWRkaW5nIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgd2hpdGUtc3BhY2UsIGFuZCBwYWRkaW5nXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgYmFzZTY0IHN0cmluZy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChncm91cFBvcykge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKHAgPDwgMikgfCAoKGIgJiA0OCkgPj4gNCk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBiO1xuICAgICAgICAgICAgICAgICAgICBncm91cFBvcyA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9ICgocCAmIDE1KSA8PCA0KSB8ICgoYiAmIDYwKSA+PiAyKTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKChwICYgMykgPDwgNikgfCBiO1xuICAgICAgICAgICAgICAgICAgICBncm91cFBvcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cFBvcyA9PSAxKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGJhc2U2NCBzdHJpbmcuXCIpO1xuICAgICAgICByZXR1cm4gYnl0ZXMuc3ViYXJyYXkoMCwgYnl0ZVBvcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmNvZGUgYSBieXRlIGFycmF5IHRvIGEgYmFzZTY0IHN0cmluZy5cbiAgICAgKi9cbiAgICBlbmMoYnl0ZXMpIHtcbiAgICAgICAgbGV0IGJhc2U2NCA9IFwiXCIsIGdyb3VwUG9zID0gMCwgLy8gcG9zaXRpb24gaW4gYmFzZTY0IGdyb3VwXG4gICAgICAgIGIsIC8vIGN1cnJlbnQgYnl0ZVxuICAgICAgICBwID0gMDsgLy8gY2Fycnkgb3ZlciBmcm9tIHByZXZpb3VzIGJ5dGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYiA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgc3dpdGNoIChncm91cFBvcykge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW2IgPj4gMl07XG4gICAgICAgICAgICAgICAgICAgIHAgPSAoYiAmIDMpIDw8IDQ7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcCB8IChiID4+IDQpXTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IChiICYgMTUpIDw8IDI7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcCB8IChiID4+IDYpXTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW2IgJiA2M107XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIG91dHB1dCBwYWRkaW5nXG4gICAgICAgIGlmIChncm91cFBvcykge1xuICAgICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3BdO1xuICAgICAgICAgICAgYmFzZTY0ICs9IFwiPVwiO1xuICAgICAgICAgICAgaWYgKGdyb3VwUG9zID09IDEpXG4gICAgICAgICAgICAgICAgYmFzZTY0ICs9IFwiPVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfSxcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgTWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlLmpzXCI7XG5pbXBvcnQgeyBMb25nVHlwZSwgU2NhbGFyVHlwZSB9IGZyb20gXCIuLi9maWVsZC5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRGbG9hdDMyLCBhc3NlcnRJbnQzMiwgYXNzZXJ0VUludDMyIH0gZnJvbSBcIi4vYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBwcm90b0ludDY0IH0gZnJvbSBcIi4uL3Byb3RvLWludDY0LmpzXCI7XG5pbXBvcnQgeyBwcm90b0Jhc2U2NCB9IGZyb20gXCIuLi9wcm90by1iYXNlNjQuanNcIjtcbi8qIGVzbGludC1kaXNhYmxlIG5vLWNhc2UtZGVjbGFyYXRpb25zLCBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgKi9cbi8vIERlZmF1bHQgb3B0aW9ucyBmb3IgcGFyc2luZyBKU09OLlxuY29uc3QganNvblJlYWREZWZhdWx0cyA9IHtcbiAgICBpZ25vcmVVbmtub3duRmllbGRzOiBmYWxzZSxcbn07XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHNlcmlhbGl6aW5nIHRvIEpTT04uXG5jb25zdCBqc29uV3JpdGVEZWZhdWx0cyA9IHtcbiAgICBlbWl0RGVmYXVsdFZhbHVlczogZmFsc2UsXG4gICAgZW51bUFzSW50ZWdlcjogZmFsc2UsXG4gICAgdXNlUHJvdG9GaWVsZE5hbWU6IGZhbHNlLFxuICAgIHByZXR0eVNwYWNlczogMCxcbn07XG5mdW5jdGlvbiBtYWtlUmVhZE9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBqc29uUmVhZERlZmF1bHRzKSwgb3B0aW9ucykgOiBqc29uUmVhZERlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGpzb25Xcml0ZURlZmF1bHRzKSwgb3B0aW9ucykgOiBqc29uV3JpdGVEZWZhdWx0cztcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSnNvbkZvcm1hdENvbW1vbihtYWtlV3JpdGVGaWVsZCkge1xuICAgIGNvbnN0IHdyaXRlRmllbGQgPSBtYWtlV3JpdGVGaWVsZCh3cml0ZUVudW0sIHdyaXRlU2NhbGFyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYWtlUmVhZE9wdGlvbnMsXG4gICAgICAgIG1ha2VXcml0ZU9wdGlvbnMsXG4gICAgICAgIHJlYWRNZXNzYWdlKHR5cGUsIGpzb24sIG9wdGlvbnMsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChqc29uID09IG51bGwgfHwgQXJyYXkuaXNBcnJheShqc29uKSB8fCB0eXBlb2YganNvbiAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgJHt0eXBlLnR5cGVOYW1lfSBmcm9tIEpTT046ICR7dGhpcy5kZWJ1Zyhqc29uKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBuZXcgdHlwZSgpO1xuICAgICAgICAgICAgY29uc3Qgb25lb2ZTZWVuID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtqc29uS2V5LCBqc29uVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGpzb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0eXBlLmZpZWxkcy5maW5kSnNvbk5hbWUoanNvbktleSk7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgJHt0eXBlLnR5cGVOYW1lfSBmcm9tIEpTT046IGtleSBcIiR7anNvbktleX1cIiBpcyB1bmtub3duYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwgJiYgZmllbGQua2luZCA9PSBcInNjYWxhclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWUgY29uZm9ybWFuY2UgdGVzdCBSZXF1aXJlZC5Qcm90bzMuSnNvbklucHV0Lk9uZW9mRmllbGROdWxse0ZpcnN0LFNlY29uZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlZW4gPSBvbmVvZlNlZW5bZmllbGQub25lb2YubG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBtZXNzYWdlICR7dHlwZS50eXBlTmFtZX0gZnJvbSBKU09OOiBtdWx0aXBsZSBrZXlzIGZvciBvbmVvZiBcIiR7ZmllbGQub25lb2YubmFtZX1cIiBwcmVzZW50OiBcIiR7c2Vlbn1cIiwgXCIke2pzb25LZXl9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvbmVvZlNlZW5bZmllbGQub25lb2YubG9jYWxOYW1lXSA9IGpzb25LZXk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldFtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdID0geyBjYXNlOiBsb2NhbE5hbWUgfTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxOYW1lID0gXCJ2YWx1ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb25WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiAke3RoaXMuZGVidWcoanNvblZhbHVlKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRBcnJheSA9IHRhcmdldFtsb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGpzb25JdGVtIG9mIGpzb25WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25JdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGZpZWxkICR7dHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7dGhpcy5kZWJ1Zyhqc29uSXRlbSl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gXCJtYXBcIiBpcyBpbnZhbGlkIGZvciByZXBlYXRlZCBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGZpZWxkLlQuZnJvbUpzb24oanNvbkl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSByZWFkRW51bShmaWVsZC5ULCBqc29uSXRlbSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRTY2FsYXIoZmllbGQuVCwganNvbkl0ZW0sIGZpZWxkLkwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IGBjYW5ub3QgZGVjb2RlIGZpZWxkICR7dHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7dGhpcy5kZWJ1Zyhqc29uSXRlbSl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtICs9IGA6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRBcnJheS5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGpzb25WYWx1ZSkgfHwgdHlwZW9mIGpzb25WYWx1ZSAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgZmllbGQgJHt0eXBlLnR5cGVOYW1lfS4ke2ZpZWxkLm5hbWV9IGZyb20gSlNPTjogJHt0aGlzLmRlYnVnKGpzb25WYWx1ZSl9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0TWFwID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2pzb25NYXBLZXksIGpzb25NYXBWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoanNvblZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25NYXBWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiBtYXAgdmFsdWUgbnVsbGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZmllbGQuVi5ULmZyb21Kc29uKGpzb25NYXBWYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRFbnVtKGZpZWxkLlYuVCwganNvbk1hcFZhbHVlLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmVhZFNjYWxhcihmaWVsZC5WLlQsIGpzb25NYXBWYWx1ZSwgTG9uZ1R5cGUuQklHSU5UKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBtYXAgdmFsdWUgZm9yIGZpZWxkICR7dHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7dGhpcy5kZWJ1Zyhqc29uVmFsdWUpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSArPSBgOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRNYXBbcmVhZFNjYWxhcihmaWVsZC5LLCBmaWVsZC5LID09IFNjYWxhclR5cGUuQk9PTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGpzb25NYXBLZXkgPT0gXCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBqc29uTWFwS2V5ID09IFwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGpzb25NYXBLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBqc29uTWFwS2V5LCBMb25nVHlwZS5CSUdJTlQpLnRvU3RyaW5nKCldID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IGBjYW5ub3QgZGVjb2RlIG1hcCBrZXkgZm9yIGZpZWxkICR7dHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7dGhpcy5kZWJ1Zyhqc29uVmFsdWUpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtICs9IGA6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gZmllbGQuVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VUeXBlLnR5cGVOYW1lICE9IFwiZ29vZ2xlLnByb3RvYnVmLlZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgZmllbGQgJHt0eXBlLnR5cGVOYW1lfS4ke2ZpZWxkLm5hbWV9IGZyb20gSlNPTjogbnVsbCBpcyBpbnZhbGlkIGZvciBvbmVvZiBmaWVsZCBcIiR7anNvbktleX1cImApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W2xvY2FsTmFtZV0gaW5zdGFuY2VvZiBNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IG1lc3NhZ2VUeXBlLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIgJiYgIWZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IG1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlci51bndyYXBGaWVsZCh0YXJnZXRbbG9jYWxOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHJlYWRFbnVtKGZpZWxkLlQsIGpzb25WYWx1ZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW51bVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBlbnVtVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gcmVhZFNjYWxhcihmaWVsZC5ULCBqc29uVmFsdWUsIGZpZWxkLkwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IGBjYW5ub3QgZGVjb2RlIGZpZWxkICR7dHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7dGhpcy5kZWJ1Zyhqc29uVmFsdWUpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gKz0gYDogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlTWVzc2FnZShtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICAgICAgICBjb25zdCBqc29uID0ge307XG4gICAgICAgICAgICBsZXQgZmllbGQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGpzb25WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlci5raW5kID09IFwib25lb2ZcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25lb2YgPSBtZXNzYWdlW21lbWJlci5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uZW9mLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkID0gbWVtYmVyLmZpbmRGaWVsZChvbmVvZi5jYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIm9uZW9mIGNhc2Ugbm90IGZvdW5kOiBcIiArIG9uZW9mLmNhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uVmFsdWUgPSB3cml0ZUZpZWxkKGZpZWxkLCBvbmVvZi52YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IG1lbWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25WYWx1ZSA9IHdyaXRlRmllbGQoZmllbGQsIG1lc3NhZ2VbZmllbGQubG9jYWxOYW1lXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uW29wdGlvbnMudXNlUHJvdG9GaWVsZE5hbWUgPyBmaWVsZC5uYW1lIDogZmllbGQuanNvbk5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBmaWVsZFxuICAgICAgICAgICAgICAgICAgICA/IGBjYW5ub3QgZW5jb2RlIGZpZWxkICR7dHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSB0byBKU09OYFxuICAgICAgICAgICAgICAgICAgICA6IGBjYW5ub3QgZW5jb2RlIG1lc3NhZ2UgJHt0eXBlLnR5cGVOYW1lfSB0byBKU09OYDtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtICsgKHIubGVuZ3RoID4gMCA/IGA6ICR7cn1gIDogXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRTY2FsYXIsXG4gICAgICAgIHdyaXRlU2NhbGFyLFxuICAgICAgICBkZWJ1ZzogZGVidWdKc29uVmFsdWUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlYnVnSnNvblZhbHVlKGpzb24pIHtcbiAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoanNvbikgPyBcImFycmF5XCIgOiBcIm9iamVjdFwiO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4ganNvbi5sZW5ndGggPiAxMDAgPyBcInN0cmluZ1wiIDogYFwiJHtqc29uLnNwbGl0KCdcIicpLmpvaW4oJ1xcXFxcIicpfVwiYDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoanNvbik7XG4gICAgfVxufVxuLy8gTWF5IHRocm93IGFuIGVycm9yLiBJZiB0aGUgZXJyb3IgbWVzc2FnZSBpcyBub24tYmxhbmssIGl0IHNob3VsZCBiZSBzaG93bi5cbi8vIEl0IGlzIHVwIHRvIHRoZSBjYWxsZXIgdG8gcHJvdmlkZSBjb250ZXh0LlxuZnVuY3Rpb24gcmVhZFNjYWxhcih0eXBlLCBqc29uLCBsb25nVHlwZSkge1xuICAgIC8vIGV2ZXJ5IHZhbGlkIGNhc2UgaW4gdGhlIHN3aXRjaCBiZWxvdyByZXR1cm5zLCBhbmQgZXZlcnkgZmFsbFxuICAgIC8vIHRocm91Z2ggaXMgcmVnYXJkZWQgYXMgYSBmYWlsdXJlLlxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAvLyBmbG9hdCwgZG91YmxlOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBzcGVjaWFsIHN0cmluZyB2YWx1ZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiLCBhbmQgXCItSW5maW5pdHlcIi5cbiAgICAgICAgLy8gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuIEV4cG9uZW50IG5vdGF0aW9uIGlzIGFsc28gYWNjZXB0ZWQuXG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gXCJOYU5cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgIGlmIChqc29uID09PSBcIkluZmluaXR5XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgIGlmIChqc29uID09PSBcIi1JbmZpbml0eVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIC8vIGVtcHR5IHN0cmluZyBpcyBub3QgYSBudW1iZXJcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24udHJpbSgpLmxlbmd0aCAhPT0ganNvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBleHRyYSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YganNvbiAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmbG9hdCA9IE51bWJlcihqc29uKTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4oZmxvYXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGEgbnVtYmVyXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShmbG9hdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpbmZpbml0eSBhbmQgLWluZmluaXR5IGFyZSBoYW5kbGVkIGJ5IHN0cmluZyByZXByZXNlbnRhdGlvbiBhYm92ZSwgc28gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5GTE9BVClcbiAgICAgICAgICAgICAgICBhc3NlcnRGbG9hdDMyKGZsb2F0KTtcbiAgICAgICAgICAgIHJldHVybiBmbG9hdDtcbiAgICAgICAgLy8gaW50MzIsIGZpeGVkMzIsIHVpbnQzMjogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBudW1iZXIuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGxldCBpbnQzMjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIGludDMyID0ganNvbjtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBqc29uID09IFwic3RyaW5nXCIgJiYganNvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb24udHJpbSgpLmxlbmd0aCA9PT0ganNvbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGludDMyID0gTnVtYmVyKGpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGludDMyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBTY2FsYXJUeXBlLlVJTlQzMilcbiAgICAgICAgICAgICAgICBhc3NlcnRVSW50MzIoaW50MzIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFzc2VydEludDMyKGludDMyKTtcbiAgICAgICAgICAgIHJldHVybiBpbnQzMjtcbiAgICAgICAgLy8gaW50NjQsIGZpeGVkNjQsIHVpbnQ2NDogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBzdHJpbmcuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm90b0ludDY0Lnplcm87XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIiAmJiB0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY29uc3QgbG9uZyA9IHByb3RvSW50NjQucGFyc2UoanNvbik7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICByZXR1cm4gbG9uZ1R5cGUgPyBsb25nLnRvU3RyaW5nKCkgOiBsb25nO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm90b0ludDY0Lnplcm87XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIiAmJiB0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY29uc3QgdUxvbmcgPSBwcm90b0ludDY0LnVQYXJzZShqc29uKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICAgICAgICAgIHJldHVybiBsb25nVHlwZSA/IHVMb25nLnRvU3RyaW5nKCkgOiB1TG9uZztcbiAgICAgICAgLy8gYm9vbDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgIC8vIHN0cmluZzpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBIHN0cmluZyBtdXN0IGFsd2F5cyBjb250YWluIFVURi04IGVuY29kZWQgb3IgNy1iaXQgQVNDSUkuXG4gICAgICAgICAgICAvLyBXZSB2YWxpZGF0ZSB3aXRoIGVuY29kZVVSSUNvbXBvbmVudCwgd2hpY2ggYXBwZWFycyB0byBiZSB0aGUgZmFzdGVzdCB3aWRlbHkgYXZhaWxhYmxlIG9wdGlvbi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFVURjhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgLy8gYnl0ZXM6IEpTT04gdmFsdWUgd2lsbCBiZSB0aGUgZGF0YSBlbmNvZGVkIGFzIGEgc3RyaW5nIHVzaW5nIHN0YW5kYXJkIGJhc2U2NCBlbmNvZGluZyB3aXRoIHBhZGRpbmdzLlxuICAgICAgICAvLyBFaXRoZXIgc3RhbmRhcmQgb3IgVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nIHdpdGgvd2l0aG91dCBwYWRkaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsIHx8IGpzb24gPT09IFwiXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcmV0dXJuIHByb3RvQmFzZTY0LmRlYyhqc29uKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG59XG5mdW5jdGlvbiByZWFkRW51bSh0eXBlLCBqc29uLCBpZ25vcmVVbmtub3duRmllbGRzKSB7XG4gICAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICAgICAgLy8gcHJvdG8zIHJlcXVpcmVzIDAgdG8gYmUgZGVmYXVsdCB2YWx1ZSBmb3IgYWxsIGVudW1zXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVja1xuICAgIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoanNvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGUuZmluZE5hbWUoanNvbik7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgICAgIGlmICh2YWx1ZSB8fCBpZ25vcmVVbmtub3duRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5ubztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgZW51bSAke3R5cGUudHlwZU5hbWV9IGZyb20gSlNPTjogJHtkZWJ1Z0pzb25WYWx1ZShqc29uKX1gKTtcbn1cbmZ1bmN0aW9uIHdyaXRlRW51bSh0eXBlLCB2YWx1ZSwgZW1pdEludHJpbnNpY0RlZmF1bHQsIGVudW1Bc0ludGVnZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IDAgJiYgIWVtaXRJbnRyaW5zaWNEZWZhdWx0KSB7XG4gICAgICAgIC8vIHByb3RvMyByZXF1aXJlcyAwIHRvIGJlIGRlZmF1bHQgdmFsdWUgZm9yIGFsbCBlbnVtc1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoZW51bUFzSW50ZWdlcikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlLnR5cGVOYW1lID09IFwiZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZVwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB2YWwgPSB0eXBlLmZpbmROdW1iZXIodmFsdWUpO1xuICAgIHJldHVybiAoX2EgPSB2YWwgPT09IG51bGwgfHwgdmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWwubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsdWU7IC8vIGlmIHdlIGRvbid0IGtub3cgdGhlIGVudW0gdmFsdWUsIGp1c3QgcmV0dXJuIHRoZSBudW1iZXJcbn1cbmZ1bmN0aW9uIHdyaXRlU2NhbGFyKHR5cGUsIHZhbHVlLCBlbWl0SW50cmluc2ljRGVmYXVsdCkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAvLyBpbnQzMiwgZml4ZWQzMiwgdWludDMyOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIG51bWJlci4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gMCB8fCBlbWl0SW50cmluc2ljRGVmYXVsdCA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBmbG9hdCwgZG91YmxlOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBzcGVjaWFsIHN0cmluZyB2YWx1ZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiLCBhbmQgXCItSW5maW5pdHlcIi5cbiAgICAgICAgLy8gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuIEV4cG9uZW50IG5vdGF0aW9uIGlzIGFsc28gYWNjZXB0ZWQuXG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgICAgLy8gYXNzZXJ0RmxvYXQzMih2YWx1ZSk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJOYU5cIjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIkluZmluaXR5XCI7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCItSW5maW5pdHlcIjtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gMCB8fCBlbWl0SW50cmluc2ljRGVmYXVsdCA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBzdHJpbmc6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+IDAgfHwgZW1pdEludHJpbnNpY0RlZmF1bHQgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gYm9vbDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwiYm9vbGVhblwiKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSB8fCBlbWl0SW50cmluc2ljRGVmYXVsdCA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIHN0cmluZy4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJiaWdpbnRcIiB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgLy8gV2UgdXNlIGltcGxpY2l0IGNvbnZlcnNpb24gd2l0aCBgdmFsdWUgIT0gMGAgdG8gY2F0Y2ggYm90aCAwbiBhbmQgXCIwXCJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJldHVybiBlbWl0SW50cmluc2ljRGVmYXVsdCB8fCB2YWx1ZSAhPSAwXG4gICAgICAgICAgICAgICAgPyB2YWx1ZS50b1N0cmluZygxMClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gYnl0ZXM6IEpTT04gdmFsdWUgd2lsbCBiZSB0aGUgZGF0YSBlbmNvZGVkIGFzIGEgc3RyaW5nIHVzaW5nIHN0YW5kYXJkIGJhc2U2NCBlbmNvZGluZyB3aXRoIHBhZGRpbmdzLlxuICAgICAgICAvLyBFaXRoZXIgc3RhbmRhcmQgb3IgVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nIHdpdGgvd2l0aG91dCBwYWRkaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgICAgICAgIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xuICAgICAgICAgICAgcmV0dXJuIGVtaXRJbnRyaW5zaWNEZWZhdWx0IHx8IHZhbHVlLmJ5dGVMZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgPyBwcm90b0Jhc2U2NC5lbmModmFsdWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IHdyYXBGaWVsZCB9IGZyb20gXCIuL2ZpZWxkLXdyYXBwZXIuanNcIjtcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuL2Fzc2VydC5qc1wiO1xuaW1wb3J0IHsgbWFrZUpzb25Gb3JtYXRDb21tb24gfSBmcm9tIFwiLi9qc29uLWZvcm1hdC1jb21tb24uanNcIjtcbi8qIGVzbGludC1kaXNhYmxlIG5vLWNhc2UtZGVjbGFyYXRpb25zLCBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSnNvbkZvcm1hdFByb3RvMygpIHtcbiAgICByZXR1cm4gbWFrZUpzb25Gb3JtYXRDb21tb24oKHdyaXRlRW51bSwgd3JpdGVTY2FsYXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHdyaXRlRmllbGQoZmllbGQsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbk9iaiA9IHt9O1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB3cml0ZVNjYWxhcihmaWVsZC5WLlQsIGVudHJ5VmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCh2YWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IHZhbDsgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25PYmpbZW50cnlLZXkudG9TdHJpbmcoKV0gPSBlbnRyeVZhbHVlLnRvSnNvbihvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW51bVR5cGUgPSBmaWVsZC5WLlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGVudHJ5VmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgZW50cnlWYWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB3cml0ZUVudW0oZW51bVR5cGUsIGVudHJ5VmFsdWUsIHRydWUsIG9wdGlvbnMuZW51bUFzSW50ZWdlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gdmFsOyAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMgfHwgT2JqZWN0LmtleXMoanNvbk9iaikubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICA/IGpzb25PYmpcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpzb25BcnIgPSBbXTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25BcnIucHVzaCh3cml0ZVNjYWxhcihmaWVsZC5ULCB2YWx1ZVtpXSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbkFyci5wdXNoKHdyaXRlRW51bShmaWVsZC5ULCB2YWx1ZVtpXSwgdHJ1ZSwgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2god3JhcEZpZWxkKGZpZWxkLlQsIHZhbHVlW2ldKS50b0pzb24ob3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IGpzb25BcnIubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICA/IGpzb25BcnJcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlU2NhbGFyKGZpZWxkLlQsIHZhbHVlLCAhIWZpZWxkLm9uZW9mIHx8IGZpZWxkLm9wdCB8fCBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZUVudW0oZmllbGQuVCwgdmFsdWUsICEhZmllbGQub25lb2YgfHwgZmllbGQub3B0IHx8IG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMsIG9wdGlvbnMuZW51bUFzSW50ZWdlcik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gd3JhcEZpZWxkKGZpZWxkLlQsIHZhbHVlKS50b0pzb24ob3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgc2V0RW51bVR5cGUgfSBmcm9tIFwiLi9lbnVtLmpzXCI7XG5pbXBvcnQgeyBNZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2UuanNcIjtcbmltcG9ydCB7IFNjYWxhclR5cGUgfSBmcm9tIFwiLi4vZmllbGQuanNcIjtcbmltcG9ydCB7IHNjYWxhckVxdWFscyB9IGZyb20gXCIuL3NjYWxhcnMuanNcIjtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybixAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50LG5vLWNhc2UtZGVjbGFyYXRpb25zICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVV0aWxDb21tb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2V0RW51bVR5cGUsXG4gICAgICAgIGluaXRQYXJ0aWFsKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAoc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdGFyZ2V0LmdldFR5cGUoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbE5hbWUgPSBtZW1iZXIubG9jYWxOYW1lLCB0ID0gdGFyZ2V0LCBzID0gc291cmNlO1xuICAgICAgICAgICAgICAgIGlmIChzW2xvY2FsTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZW1iZXIua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib25lb2ZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNrID0gc1tsb2NhbE5hbWVdLmNhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlRmllbGQgPSBtZW1iZXIuZmluZEZpZWxkKHNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBzW2xvY2FsTmFtZV0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlRmllbGQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VGaWVsZC5raW5kID09IFwibWVzc2FnZVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgISh2YWwgaW5zdGFuY2VvZiBzb3VyY2VGaWVsZC5UKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG5ldyBzb3VyY2VGaWVsZC5UKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VGaWVsZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUZpZWxkLmtpbmQgPT09IFwic2NhbGFyXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VGaWVsZC5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdG9VOEFycih2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0geyBjYXNlOiBzaywgdmFsdWU6IHZhbCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3B5ID0gc1tsb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlci5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weSA9IG1lbWJlci5yZXBlYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNvcHkubWFwKHRvVThBcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdG9VOEFycihjb3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IGNvcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZW1iZXIuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIuVi5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhzW2xvY2FsTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdW2tdID0gdG9VOEFycih2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odFtsb2NhbE5hbWVdLCBzW2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gbWVtYmVyLlYuVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHNbbG9jYWxOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBzW2xvY2FsTmFtZV1ba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgdGFrZSBwYXJ0aWFsIGlucHV0IGZvciBtZXNzYWdlcyB0aGF0IGFyZSBub3QgYSB3cmFwcGVyIHR5cGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRob3NlIG1lc3NhZ2VzLCB3ZSByZWN1cnNpdmVseSBub3JtYWxpemUgdGhlIHBhcnRpYWwgaW5wdXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbmV3IG1lc3NhZ2VUeXBlKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV1ba10gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG10ID0gbWVtYmVyLlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gc1tsb2NhbE5hbWVdLm1hcCgodmFsKSA9PiB2YWwgaW5zdGFuY2VvZiBtdCA/IHZhbCA6IG5ldyBtdCh2YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbbG9jYWxOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gc1tsb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdC5maWVsZFdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCB1c2UgQnl0ZXNWYWx1ZS50eXBlTmFtZSBhcyB0aGF0IHdpbGwgY3JlYXRlIGEgY2lyY3VsYXIgaW1wb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG10LnR5cGVOYW1lID09PSBcImdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHRvVThBcnIodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gdmFsIGluc3RhbmNlb2YgbXQgPyB2YWwgOiBuZXcgbXQodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVxdWFscyh0eXBlLCBhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhIHx8ICFiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkuZXZlcnkoKG0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YSA9IGFbbS5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZiID0gYlttLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhLmxlbmd0aCAhPT0gdmIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gcmVwZWF0ZWQgZmllbGRzIGFyZSBuZXZlciBcIm1hcFwiXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobS5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gbS5ULmVxdWFscyhhLCB2YltpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gc2NhbGFyRXF1YWxzKG0uVCwgYSwgdmJbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgYSwgdmJbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlcGVhdGVkIGNhbm5vdCBjb250YWluICR7bS5raW5kfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG0ua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0uVC5lcXVhbHModmEsIHZiKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgdmEsIHZiKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhtLlQsIHZhLCB2Yik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhLmNhc2UgIT09IHZiLmNhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gbS5maW5kRmllbGQodmEuY2FzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSBvbmVvZiBmaWVsZHMgYXJlIG5ldmVyIFwibWFwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocy5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuVC5lcXVhbHModmEudmFsdWUsIHZiLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhLnZhbHVlLCB2Yi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKHMuVCwgdmEudmFsdWUsIHZiLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25lb2YgY2Fubm90IGNvbnRhaW4gJHtzLmtpbmR9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YSkuY29uY2F0KE9iamVjdC5rZXlzKHZiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG0uVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBtLlYuVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoKGspID0+IG1lc3NhZ2VUeXBlLmVxdWFscyh2YVtrXSwgdmJba10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeSgoaykgPT4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGFyVHlwZSA9IG0uVi5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeSgoaykgPT4gc2NhbGFyRXF1YWxzKHNjYWxhclR5cGUsIHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb25lKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKSwgdGFyZ2V0ID0gbmV3IHR5cGUoKSwgYW55ID0gdGFyZ2V0O1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdHlwZS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IG1lc3NhZ2VbbWVtYmVyLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgbGV0IGNvcHk7XG4gICAgICAgICAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc291cmNlLm1hcChjbG9uZVNpbmd1bGFyRmllbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZW1iZXIua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBhbnlbbWVtYmVyLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdl0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weVtrZXldID0gY2xvbmVTaW5ndWxhckZpZWxkKHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lbWJlci5raW5kID09IFwib25lb2ZcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmID0gbWVtYmVyLmZpbmRGaWVsZChzb3VyY2UuY2FzZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBmXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgY2FzZTogc291cmNlLmNhc2UsIHZhbHVlOiBjbG9uZVNpbmd1bGFyRmllbGQoc291cmNlLnZhbHVlKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgY2FzZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gY2xvbmVTaW5ndWxhckZpZWxkKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFueVttZW1iZXIubG9jYWxOYW1lXSA9IGNvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyBjbG9uZSBhIHNpbmdsZSBmaWVsZCB2YWx1ZSAtIGkuZS4gdGhlIGVsZW1lbnQgdHlwZSBvZiByZXBlYXRlZCBmaWVsZHMsIHRoZSB2YWx1ZSB0eXBlIG9mIG1hcHNcbmZ1bmN0aW9uIGNsb25lU2luZ3VsYXJGaWVsZCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuY2xvbmUoKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGMuc2V0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIGNvbnZlcnRzIGFueSBBcnJheUxpa2U8bnVtYmVyPiB0byBVaW50OEFycmF5IGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIHRvVThBcnIoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gaW5wdXQgOiBuZXcgVWludDhBcnJheShpbnB1dCk7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuZXhwb3J0IGNsYXNzIEludGVybmFsRmllbGRMaXN0IHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIG5vcm1hbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5fZmllbGRzID0gZmllbGRzO1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVyID0gbm9ybWFsaXplcjtcbiAgICB9XG4gICAgZmluZEpzb25OYW1lKGpzb25OYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5qc29uTmFtZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLmxpc3QoKSkge1xuICAgICAgICAgICAgICAgIHRbZi5qc29uTmFtZV0gPSB0W2YubmFtZV0gPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5qc29uTmFtZXMgPSB0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmpzb25OYW1lc1tqc29uTmFtZV07XG4gICAgfVxuICAgIGZpbmQoZmllbGRObykge1xuICAgICAgICBpZiAoIXRoaXMubnVtYmVycykge1xuICAgICAgICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgICAgICAgICAgdFtmLm5vXSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm51bWJlcnMgPSB0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm51bWJlcnNbZmllbGROb107XG4gICAgfVxuICAgIGxpc3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsID0gdGhpcy5fbm9ybWFsaXplcih0aGlzLl9maWVsZHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFsbDtcbiAgICB9XG4gICAgYnlOdW1iZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5udW1iZXJzQXNjKSB7XG4gICAgICAgICAgICB0aGlzLm51bWJlcnNBc2MgPSB0aGlzLmxpc3QoKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLm5vIC0gYi5ubyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubnVtYmVyc0FzYztcbiAgICB9XG4gICAgYnlNZW1iZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5tZW1iZXJzKSB7XG4gICAgICAgICAgICB0aGlzLm1lbWJlcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLm1lbWJlcnM7XG4gICAgICAgICAgICBsZXQgbztcbiAgICAgICAgICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLmxpc3QoKSkge1xuICAgICAgICAgICAgICAgIGlmIChmLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmLm9uZW9mICE9PSBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gZi5vbmVvZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tZW1iZXJzO1xuICAgIH1cbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBwcm90b2J1ZiBlbGVtZW50IGluIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEZpZWxkIG5hbWVzIC0gaW5jbHVkaW5nIG9uZW9mcyAtIGFyZSBjb252ZXJ0ZWQgdG8gbG93ZXJDYW1lbENhc2UuIEZvclxuICogbWVzc2FnZXMsIGVudW1lcmF0aW9ucyBhbmQgc2VydmljZXMsIHRoZSBwYWNrYWdlIG5hbWUgaXMgc3RyaXBwZWQgZnJvbVxuICogdGhlIHR5cGUgbmFtZS4gRm9yIG5lc3RlZCBtZXNzYWdlcyBhbmQgZW51bWVyYXRpb25zLCB0aGUgbmFtZXMgYXJlIGpvaW5lZFxuICogd2l0aCBhbiB1bmRlcnNjb3JlLiBGb3IgbWV0aG9kcywgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBtYWRlIGxvd2VyY2FzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsTmFtZShkZXNjKSB7XG4gICAgc3dpdGNoIChkZXNjLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcImZpZWxkXCI6XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxGaWVsZE5hbWUoZGVzYy5uYW1lLCBkZXNjLm9uZW9mICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBjYXNlIFwib25lb2ZcIjpcbiAgICAgICAgICAgIHJldHVybiBsb2NhbE9uZW9mTmFtZShkZXNjLm5hbWUpO1xuICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICBjYXNlIFwic2VydmljZVwiOiB7XG4gICAgICAgICAgICBjb25zdCBwa2cgPSBkZXNjLmZpbGUucHJvdG8ucGFja2FnZTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHBrZyA9PT0gdW5kZWZpbmVkID8gMCA6IHBrZy5sZW5ndGggKyAxO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGRlc2MudHlwZU5hbWUuc3Vic3RyaW5nKG9mZnNldCkucmVwbGFjZSgvXFwuL2csIFwiX1wiKTtcbiAgICAgICAgICAgIC8vIEZvciBzZXJ2aWNlcywgd2Ugb25seSBjYXJlIGFib3V0IHNhZmUgaWRlbnRpZmllcnMsIG5vdCBzYWZlIG9iamVjdCBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgc2hpcHBlZCB2MSB3aXRoIGEgYnVnIHRoYXQgcmVzcGVjdGVkIG9iamVjdCBwcm9wZXJ0aWVzLCBhbmQgd2VcbiAgICAgICAgICAgIC8vIGRvIG5vdCB3YW50IHRvIGludHJvZHVjZSBhIGJyZWFraW5nIGNoYW5nZSwgc28gd2UgY29udGludWUgdG8gZXNjYXBlIGZvclxuICAgICAgICAgICAgLy8gc2FmZSBvYmplY3QgcHJvcGVydGllcy5cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnVmYnVpbGQvcHJvdG9idWYtZXMvcHVsbC8zOTFcbiAgICAgICAgICAgIHJldHVybiBzYWZlT2JqZWN0UHJvcGVydHkoc2FmZUlkZW50aWZpZXIobmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJlbnVtX3ZhbHVlXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFByZWZpeCA9IGRlc2MucGFyZW50LnNoYXJlZFByZWZpeDtcbiAgICAgICAgICAgIGlmIChzaGFyZWRQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZGVzYy5uYW1lLnN1YnN0cmluZyhzaGFyZWRQcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBzYWZlT2JqZWN0UHJvcGVydHkobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJwY1wiOiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGRlc2MubmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lID0gbmFtZVswXS50b0xvd2VyQ2FzZSgpICsgbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICByZXR1cm4gc2FmZU9iamVjdFByb3BlcnR5KG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgZmllbGQgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbEZpZWxkTmFtZShwcm90b05hbWUsIGluT25lb2YpIHtcbiAgICBjb25zdCBuYW1lID0gcHJvdG9DYW1lbENhc2UocHJvdG9OYW1lKTtcbiAgICBpZiAoaW5PbmVvZikge1xuICAgICAgICAvLyBvbmVvZiBtZW1iZXIgbmFtZXMgYXJlIG5vdCBwcm9wZXJ0aWVzLCBidXQgdmFsdWVzIG9mIHRoZSBgY2FzZWAgcHJvcGVydHkuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gc2FmZU9iamVjdFByb3BlcnR5KHNhZmVNZXNzYWdlUHJvcGVydHkobmFtZSkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgb25lb2YgZ3JvdXAgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbE9uZW9mTmFtZShwcm90b05hbWUpIHtcbiAgICByZXR1cm4gbG9jYWxGaWVsZE5hbWUocHJvdG9OYW1lLCBmYWxzZSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIEpTT04gbmFtZSBmb3IgYSBwcm90b2J1ZiBmaWVsZCwgZXhhY3RseSBsaWtlIHByb3RvYyBkb2VzLlxuICovXG5leHBvcnQgY29uc3QgZmllbGRKc29uTmFtZSA9IHByb3RvQ2FtZWxDYXNlO1xuLyoqXG4gKiBGaW5kcyBhIHByZWZpeCBzaGFyZWQgYnkgZW51bSB2YWx1ZXMsIGZvciBleGFtcGxlIGBNWV9FTlVNX2AgZm9yXG4gKiBgZW51bSBNeUVudW0ge01ZX0VOVU1fQT0wOyBNWV9FTlVNX0I9MTt9YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFbnVtU2hhcmVkUHJlZml4KGVudW1OYW1lLCB2YWx1ZU5hbWVzKSB7XG4gICAgY29uc3QgcHJlZml4ID0gY2FtZWxUb1NuYWtlQ2FzZShlbnVtTmFtZSkgKyBcIl9cIjtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdmFsdWVOYW1lcykge1xuICAgICAgICBpZiAoIW5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hvcnROYW1lID0gbmFtZS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIGlmIChzaG9ydE5hbWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9eXFxkLy50ZXN0KHNob3J0TmFtZSkpIHtcbiAgICAgICAgICAgIC8vIGlkZW50aWZpZXJzIG11c3Qgbm90IHN0YXJ0IHdpdGggbnVtYmVyc1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJlZml4O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBsb3dlckNhbWVsQ2FzZSBvciBVcHBlckNhbWVsQ2FzZSBpbnRvIGxvd2VyX3NuYWtlX2Nhc2UuXG4gKiBUaGlzIGlzIHVzZWQgdG8gZmluZCBzaGFyZWQgcHJlZml4ZXMgaW4gYW4gZW51bS5cbiAqL1xuZnVuY3Rpb24gY2FtZWxUb1NuYWtlQ2FzZShjYW1lbCkge1xuICAgIHJldHVybiAoY2FtZWwuc3Vic3RyaW5nKDAsIDEpICsgY2FtZWwuc3Vic3RyaW5nKDEpLnJlcGxhY2UoL1tBLVpdL2csIChjKSA9PiBcIl9cIiArIGMpKS50b0xvd2VyQ2FzZSgpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBzbmFrZV9jYXNlIHRvIHByb3RvQ2FtZWxDYXNlIGFjY29yZGluZyB0byB0aGUgY29udmVudGlvblxuICogdXNlZCBieSBwcm90b2MgdG8gY29udmVydCBhIGZpZWxkIG5hbWUgdG8gYSBKU09OIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHByb3RvQ2FtZWxDYXNlKHNuYWtlQ2FzZSkge1xuICAgIGxldCBjYXBOZXh0ID0gZmFsc2U7XG4gICAgY29uc3QgYiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc25ha2VDYXNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjID0gc25ha2VDYXNlLmNoYXJBdChpKTtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICBjYXNlIFwiX1wiOlxuICAgICAgICAgICAgICAgIGNhcE5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICAgICAgY2FzZSBcIjZcIjpcbiAgICAgICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICAgICAgY2FzZSBcIjlcIjpcbiAgICAgICAgICAgICAgICBiLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgY2FwTmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2FwTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBjYXBOZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBjLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIucHVzaChjKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYi5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBpZGVudGlmaWVycywgc3VjaCBhcyBjbGFzcyBuYW1lcyxcbiAqIGJ1dCBfY2FuXyBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcy5cbiAqL1xuY29uc3QgcmVzZXJ2ZWRJZGVudGlmaWVycyA9IG5ldyBTZXQoW1xuICAgIC8vIEVDTUFTY3JpcHQgMjAxNSBrZXl3b3Jkc1xuICAgIFwiYnJlYWtcIixcbiAgICBcImNhc2VcIixcbiAgICBcImNhdGNoXCIsXG4gICAgXCJjbGFzc1wiLFxuICAgIFwiY29uc3RcIixcbiAgICBcImNvbnRpbnVlXCIsXG4gICAgXCJkZWJ1Z2dlclwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIFwiZGVsZXRlXCIsXG4gICAgXCJkb1wiLFxuICAgIFwiZWxzZVwiLFxuICAgIFwiZXhwb3J0XCIsXG4gICAgXCJleHRlbmRzXCIsXG4gICAgXCJmYWxzZVwiLFxuICAgIFwiZmluYWxseVwiLFxuICAgIFwiZm9yXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwiaWZcIixcbiAgICBcImltcG9ydFwiLFxuICAgIFwiaW5cIixcbiAgICBcImluc3RhbmNlb2ZcIixcbiAgICBcIm5ld1wiLFxuICAgIFwibnVsbFwiLFxuICAgIFwicmV0dXJuXCIsXG4gICAgXCJzdXBlclwiLFxuICAgIFwic3dpdGNoXCIsXG4gICAgXCJ0aGlzXCIsXG4gICAgXCJ0aHJvd1wiLFxuICAgIFwidHJ1ZVwiLFxuICAgIFwidHJ5XCIsXG4gICAgXCJ0eXBlb2ZcIixcbiAgICBcInZhclwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwid2hpbGVcIixcbiAgICBcIndpdGhcIixcbiAgICBcInlpZWxkXCIsXG4gICAgLy8gRUNNQVNjcmlwdCAyMDE1IGZ1dHVyZSByZXNlcnZlZCBrZXl3b3Jkc1xuICAgIFwiZW51bVwiLFxuICAgIFwiaW1wbGVtZW50c1wiLFxuICAgIFwiaW50ZXJmYWNlXCIsXG4gICAgXCJsZXRcIixcbiAgICBcInBhY2thZ2VcIixcbiAgICBcInByaXZhdGVcIixcbiAgICBcInByb3RlY3RlZFwiLFxuICAgIFwicHVibGljXCIsXG4gICAgXCJzdGF0aWNcIixcbiAgICAvLyBDbGFzcyBuYW1lIGNhbm5vdCBiZSAnT2JqZWN0JyB3aGVuIHRhcmdldGluZyBFUzUgd2l0aCBtb2R1bGUgQ29tbW9uSlNcbiAgICBcIk9iamVjdFwiLFxuICAgIC8vIFR5cGVTY3JpcHQga2V5d29yZHMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3IgdHlwZXMgKGFzIG9wcG9zZWQgdG8gdmFyaWFibGVzKVxuICAgIFwiYmlnaW50XCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcImJvb2xlYW5cIixcbiAgICBcInN0cmluZ1wiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgLy8gSWRlbnRpZmllcnMgcmVzZXJ2ZWQgZm9yIHRoZSBydW50aW1lLCBzbyB3ZSBjYW4gZ2VuZXJhdGUgbGVnaWJsZSBjb2RlXG4gICAgXCJnbG9iYWxUaGlzXCIsXG4gICAgXCJVaW50OEFycmF5XCIsXG4gICAgXCJQYXJ0aWFsXCIsXG5dKTtcbi8qKlxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGFyZSByZXNlcnZlZFxuICogYnkgYnVpbHQtaW4gSmF2YVNjcmlwdCBwcm9wZXJ0aWVzLlxuICovXG5jb25zdCByZXNlcnZlZE9iamVjdFByb3BlcnRpZXMgPSBuZXcgU2V0KFtcbiAgICAvLyBuYW1lcyByZXNlcnZlZCBieSBKYXZhU2NyaXB0XG4gICAgXCJjb25zdHJ1Y3RvclwiLFxuICAgIFwidG9TdHJpbmdcIixcbiAgICBcInRvSlNPTlwiLFxuICAgIFwidmFsdWVPZlwiLFxuXSk7XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcbiAqIGJ5IHRoZSBydW50aW1lLlxuICovXG5jb25zdCByZXNlcnZlZE1lc3NhZ2VQcm9wZXJ0aWVzID0gbmV3IFNldChbXG4gICAgLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgdGhlIHJ1bnRpbWVcbiAgICBcImdldFR5cGVcIixcbiAgICBcImNsb25lXCIsXG4gICAgXCJlcXVhbHNcIixcbiAgICBcImZyb21CaW5hcnlcIixcbiAgICBcImZyb21Kc29uXCIsXG4gICAgXCJmcm9tSnNvblN0cmluZ1wiLFxuICAgIFwidG9CaW5hcnlcIixcbiAgICBcInRvSnNvblwiLFxuICAgIFwidG9Kc29uU3RyaW5nXCIsXG4gICAgLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgdGhlIHJ1bnRpbWUgZm9yIHRoZSBmdXR1cmVcbiAgICBcInRvT2JqZWN0XCIsXG5dKTtcbmNvbnN0IGZhbGxiYWNrID0gKG5hbWUpID0+IGAke25hbWV9JGA7XG4vKipcbiAqIFdpbGwgd3JhcCBuYW1lcyB0aGF0IGFyZSBPYmplY3QgcHJvdG90eXBlIHByb3BlcnRpZXMgb3IgbmFtZXMgcmVzZXJ2ZWRcbiAqIGZvciBgTWVzc2FnZWBzLlxuICovXG5jb25zdCBzYWZlTWVzc2FnZVByb3BlcnR5ID0gKG5hbWUpID0+IHtcbiAgICBpZiAocmVzZXJ2ZWRNZXNzYWdlUHJvcGVydGllcy5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcbiAqIGJ5IGJ1aWx0LWluIEphdmFTY3JpcHQgcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGNvbnN0IHNhZmVPYmplY3RQcm9wZXJ0eSA9IChuYW1lKSA9PiB7XG4gICAgaWYgKHJlc2VydmVkT2JqZWN0UHJvcGVydGllcy5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG4vKipcbiAqIE5hbWVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGlkZW50aWZpZXJzIG9yIGNsYXNzIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGNvbnN0IHNhZmVJZGVudGlmaWVyID0gKG5hbWUpID0+IHtcbiAgICBpZiAocmVzZXJ2ZWRJZGVudGlmaWVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgbG9jYWxPbmVvZk5hbWUgfSBmcm9tIFwiLi9uYW1lcy5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4vYXNzZXJ0LmpzXCI7XG5leHBvcnQgY2xhc3MgSW50ZXJuYWxPbmVvZkluZm8ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5raW5kID0gXCJvbmVvZlwiO1xuICAgICAgICB0aGlzLnJlcGVhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5sb2NhbE5hbWUgPSBsb2NhbE9uZW9mTmFtZShuYW1lKTtcbiAgICB9XG4gICAgYWRkRmllbGQoZmllbGQpIHtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLm9uZW9mID09PSB0aGlzLCBgZmllbGQgJHtmaWVsZC5uYW1lfSBub3Qgb25lIG9mICR7dGhpcy5uYW1lfWApO1xuICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICB9XG4gICAgZmluZEZpZWxkKGxvY2FsTmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvb2t1cCkge1xuICAgICAgICAgICAgdGhpcy5fbG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb29rdXBbdGhpcy5maWVsZHNbaV0ubG9jYWxOYW1lXSA9IHRoaXMuZmllbGRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sb29rdXBbbG9jYWxOYW1lXTtcbiAgICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgbWFrZVByb3RvUnVudGltZSB9IGZyb20gXCIuL3ByaXZhdGUvcHJvdG8tcnVudGltZS5qc1wiO1xuaW1wb3J0IHsgbWFrZUJpbmFyeUZvcm1hdFByb3RvMyB9IGZyb20gXCIuL3ByaXZhdGUvYmluYXJ5LWZvcm1hdC1wcm90bzMuanNcIjtcbmltcG9ydCB7IG1ha2VKc29uRm9ybWF0UHJvdG8zIH0gZnJvbSBcIi4vcHJpdmF0ZS9qc29uLWZvcm1hdC1wcm90bzMuanNcIjtcbmltcG9ydCB7IG1ha2VVdGlsQ29tbW9uIH0gZnJvbSBcIi4vcHJpdmF0ZS91dGlsLWNvbW1vbi5qc1wiO1xuaW1wb3J0IHsgSW50ZXJuYWxGaWVsZExpc3QgfSBmcm9tIFwiLi9wcml2YXRlL2ZpZWxkLWxpc3QuanNcIjtcbmltcG9ydCB7IHNjYWxhckRlZmF1bHRWYWx1ZSB9IGZyb20gXCIuL3ByaXZhdGUvc2NhbGFycy5qc1wiO1xuaW1wb3J0IHsgTG9uZ1R5cGUsIFNjYWxhclR5cGUgfSBmcm9tIFwiLi9maWVsZC5qc1wiO1xuaW1wb3J0IHsgSW50ZXJuYWxPbmVvZkluZm8gfSBmcm9tIFwiLi9wcml2YXRlL2ZpZWxkLmpzXCI7XG5pbXBvcnQgeyBsb2NhbEZpZWxkTmFtZSwgZmllbGRKc29uTmFtZSB9IGZyb20gXCIuL3ByaXZhdGUvbmFtZXMuanNcIjtcbi8qKlxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgbWVzc2FnZXMgZGVmaW5lZCB3aXRoIHRoZSBwcm90bzMgc3ludGF4LlxuICovXG5leHBvcnQgY29uc3QgcHJvdG8zID0gbWFrZVByb3RvUnVudGltZShcInByb3RvM1wiLCBtYWtlSnNvbkZvcm1hdFByb3RvMygpLCBtYWtlQmluYXJ5Rm9ybWF0UHJvdG8zKCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFrZVV0aWxDb21tb24oKSksIHsgbmV3RmllbGRMaXN0KGZpZWxkcykge1xuICAgICAgICByZXR1cm4gbmV3IEludGVybmFsRmllbGRMaXN0KGZpZWxkcywgbm9ybWFsaXplRmllbGRJbmZvc1Byb3RvMyk7XG4gICAgfSxcbiAgICBpbml0RmllbGRzKHRhcmdldCkge1xuICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0YXJnZXQuZ2V0VHlwZSgpLmZpZWxkcy5ieU1lbWJlcigpKSB7XG4gICAgICAgICAgICBpZiAobWVtYmVyLm9wdCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG1lbWJlci5sb2NhbE5hbWUsIHQgPSB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAobWVtYmVyLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgdFtuYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChtZW1iZXIua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgICAgICAgICB0W25hbWVdID0geyBjYXNlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgdFtuYW1lXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICAgICAgdFtuYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgIHRbbmFtZV0gPSBzY2FsYXJEZWZhdWx0VmFsdWUobWVtYmVyLlQsIG1lbWJlci5MKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgLy8gbWVzc2FnZSBmaWVsZHMgYXJlIGFsd2F5cyBvcHRpb25hbCBpbiBwcm90bzNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IH0pKTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50ICovXG5mdW5jdGlvbiBub3JtYWxpemVGaWVsZEluZm9zUHJvdG8zKGZpZWxkSW5mb3MpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgY29uc3QgciA9IFtdO1xuICAgIGxldCBvO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZW9mIGZpZWxkSW5mb3MgPT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gZmllbGRJbmZvcygpXG4gICAgICAgIDogZmllbGRJbmZvcykge1xuICAgICAgICBjb25zdCBmID0gZmllbGQ7XG4gICAgICAgIGYubG9jYWxOYW1lID0gbG9jYWxGaWVsZE5hbWUoZmllbGQubmFtZSwgZmllbGQub25lb2YgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGYuanNvbk5hbWUgPSAoX2EgPSBmaWVsZC5qc29uTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmllbGRKc29uTmFtZShmaWVsZC5uYW1lKTtcbiAgICAgICAgZi5yZXBlYXRlZCA9IChfYiA9IGZpZWxkLnJlcGVhdGVkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgaWYgKGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikge1xuICAgICAgICAgICAgZi5MID0gKF9jID0gZmllbGQuTCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogTG9uZ1R5cGUuQklHSU5UO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZyb20gdGhlIHByb3RvMyBsYW5ndWFnZSBndWlkZTpcbiAgICAgICAgLy8gPiBJbiBwcm90bzMsIHJlcGVhdGVkIGZpZWxkcyBvZiBzY2FsYXIgbnVtZXJpYyB0eXBlcyBhcmUgcGFja2VkIGJ5IGRlZmF1bHQuXG4gICAgICAgIC8vIFRoaXMgaW5mb3JtYXRpb24gaXMgaW5jb21wbGV0ZSAtIGFjY29yZGluZyB0byB0aGUgY29uZm9ybWFuY2UgdGVzdHMsIEJPT0xcbiAgICAgICAgLy8gYW5kIEVOVU0gYXJlIHBhY2tlZCBieSBkZWZhdWx0IGFzIHdlbGwuIFRoaXMgbWVhbnMgb25seSBTVFJJTkcgYW5kIEJZVEVTXG4gICAgICAgIC8vIGFyZSBub3QgcGFja2VkIGJ5IGRlZmF1bHQsIHdoaWNoIG1ha2VzIHNlbnNlIGJlY2F1c2UgdGhleSBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgICAgZi5wYWNrZWQgPVxuICAgICAgICAgICAgKF9kID0gZmllbGQucGFja2VkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAoZmllbGQua2luZCA9PSBcImVudW1cIiB8fFxuICAgICAgICAgICAgICAgIChmaWVsZC5raW5kID09IFwic2NhbGFyXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuVCAhPSBTY2FsYXJUeXBlLkJZVEVTICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLlQgIT0gU2NhbGFyVHlwZS5TVFJJTkcpKTtcbiAgICAgICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcbiAgICAgICAgLy8gZi5vcHRpb25zID0gZmllbGQub3B0aW9ucyA/PyBlbXB0eVJlYWRvbmx5T2JqZWN0O1xuICAgICAgICBpZiAoZmllbGQub25lb2YgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qgb29uYW1lID0gdHlwZW9mIGZpZWxkLm9uZW9mID09IFwic3RyaW5nXCIgPyBmaWVsZC5vbmVvZiA6IGZpZWxkLm9uZW9mLm5hbWU7XG4gICAgICAgICAgICBpZiAoIW8gfHwgby5uYW1lICE9IG9vbmFtZSkge1xuICAgICAgICAgICAgICAgIG8gPSBuZXcgSW50ZXJuYWxPbmVvZkluZm8ob29uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGYub25lb2YgPSBvO1xuICAgICAgICAgICAgby5hZGRGaWVsZChmKTtcbiAgICAgICAgfVxuICAgICAgICByLnB1c2goZik7XG4gICAgfVxuICAgIHJldHVybiByO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogTWV0aG9kS2luZCByZXByZXNlbnRzIHRoZSBmb3VyIG1ldGhvZCB0eXBlcyB0aGF0IGNhbiBiZSBkZWNsYXJlZCBpblxuICogcHJvdG9idWYgd2l0aCB0aGUgYHN0cmVhbWAga2V5d29yZDpcbiAqXG4gKiAxLiBVbmFyeTogICAgICAgICAgIHJwYyAoSW5wdXQpIHJldHVybnMgKE91dHB1dClcbiAqIDIuIFNlcnZlclN0cmVhbWluZzogcnBjIChJbnB1dCkgcmV0dXJucyAoc3RyZWFtIE91dHB1dClcbiAqIDMuIENsaWVudFN0cmVhbWluZzogcnBjIChzdHJlYW0gSW5wdXQpIHJldHVybnMgKE91dHB1dClcbiAqIDQuIEJpRGlTdHJlYW1pbmc6ICAgcnBjIChzdHJlYW0gSW5wdXQpIHJldHVybnMgKHN0cmVhbSBPdXRwdXQpXG4gKi9cbmV4cG9ydCB2YXIgTWV0aG9kS2luZDtcbihmdW5jdGlvbiAoTWV0aG9kS2luZCkge1xuICAgIE1ldGhvZEtpbmRbTWV0aG9kS2luZFtcIlVuYXJ5XCJdID0gMF0gPSBcIlVuYXJ5XCI7XG4gICAgTWV0aG9kS2luZFtNZXRob2RLaW5kW1wiU2VydmVyU3RyZWFtaW5nXCJdID0gMV0gPSBcIlNlcnZlclN0cmVhbWluZ1wiO1xuICAgIE1ldGhvZEtpbmRbTWV0aG9kS2luZFtcIkNsaWVudFN0cmVhbWluZ1wiXSA9IDJdID0gXCJDbGllbnRTdHJlYW1pbmdcIjtcbiAgICBNZXRob2RLaW5kW01ldGhvZEtpbmRbXCJCaURpU3RyZWFtaW5nXCJdID0gM10gPSBcIkJpRGlTdHJlYW1pbmdcIjtcbn0pKE1ldGhvZEtpbmQgfHwgKE1ldGhvZEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBJcyB0aGlzIG1ldGhvZCBzaWRlLWVmZmVjdC1mcmVlIChvciBzYWZlIGluIEhUVFAgcGFybGFuY2UpLCBvciBqdXN0XG4gKiBpZGVtcG90ZW50LCBvciBuZWl0aGVyPyBIVFRQIGJhc2VkIFJQQyBpbXBsZW1lbnRhdGlvbiBtYXkgY2hvb3NlIEdFVCB2ZXJiXG4gKiBmb3Igc2FmZSBtZXRob2RzLCBhbmQgUFVUIHZlcmIgZm9yIGlkZW1wb3RlbnQgbWV0aG9kcyBpbnN0ZWFkIG9mIHRoZVxuICogZGVmYXVsdCBQT1NULlxuICpcbiAqIFRoaXMgZW51bSBtYXRjaGVzIHRoZSBwcm90b2J1ZiBlbnVtIGdvb2dsZS5wcm90b2J1Zi5NZXRob2RPcHRpb25zLklkZW1wb3RlbmN5TGV2ZWwsXG4gKiBkZWZpbmVkIGluIHRoZSB3ZWxsLWtub3duIHR5cGUgZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IucHJvdG8sIGJ1dFxuICogZHJvcHMgVU5LTk9XTi5cbiAqL1xuZXhwb3J0IHZhciBNZXRob2RJZGVtcG90ZW5jeTtcbihmdW5jdGlvbiAoTWV0aG9kSWRlbXBvdGVuY3kpIHtcbiAgICAvKipcbiAgICAgKiBJZGVtcG90ZW50LCBubyBzaWRlIGVmZmVjdHMuXG4gICAgICovXG4gICAgTWV0aG9kSWRlbXBvdGVuY3lbTWV0aG9kSWRlbXBvdGVuY3lbXCJOb1NpZGVFZmZlY3RzXCJdID0gMV0gPSBcIk5vU2lkZUVmZmVjdHNcIjtcbiAgICAvKipcbiAgICAgKiBJZGVtcG90ZW50LCBidXQgbWF5IGhhdmUgc2lkZSBlZmZlY3RzLlxuICAgICAqL1xuICAgIE1ldGhvZElkZW1wb3RlbmN5W01ldGhvZElkZW1wb3RlbmN5W1wiSWRlbXBvdGVudFwiXSA9IDJdID0gXCJJZGVtcG90ZW50XCI7XG59KShNZXRob2RJZGVtcG90ZW5jeSB8fCAoTWV0aG9kSWRlbXBvdGVuY3kgPSB7fSkpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQ29ubmVjdCByZXByZXNlbnRzIGNhdGVnb3JpZXMgb2YgZXJyb3JzIGFzIGNvZGVzLCBhbmQgZWFjaCBjb2RlIG1hcHMgdG8gYVxuICogc3BlY2lmaWMgSFRUUCBzdGF0dXMgY29kZS4gVGhlIGNvZGVzIGFuZCB0aGVpciBzZW1hbnRpY3Mgd2VyZSBjaG9zZW4gdG9cbiAqIG1hdGNoIGdSUEMuIE9ubHkgdGhlIGNvZGVzIGJlbG93IGFyZSB2YWxpZCDigJQgdGhlcmUgYXJlIG5vIHVzZXItZGVmaW5lZFxuICogY29kZXMuXG4gKlxuICogU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGF0IGh0dHBzOi8vY29ubmVjdHJwYy5jb20vZG9jcy9wcm90b2NvbCNlcnJvci1jb2Rlc1xuICogZm9yIGRldGFpbHMuXG4gKi9cbmV4cG9ydCB2YXIgQ29kZTtcbihmdW5jdGlvbiAoQ29kZSkge1xuICAgIC8qKlxuICAgICAqIENhbmNlbGVkLCB1c3VhbGx5IGJlIHRoZSB1c2VyXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiQ2FuY2VsZWRcIl0gPSAxXSA9IFwiQ2FuY2VsZWRcIjtcbiAgICAvKipcbiAgICAgKiBVbmtub3duIGVycm9yXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiVW5rbm93blwiXSA9IDJdID0gXCJVbmtub3duXCI7XG4gICAgLyoqXG4gICAgICogQXJndW1lbnQgaW52YWxpZCByZWdhcmRsZXNzIG9mIHN5c3RlbSBzdGF0ZVxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIkludmFsaWRBcmd1bWVudFwiXSA9IDNdID0gXCJJbnZhbGlkQXJndW1lbnRcIjtcbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb24gZXhwaXJlZCwgbWF5IG9yIG1heSBub3QgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiRGVhZGxpbmVFeGNlZWRlZFwiXSA9IDRdID0gXCJEZWFkbGluZUV4Y2VlZGVkXCI7XG4gICAgLyoqXG4gICAgICogRW50aXR5IG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJOb3RGb3VuZFwiXSA9IDVdID0gXCJOb3RGb3VuZFwiO1xuICAgIC8qKlxuICAgICAqIEVudGl0eSBhbHJlYWR5IGV4aXN0cy5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJBbHJlYWR5RXhpc3RzXCJdID0gNl0gPSBcIkFscmVhZHlFeGlzdHNcIjtcbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb24gbm90IGF1dGhvcml6ZWQuXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiUGVybWlzc2lvbkRlbmllZFwiXSA9IDddID0gXCJQZXJtaXNzaW9uRGVuaWVkXCI7XG4gICAgLyoqXG4gICAgICogUXVvdGEgZXhoYXVzdGVkLlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIlJlc291cmNlRXhoYXVzdGVkXCJdID0gOF0gPSBcIlJlc291cmNlRXhoYXVzdGVkXCI7XG4gICAgLyoqXG4gICAgICogQXJndW1lbnQgaW52YWxpZCBpbiBjdXJyZW50IHN5c3RlbSBzdGF0ZS5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJGYWlsZWRQcmVjb25kaXRpb25cIl0gPSA5XSA9IFwiRmFpbGVkUHJlY29uZGl0aW9uXCI7XG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9uIGFib3J0ZWQuXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiQWJvcnRlZFwiXSA9IDEwXSA9IFwiQWJvcnRlZFwiO1xuICAgIC8qKlxuICAgICAqIE91dCBvZiBib3VuZHMsIHVzZSBpbnN0ZWFkIG9mIEZhaWxlZFByZWNvbmRpdGlvbi5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJPdXRPZlJhbmdlXCJdID0gMTFdID0gXCJPdXRPZlJhbmdlXCI7XG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9uIG5vdCBpbXBsZW1lbnRlZCBvciBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJVbmltcGxlbWVudGVkXCJdID0gMTJdID0gXCJVbmltcGxlbWVudGVkXCI7XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZXJyb3IsIHJlc2VydmVkIGZvciBcInNlcmlvdXMgZXJyb3JzXCIuXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiSW50ZXJuYWxcIl0gPSAxM10gPSBcIkludGVybmFsXCI7XG4gICAgLyoqXG4gICAgICogVW5hdmFpbGFibGUsIGNsaWVudCBzaG91bGQgYmFjayBvZmYgYW5kIHJldHJ5LlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIlVuYXZhaWxhYmxlXCJdID0gMTRdID0gXCJVbmF2YWlsYWJsZVwiO1xuICAgIC8qKlxuICAgICAqIFVucmVjb3ZlcmFibGUgZGF0YSBsb3NzIG9yIGNvcnJ1cHRpb24uXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiRGF0YUxvc3NcIl0gPSAxNV0gPSBcIkRhdGFMb3NzXCI7XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBpc24ndCBhdXRoZW50aWNhdGVkLlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIlVuYXV0aGVudGljYXRlZFwiXSA9IDE2XSA9IFwiVW5hdXRoZW50aWNhdGVkXCI7XG59KShDb2RlIHx8IChDb2RlID0ge30pKTtcbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4uL2NvZGUuanNcIjtcbi8qKlxuICogY29kZVRvU3RyaW5nIHJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIENvZGUuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2RlVG9TdHJpbmcodmFsdWUpIHtcbiAgICBjb25zdCBuYW1lID0gQ29kZVt2YWx1ZV07XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiAobmFtZVswXS50b0xvd2VyQ2FzZSgpICtcbiAgICAgICAgbmFtZS5zdWJzdHJpbmcoMSkucmVwbGFjZSgvW0EtWl0vZywgKGMpID0+IFwiX1wiICsgYy50b0xvd2VyQ2FzZSgpKSk7XG59XG5sZXQgc3RyaW5nVG9Db2RlO1xuLyoqXG4gKiBjb2RlRnJvbVN0cmluZyBwYXJzZXMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIENvZGUgaW4gc25ha2VfY2FzZS5cbiAqIEZvciBleGFtcGxlLCB0aGUgc3RyaW5nIFwicGVybWlzc2lvbl9kZW5pZWRcIiBwYXJzZXMgaW50byBDb2RlLlBlcm1pc3Npb25EZW5pZWQuXG4gKlxuICogSWYgdGhlIGdpdmVuIHN0cmluZyBjYW5ub3QgYmUgcGFyc2VkLCB0aGUgZnVuY3Rpb24gcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2RlRnJvbVN0cmluZyh2YWx1ZSkge1xuICAgIGlmICghc3RyaW5nVG9Db2RlKSB7XG4gICAgICAgIHN0cmluZ1RvQ29kZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIE9iamVjdC52YWx1ZXMoQ29kZSkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nVG9Db2RlW2NvZGVUb1N0cmluZyh2YWx1ZSldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ1RvQ29kZVt2YWx1ZV07XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgQ29kZSB9IGZyb20gXCIuL2NvZGUuanNcIjtcbmltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tIFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmXCI7XG5pbXBvcnQgeyBjb2RlVG9TdHJpbmcgfSBmcm9tIFwiLi9wcm90b2NvbC1jb25uZWN0L2NvZGUtc3RyaW5nLmpzXCI7XG4vKipcbiAqIENvbm5lY3RFcnJvciBjYXB0dXJlcyBmb3VyIHBpZWNlcyBvZiBpbmZvcm1hdGlvbjogYSBDb2RlLCBhbiBlcnJvclxuICogbWVzc2FnZSwgYW4gb3B0aW9uYWwgY2F1c2Ugb2YgdGhlIGVycm9yLCBhbmQgYW4gb3B0aW9uYWwgY29sbGVjdGlvbiBvZlxuICogYXJiaXRyYXJ5IFByb3RvYnVmIG1lc3NhZ2VzIGNhbGxlZCAgXCJkZXRhaWxzXCIuXG4gKlxuICogQmVjYXVzZSBkZXZlbG9wZXIgdG9vbHMgdHlwaWNhbGx5IHNob3cganVzdCB0aGUgZXJyb3IgbWVzc2FnZSwgd2UgcHJlZml4XG4gKiBpdCB3aXRoIHRoZSBzdGF0dXMgY29kZSwgc28gdGhhdCB0aGUgbW9zdCBpbXBvcnRhbnQgaW5mb3JtYXRpb24gaXMgYWx3YXlzXG4gKiB2aXNpYmxlIGltbWVkaWF0ZWx5LlxuICpcbiAqIEVycm9yIGRldGFpbHMgYXJlIHdyYXBwZWQgd2l0aCBnb29nbGUucHJvdG9idWYuQW55IG9uIHRoZSB3aXJlLCBzbyB0aGF0XG4gKiBhIHNlcnZlciBvciBtaWRkbGV3YXJlIGNhbiBhdHRhY2ggYXJiaXRyYXJ5IGRhdGEgdG8gYW4gZXJyb3IuIFVzZSB0aGVcbiAqIG1ldGhvZCBmaW5kRGV0YWlscygpIHRvIHJldHJpZXZlIHRoZSBkZXRhaWxzLlxuICovXG5leHBvcnQgY2xhc3MgQ29ubmVjdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBDb25uZWN0RXJyb3IuXG4gICAgICogSWYgbm8gY29kZSBpcyBwcm92aWRlZCwgY29kZSBcInVua25vd25cIiBpcyB1c2VkLlxuICAgICAqIE91dGdvaW5nIGRldGFpbHMgYXJlIG9ubHkgcmVsZXZhbnQgZm9yIHRoZSBzZXJ2ZXIgc2lkZSAtIGEgc2VydmljZSBtYXlcbiAgICAgKiByYWlzZSBhbiBlcnJvciB3aXRoIGRldGFpbHMsIGFuZCBpdCBpcyB1cCB0byB0aGUgcHJvdG9jb2wgaW1wbGVtZW50YXRpb25cbiAgICAgKiB0byBlbmNvZGUgYW5kIHNlbmQgdGhlIGRldGFpbHMgYWxvbmcgd2l0aCBlcnJvci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlID0gQ29kZS5Vbmtub3duLCBtZXRhZGF0YSwgb3V0Z29pbmdEZXRhaWxzLCBjYXVzZSkge1xuICAgICAgICBzdXBlcihjcmVhdGVNZXNzYWdlKG1lc3NhZ2UsIGNvZGUpKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJDb25uZWN0RXJyb3JcIjtcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL3JlbGVhc2Utbm90ZXMvdHlwZXNjcmlwdC0yLTIuaHRtbCNleGFtcGxlXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgICAgIHRoaXMucmF3TWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBuZXcgSGVhZGVycyhtZXRhZGF0YSAhPT0gbnVsbCAmJiBtZXRhZGF0YSAhPT0gdm9pZCAwID8gbWV0YWRhdGEgOiB7fSk7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IG91dGdvaW5nRGV0YWlscyAhPT0gbnVsbCAmJiBvdXRnb2luZ0RldGFpbHMgIT09IHZvaWQgMCA/IG91dGdvaW5nRGV0YWlscyA6IFtdO1xuICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYW55IHZhbHVlIC0gdHlwaWNhbGx5IGEgY2F1Z2h0IGVycm9yIGludG8gYSBDb25uZWN0RXJyb3IsXG4gICAgICogZm9sbG93aW5nIHRoZXNlIHJ1bGVzOlxuICAgICAqIC0gSWYgdGhlIHZhbHVlIGlzIGFscmVhZHkgYSBDb25uZWN0RXJyb3IsIHJldHVybiBpdCBhcyBpcy5cbiAgICAgKiAtIElmIHRoZSB2YWx1ZSBpcyBhbiBBYm9ydEVycm9yIGZyb20gdGhlIGZldGNoIEFQSSwgcmV0dXJuIHRoZSBtZXNzYWdlXG4gICAgICogICBvZiB0aGUgQWJvcnRFcnJvciB3aXRoIGNvZGUgQ2FuY2VsZWQuXG4gICAgICogLSBGb3Igb3RoZXIgRXJyb3JzLCByZXR1cm4gdGhlIGVycm9yIG1lc3NhZ2Ugd2l0aCBjb2RlIFVua25vd24gYnkgZGVmYXVsdC5cbiAgICAgKiAtIEZvciBvdGhlciB2YWx1ZXMsIHJldHVybiB0aGUgdmFsdWVzIFN0cmluZyByZXByZXNlbnRhdGlvbiBhcyBhIG1lc3NhZ2UsXG4gICAgICogICB3aXRoIHRoZSBjb2RlIFVua25vd24gYnkgZGVmYXVsdC5cbiAgICAgKiBUaGUgb3JpZ2luYWwgdmFsdWUgd2lsbCBiZSB1c2VkIGZvciB0aGUgXCJjYXVzZVwiIHByb3BlcnR5IGZvciB0aGUgbmV3XG4gICAgICogQ29ubmVjdEVycm9yLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHJlYXNvbiwgY29kZSA9IENvZGUuVW5rbm93bikge1xuICAgICAgICBpZiAocmVhc29uIGluc3RhbmNlb2YgQ29ubmVjdEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhc29uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgaWYgKHJlYXNvbi5uYW1lID09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggcmVxdWVzdHMgY2FuIG9ubHkgYmUgY2FuY2VsZWQgd2l0aCBhbiBBYm9ydENvbnRyb2xsZXIuXG4gICAgICAgICAgICAgICAgLy8gV2UgZGV0ZWN0IHRoYXQgY29uZGl0aW9uIGJ5IGxvb2tpbmcgYXQgdGhlIG5hbWUgb2YgdGhlIHJhaXNlZFxuICAgICAgICAgICAgICAgIC8vIGVycm9yIG9iamVjdCwgYW5kIHRyYW5zbGF0ZSB0byB0aGUgYXBwcm9wcmlhdGUgc3RhdHVzIGNvZGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25uZWN0RXJyb3IocmVhc29uLm1lc3NhZ2UsIENvZGUuQ2FuY2VsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25uZWN0RXJyb3IocmVhc29uLm1lc3NhZ2UsIGNvZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29ubmVjdEVycm9yKFN0cmluZyhyZWFzb24pLCBjb2RlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcmVhc29uKTtcbiAgICB9XG4gICAgZmluZERldGFpbHModHlwZU9yUmVnaXN0cnkpIHtcbiAgICAgICAgY29uc3QgcmVnaXN0cnkgPSBcInR5cGVOYW1lXCIgaW4gdHlwZU9yUmVnaXN0cnlcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGZpbmRNZXNzYWdlOiAodHlwZU5hbWUpID0+IHR5cGVOYW1lID09PSB0eXBlT3JSZWdpc3RyeS50eXBlTmFtZSA/IHR5cGVPclJlZ2lzdHJ5IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB0eXBlT3JSZWdpc3RyeTtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGRhdGEgb2YgdGhpcy5kZXRhaWxzKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0cnkuZmluZE1lc3NhZ2UoZGF0YS5nZXRUeXBlKCkudHlwZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gcmVnaXN0cnkuZmluZE1lc3NhZ2UoZGF0YS50eXBlKTtcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKHR5cGUuZnJvbUJpbmFyeShkYXRhLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNpbGVudGx5IGdpdmUgdXAgaWYgd2UgYXJlIHVuYWJsZSB0byBwYXJzZSB0aGUgZGV0YWlsLCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgYXBwZWFycyB0byBiZSB0aGUgbGVhc3Qgd29yc3QgYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IGlzIHZlcnkgdW5saWtlbHkgdGhhdCBhIHVzZXIgc3Vycm91bmRzIGEgY2F0Y2ggYm9keSBoYW5kbGluZyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3Igd2l0aCBhbm90aGVyIHRyeS1jYXRjaCBzdGF0ZW1lbnQsIGFuZCB3ZSBkbyBub3Qgd2FudCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyByZWNvbW1lbmQgZG9pbmcgc28uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGFuIGVycm9yIG1lc3NhZ2UsIHByZWZpeGluZyB0aGUgZ2l2ZW4gY29kZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZShtZXNzYWdlLCBjb2RlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UubGVuZ3RoXG4gICAgICAgID8gYFske2NvZGVUb1N0cmluZyhjb2RlKX1dICR7bWVzc2FnZX1gXG4gICAgICAgIDogYFske2NvZGVUb1N0cmluZyhjb2RlKX1dYDtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBNZXNzYWdlLCBwcm90b0Jhc2U2NCB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbmltcG9ydCB7IENvbm5lY3RFcnJvciB9IGZyb20gXCIuL2Nvbm5lY3QtZXJyb3IuanNcIjtcbmltcG9ydCB7IENvZGUgfSBmcm9tIFwiLi9jb2RlLmpzXCI7XG4vKipcbiAqIEVuY29kZSBhIHNpbmdsZSBiaW5hcnkgaGVhZGVyIHZhbHVlIGFjY29yZGluZyB0byB0aGUgQ29ubmVjdFxuICogYW5kIGdSUEMgc3BlY2lmaWNhdGlvbnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIHJhdyBiaW5hcnkgZGF0YSBmcm9tIGEgYnVmZmVyLCBhIHN0cmluZ1xuICogd2l0aCBVVEYtOCB0ZXh0LCBvciBhIHByb3RvYnVmIG1lc3NhZ2UuIEl0IGVuY29kZXMgdGhlIGlucHV0XG4gKiB3aXRoIHVucGFkZGVkIGJhc2U2NCBhbmQgcmV0dXJucyBhIHN0cmluZyB0aGF0IGNhbiBiZSB1c2VkIGZvclxuICogYSBoZWFkZXIgd2hvc2UgbmFtZSBlbmRzIHdpdGggYC1iaW5gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQmluYXJ5SGVhZGVyKHZhbHVlKSB7XG4gICAgbGV0IGJ5dGVzO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgYnl0ZXMgPSB2YWx1ZS50b0JpbmFyeSgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBieXRlcyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBieXRlcyA9IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSA/IHZhbHVlIDogbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdG9CYXNlNjQuZW5jKGJ5dGVzKS5yZXBsYWNlKC89KyQvLCBcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCaW5hcnlIZWFkZXIodmFsdWUsIHR5cGUsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBieXRlcyA9IHByb3RvQmFzZTY0LmRlYyh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IENvbm5lY3RFcnJvci5mcm9tKGUsIENvZGUuRGF0YUxvc3MpO1xuICAgIH1cbn1cbi8qKlxuICogTWVyZ2UgdHdvIG9yIG1vcmUgSGVhZGVycyBvYmplY3RzIGJ5IGFwcGVuZGluZyBhbGwgZmllbGRzIGZyb21cbiAqIGFsbCBpbnB1dHMgdG8gYSBuZXcgSGVhZGVycyBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRIZWFkZXJzKC4uLmhlYWRlcnMpIHtcbiAgICBjb25zdCBoID0gbmV3IEhlYWRlcnMoKTtcbiAgICBmb3IgKGNvbnN0IGUgb2YgaGVhZGVycykge1xuICAgICAgICBlLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGguYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGg7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBDcmVhdGUgYW55IGNsaWVudCBmb3IgdGhlIGdpdmVuIHNlcnZpY2UuXG4gKlxuICogVGhlIGdpdmVuIGNyZWF0ZU1ldGhvZCBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2ggbWV0aG9kIGRlZmluaXRpb25cbiAqIG9mIHRoZSBzZXJ2aWNlLiBUaGUgZnVuY3Rpb24gaXQgcmV0dXJucyBpcyBhZGRlZCB0byB0aGUgY2xpZW50IG9iamVjdFxuICogYXMgYSBtZXRob2QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQW55Q2xpZW50KHNlcnZpY2UsIGNyZWF0ZU1ldGhvZCkge1xuICAgIGNvbnN0IGNsaWVudCA9IHt9O1xuICAgIGZvciAoY29uc3QgW2xvY2FsTmFtZSwgbWV0aG9kSW5mb10gb2YgT2JqZWN0LmVudHJpZXMoc2VydmljZS5tZXRob2RzKSkge1xuICAgICAgICBjb25zdCBtZXRob2QgPSBjcmVhdGVNZXRob2QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtZXRob2RJbmZvKSwgeyBsb2NhbE5hbWUsXG4gICAgICAgICAgICBzZXJ2aWNlIH0pKTtcbiAgICAgICAgaWYgKG1ldGhvZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjbGllbnRbbG9jYWxOYW1lXSA9IG1ldGhvZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xpZW50O1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IENvbm5lY3RFcnJvciB9IGZyb20gXCIuLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4uL2NvZGUuanNcIjtcbmltcG9ydCB7IGNvbXByZXNzZWRGbGFnIH0gZnJvbSBcIi4vY29tcHJlc3Npb24uanNcIjtcbi8qKlxuICogQ3JlYXRlIGEgV0hBVFdHIFJlYWRhYmxlU3RyZWFtIG9mIGVudmVsb3BlZCBtZXNzYWdlcyBmcm9tIGEgUmVhZGFibGVTdHJlYW1cbiAqIG9mIGJ5dGVzLlxuICpcbiAqIElkZWFsbHksIHRoaXMgd291bGQgc2ltcGx5IGJlIGEgVHJhbnNmb3JtU3RyZWFtLCBidXQgUmVhZGFibGVTdHJlYW0ucGlwZVRocm91Z2hcbiAqIGRvZXMgbm90IGhhdmUgdGhlIG5lY2Vzc2FyeSBhdmFpbGFiaWxpdHkgYXQgdGhpcyB0aW1lLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW52ZWxvcGVSZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgICBsZXQgcmVhZGVyO1xuICAgIGxldCBidWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICBmdW5jdGlvbiBhcHBlbmQoY2h1bmspIHtcbiAgICAgICAgY29uc3QgbiA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICBuLnNldChidWZmZXIpO1xuICAgICAgICBuLnNldChjaHVuaywgYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIGJ1ZmZlciA9IG47XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICAgIHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBsZXQgaGVhZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXIgPT09IHVuZGVmaW5lZCAmJiBidWZmZXIuYnl0ZUxlbmd0aCA+PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCA8PCA4KSArIGJ1ZmZlcltpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSB7IGZsYWdzOiBidWZmZXJbMF0sIGxlbmd0aCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyICE9PSB1bmRlZmluZWQgJiYgYnVmZmVyLmJ5dGVMZW5ndGggPj0gaGVhZGVyLmxlbmd0aCArIDUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcHBlbmQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBDb25uZWN0RXJyb3IoXCJwcmVtYXR1cmUgZW5kIG9mIHN0cmVhbVwiLCBDb2RlLkRhdGFMb3NzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlci5zdWJhcnJheSg1LCA1ICsgaGVhZGVyLmxlbmd0aCk7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc3ViYXJyYXkoNSArIGhlYWRlci5sZW5ndGgpO1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICBmbGFnczogaGVhZGVyLmZsYWdzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQ29tcHJlc3MgYW4gRW52ZWxvcGVkTWVzc2FnZS5cbiAqXG4gKiBSYWlzZXMgSW50ZXJuYWwgaWYgYW4gZW52ZWxvcGVkIG1lc3NhZ2UgaXMgYWxyZWFkeSBjb21wcmVzc2VkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW52ZWxvcGVDb21wcmVzcyhlbnZlbG9wZSwgY29tcHJlc3Npb24sIGNvbXByZXNzTWluQnl0ZXMpIHtcbiAgICBsZXQgeyBmbGFncywgZGF0YSB9ID0gZW52ZWxvcGU7XG4gICAgaWYgKChmbGFncyAmIGNvbXByZXNzZWRGbGFnKSA9PT0gY29tcHJlc3NlZEZsYWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihcImludmFsaWQgZW52ZWxvcGUsIGFscmVhZHkgY29tcHJlc3NlZFwiLCBDb2RlLkludGVybmFsKTtcbiAgICB9XG4gICAgaWYgKGNvbXByZXNzaW9uICYmIGRhdGEuYnl0ZUxlbmd0aCA+PSBjb21wcmVzc01pbkJ5dGVzKSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCBjb21wcmVzc2lvbi5jb21wcmVzcyhkYXRhKTtcbiAgICAgICAgZmxhZ3MgPSBmbGFncyB8IGNvbXByZXNzZWRGbGFnO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhLCBmbGFncyB9O1xufVxuLyoqXG4gKiBEZWNvbXByZXNzIGFuIEVudmVsb3BlZE1lc3NhZ2UuXG4gKlxuICogUmFpc2VzIEludmFsaWRBcmd1bWVudCBpZiBhbiBlbnZlbG9wZSBpcyBjb21wcmVzc2VkLCBidXQgY29tcHJlc3Npb24gaXMgbnVsbC5cbiAqXG4gKiBSZWxpZXMgb24gdGhlIHByb3ZpZGVkIENvbXByZXNzaW9uIHRvIHJhaXNlIFJlc291cmNlRXhoYXVzdGVkIGlmIHRoZVxuICogKmRlY29tcHJlc3NlZCogbWVzc2FnZSBzaXplIGlzIGxhcmdlciB0aGFuIHJlYWRNYXhCeXRlcy4gSWYgdGhlIGVudmVsb3BlIGlzXG4gKiBub3QgY29tcHJlc3NlZCwgcmVhZE1heEJ5dGVzIGlzIG5vdCBob25vcmVkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW52ZWxvcGVEZWNvbXByZXNzKGVudmVsb3BlLCBjb21wcmVzc2lvbiwgcmVhZE1heEJ5dGVzKSB7XG4gICAgbGV0IHsgZmxhZ3MsIGRhdGEgfSA9IGVudmVsb3BlO1xuICAgIGlmICgoZmxhZ3MgJiBjb21wcmVzc2VkRmxhZykgPT09IGNvbXByZXNzZWRGbGFnKSB7XG4gICAgICAgIGlmICghY29tcHJlc3Npb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoXCJyZWNlaXZlZCBjb21wcmVzc2VkIGVudmVsb3BlLCBidXQgZG8gbm90IGtub3cgaG93IHRvIGRlY29tcHJlc3NcIiwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBhd2FpdCBjb21wcmVzc2lvbi5kZWNvbXByZXNzKGRhdGEsIHJlYWRNYXhCeXRlcyk7XG4gICAgICAgIGZsYWdzID0gZmxhZ3MgXiBjb21wcmVzc2VkRmxhZztcbiAgICB9XG4gICAgcmV0dXJuIHsgZGF0YSwgZmxhZ3MgfTtcbn1cbi8qKlxuICogRW5jb2RlIGEgc2luZ2xlIGVudmVsb3BlZCBtZXNzYWdlLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlRW52ZWxvcGUoZmxhZ3MsIGRhdGEpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgNSk7XG4gICAgYnl0ZXMuc2V0KGRhdGEsIDUpO1xuICAgIGNvbnN0IHYgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICB2LnNldFVpbnQ4KDAsIGZsYWdzKTsgLy8gZmlyc3QgYnl0ZSBpcyBmbGFnc1xuICAgIHYuc2V0VWludDMyKDEsIGRhdGEubGVuZ3RoKTsgLy8gNCBieXRlcyBtZXNzYWdlIGxlbmd0aFxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogRW5jb2RlIGEgc2V0IG9mIGVudmVsb3BlZCBtZXNzYWdlcy5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUVudmVsb3BlcyguLi5lbnZlbG9wZXMpIHtcbiAgICBjb25zdCBsZW4gPSBlbnZlbG9wZXMucmVkdWNlKChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpID0+IHByZXZpb3VzVmFsdWUgKyBjdXJyZW50VmFsdWUuZGF0YS5sZW5ndGggKyA1LCAwKTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgZSBvZiBlbnZlbG9wZXMpIHtcbiAgICAgICAgdi5zZXRVaW50OChvZmZzZXQsIGUuZmxhZ3MpOyAvLyBmaXJzdCBieXRlIGlzIGZsYWdzXG4gICAgICAgIHYuc2V0VWludDMyKG9mZnNldCArIDEsIGUuZGF0YS5sZW5ndGgpOyAvLyA0IGJ5dGVzIG1lc3NhZ2UgbGVuZ3RoXG4gICAgICAgIGJ5dGVzLnNldChlLmRhdGEsIG9mZnNldCArIDUpO1xuICAgICAgICBvZmZzZXQgKz0gZS5kYXRhLmxlbmd0aCArIDU7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19hc3luY1ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX19hc3luY1ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XG59O1xudmFyIF9fYXdhaXQgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXQpIHx8IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpOyB9XG52YXIgX19hc3luY0dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19hc3luY0dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufTtcbnZhciBfX2FzeW5jRGVsZWdhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jRGVsZWdhdG9yKSB8fCBmdW5jdGlvbiAobykge1xuICAgIHZhciBpLCBwO1xuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cbn07XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4uL2NvZGUuanNcIjtcbmltcG9ydCB7IENvbm5lY3RFcnJvciB9IGZyb20gXCIuLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBlbmNvZGVFbnZlbG9wZSwgZW52ZWxvcGVDb21wcmVzcywgZW52ZWxvcGVEZWNvbXByZXNzLCB9IGZyb20gXCIuL2VudmVsb3BlLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRSZWFkTWF4Qnl0ZXMgfSBmcm9tIFwiLi9saW1pdC1pby5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBpcGVUbyhzb3VyY2UsIC4uLnJlc3QpIHtcbiAgICBjb25zdCBbdHJhbnNmb3Jtcywgc2luaywgb3B0XSA9IHBpY2tUcmFuc2Zvcm1zQW5kU2luayhyZXN0KTtcbiAgICBsZXQgaXRlcmFibGUgPSBzb3VyY2U7XG4gICAgbGV0IGFib3J0YWJsZTtcbiAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5wcm9wYWdhdGVEb3duU3RyZWFtRXJyb3IpID09PSB0cnVlKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYWJvcnRhYmxlID0gbWFrZUl0ZXJhYmxlQWJvcnRhYmxlKGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpdGVyYWJsZSA9IHBpcGUoaXRlcmFibGUsIC4uLnRyYW5zZm9ybXMsIHsgcHJvcGFnYXRlRG93blN0cmVhbUVycm9yOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gc2luayhpdGVyYWJsZSkuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICBpZiAoYWJvcnRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJvcnRhYmxlLmFib3J0KHJlYXNvbikudGhlbigoKSA9PiBQcm9taXNlLnJlamVjdChyZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgICB9KTtcbn1cbi8vIHBpY2sgdHJhbnNmb3JtcywgdGhlIHNpbmssIGFuZCBvcHRpb25zIGZyb20gdGhlIHBpcGVUbygpIHJlc3QgcGFyYW1ldGVyXG5mdW5jdGlvbiBwaWNrVHJhbnNmb3Jtc0FuZFNpbmsocmVzdCkge1xuICAgIGxldCBvcHQ7XG4gICAgaWYgKHR5cGVvZiByZXN0W3Jlc3QubGVuZ3RoIC0gMV0gIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdCA9IHJlc3QucG9wKCk7XG4gICAgfVxuICAgIGNvbnN0IHNpbmsgPSByZXN0LnBvcCgpO1xuICAgIHJldHVybiBbcmVzdCwgc2luaywgb3B0XTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBBc3luY0l0ZXJhYmxlU2luayB0aGF0IGNvbmNhdGVuYXRlcyBhbGwgZWxlbWVudHMgZnJvbSB0aGUgaW5wdXQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW5rQWxsKCkge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgICAgY29uc3QgYWxsID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhYmxlXzEgPSBfX2FzeW5jVmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfMV8xOyBpdGVyYWJsZV8xXzEgPSBhd2FpdCBpdGVyYWJsZV8xLm5leHQoKSwgX2EgPSBpdGVyYWJsZV8xXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgYWxsLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV8xLnJldHVybikpIGF3YWl0IF9iLmNhbGwoaXRlcmFibGVfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsbDtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIEFzeW5jSXRlcmFibGVTaW5rIHRoYXQgY29uY2F0ZW5hdGVzIGFsbCBjaHVua3MgZnJvbSB0aGUgaW5wdXQgaW50b1xuICogYSBzaW5nbGUgVWludDhBcnJheS5cbiAqXG4gKiBUaGUgaXRlcmFibGUgcmFpc2VzIGFuIGVycm9yIGlmIHRoZSBtb3JlIHRoYW4gcmVhZE1heEJ5dGVzIGFyZSByZWFkLlxuICpcbiAqIEFuIG9wdGlvbmFsIGxlbmd0aCBoaW50IGNhbiBiZSBwcm92aWRlZCB0byBvcHRpbWl6ZSBhbGxvY2F0aW9uIGFuZCB2YWxpZGF0aW9uLlxuICogSWYgbW9yZSBvciBsZXNzIGJ5dGVzIGFyZSBwcmVzZW50IGluIHRoZSBzb3VyY2UgdGhhdCB0aGUgbGVuZ3RoIGhpbnQgaW5kaWNhdGVzLFxuICogYW5kIGVycm9yIGlzIHJhaXNlZC5cbiAqIElmIHRoZSBsZW5ndGggaGludCBpcyBsYXJnZXIgdGhhbiByZWFkTWF4Qnl0ZXMsIGFuIGVycm9yIGlzIHJhaXNlZC5cbiAqIElmIHRoZSBsZW5ndGggaGludCBpcyBub3QgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBpdCBpcyBpZ25vcmVkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lua0FsbEJ5dGVzKHJlYWRNYXhCeXRlcywgbGVuZ3RoSGludCkge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlYWRBbGxCeXRlcyhpdGVyYWJsZSwgcmVhZE1heEJ5dGVzLCBsZW5ndGhIaW50KTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBpcGUoc291cmNlLCAuLi5yZXN0KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIHBpcGVfMSgpIHtcbiAgICAgICAgY29uc3QgW3RyYW5zZm9ybXMsIG9wdF0gPSBwaWNrVHJhbnNmb3JtcyhyZXN0KTtcbiAgICAgICAgbGV0IGFib3J0YWJsZTtcbiAgICAgICAgY29uc3Qgc291cmNlSXQgPSBzb3VyY2VbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgIGNvbnN0IGNhY2hlZFNvdXJjZSA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZUl0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGl0ZXJhYmxlID0gY2FjaGVkU291cmNlO1xuICAgICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5wcm9wYWdhdGVEb3duU3RyZWFtRXJyb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpdGVyYWJsZSA9IGFib3J0YWJsZSA9IG1ha2VJdGVyYWJsZUFib3J0YWJsZShpdGVyYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gdChpdGVyYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXQgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0geWllbGQgX19hd2FpdChpdC5uZXh0KCkpO1xuICAgICAgICAgICAgICAgIGlmIChyLmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYWJvcnRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHIudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBfX2F3YWl0KGFib3J0YWJsZS5hYm9ydChlKSk7IC8vIHByb3BhZ2F0ZSBkb3duc3RyZWFtIGVycm9yIHRvIHRoZSBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5wcm9wYWdhdGVEb3duU3RyZWFtRXJyb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCByZXR1cm4gb24gdGhlIHNvdXJjZSBpdGVyYWJsZSB0byBpbmRpY2F0ZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2Ugd2lsbCBubyBsb25nZXIgY29uc3VtZSBpdCBhbmQgaXQgc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gY2xlYW51cCBhbnkgYWxsb2NhdGVkIHJlc291cmNlcy5cbiAgICAgICAgICAgICAgICAoX2EgPSBzb3VyY2VJdC5yZXR1cm4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHNvdXJjZUl0KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiByZXR1cm5zIGEgcHJvbWlzZSwgd2hpY2ggd2UgZG9uJ3QgY2FyZSBhYm91dC5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVW5jYXVnaHQgcHJvbWlzZXMgYXJlIHRocm93biBhdCBzb21ldGltZS9zb21ld2hlcmUgYnkgdGhlIGV2ZW50IGxvb3AsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gZW5zdXJlIGVycm9yIGlzIGNhdWdodCBhbmQgaWdub3JlZC5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcGlja1RyYW5zZm9ybXMocmVzdCkge1xuICAgIGxldCBvcHQ7XG4gICAgaWYgKHR5cGVvZiByZXN0W3Jlc3QubGVuZ3RoIC0gMV0gIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdCA9IHJlc3QucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBbcmVzdCwgb3B0XTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBBc3luY0l0ZXJhYmxlVHJhbnNmb3JtIHRoYXQgY2F0Y2hlcyBhbnkgZXJyb3IgZnJvbSB0aGUgaW5wdXQsIGFuZFxuICogcGFzc2VzIGl0IHRvIHRoZSBnaXZlbiBjYXRjaEVycm9yIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBjYXRjaEVycm9yIGZ1bmN0aW9uIG1heSByZXR1cm4gYSBmaW5hbCB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUNhdGNoKGNhdGNoRXJyb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHdlIGRlbGliZXJhdGUgYXZvaWQgYSBmb3ItYXdhaXQgbG9vcCBiZWNhdXNlIHdlIG9ubHkgd2FudCB0byBjYXRjaCB1cHN0cmVhbVxuICAgICAgICAgICAgLy8gZXJyb3JzLCBub3QgZG93bnN0cmVhbSBlcnJvcnMgKHlpZWxkKS5cbiAgICAgICAgICAgIGNvbnN0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IHI7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHlpZWxkIF9fYXdhaXQoaXQubmV4dCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2F1Z2h0ID0geWllbGQgX19hd2FpdChjYXRjaEVycm9yKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhdWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGNhdWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyLmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoci52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gQXN5bmNJdGVyYWJsZVRyYW5zZm9ybSB0aGF0IGNhdGNoZXMgYW55IGVycm9yIGZyb20gdGhlIGlucHV0LCBhbmRcbiAqIHBhc3NlcyBpdCB0byB0aGUgZ2l2ZW4gZnVuY3Rpb24uIFVubGlrZSB0cmFuc2Zvcm1DYXRjaCgpLCB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAqIGlzIGFsc28gY2FsbGVkIHdoZW4gbm8gZXJyb3IgaXMgcmFpc2VkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtQ2F0Y2hGaW5hbGx5KGNhdGNoRmluYWxseSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gd2UgZGVsaWJlcmF0ZSBhdm9pZCBhIGZvci1hd2FpdCBsb29wIGJlY2F1c2Ugd2Ugb25seSB3YW50IHRvIGNhdGNoIHVwc3RyZWFtXG4gICAgICAgICAgICAvLyBlcnJvcnMsIG5vdCBkb3duc3RyZWFtIGVycm9ycyAoeWllbGQpLlxuICAgICAgICAgICAgbGV0IGVycjtcbiAgICAgICAgICAgIGNvbnN0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IHI7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHlpZWxkIF9fYXdhaXQoaXQubmV4dCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyLmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoci52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYXVnaHQgPSB5aWVsZCBfX2F3YWl0KGNhdGNoRmluYWxseShlcnIpKTtcbiAgICAgICAgICAgIGlmIChjYXVnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoY2F1Z2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBBc3luY0l0ZXJhYmxlVHJhbnNmb3JtIHRoYXQgYXBwZW5kcyBhIHZhbHVlLlxuICpcbiAqIFRoZSBlbGVtZW50IHRvIGFwcGVuZCBpcyBwcm92aWRlZCBieSBhIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICogdW5kZWZpbmVkLCBubyBlbGVtZW50IGlzIGFwcGVuZGVkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtQXBwZW5kKHByb3ZpZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZV8yLCBfYiwgX2M7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmFibGVfMiA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV8yXzE7IGl0ZXJhYmxlXzJfMSA9IHlpZWxkIF9fYXdhaXQoaXRlcmFibGVfMi5uZXh0KCkpLCBfYSA9IGl0ZXJhYmxlXzJfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzIucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGl0ZXJhYmxlXzIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBwZW5kID0geWllbGQgX19hd2FpdChwcm92aWRlKCkpO1xuICAgICAgICAgICAgaWYgKGFwcGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChhcHBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIEFzeW5jSXRlcmFibGVUcmFuc2Zvcm0gdGhhdCBwcmVwZW5kcyBhbiBlbGVtZW50LlxuICpcbiAqIFRoZSBlbGVtZW50IHRvIHByZXBlbmQgaXMgcHJvdmlkZWQgYnkgYSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnNcbiAqIHVuZGVmaW5lZCwgbm8gZWxlbWVudCBpcyBhcHBlbmRlZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVByZXBlbmQocHJvdmlkZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBlXzMsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHByZXBlbmQgPSB5aWVsZCBfX2F3YWl0KHByb3ZpZGUoKSk7XG4gICAgICAgICAgICBpZiAocHJlcGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChwcmVwZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV8zID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzNfMTsgaXRlcmFibGVfM18xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV8zLm5leHQoKSksIF9hID0gaXRlcmFibGVfM18xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfM18xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGNodW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gaXRlcmFibGVfMy5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoaXRlcmFibGVfMykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gQXN5bmNJdGVyYWJsZVRyYW5zZm9ybSB0aGF0IHJlYWRzIGFsbCBieXRlcyBmcm9tIHRoZSBpbnB1dCwgYW5kXG4gKiBjb25jYXRlbmF0ZXMgdGhlbSB0byBhIHNpbmdsZSBVaW50OEFycmF5LlxuICpcbiAqIFRoZSBpdGVyYWJsZSByYWlzZXMgYW4gZXJyb3IgaWYgdGhlIG1vcmUgdGhhbiByZWFkTWF4Qnl0ZXMgYXJlIHJlYWQuXG4gKlxuICogQW4gb3B0aW9uYWwgbGVuZ3RoIGhpbnQgY2FuIGJlIHByb3ZpZGVkIHRvIG9wdGltaXplIGFsbG9jYXRpb24gYW5kIHZhbGlkYXRpb24uXG4gKiBJZiBtb3JlIG9yIGxlc3MgYnl0ZXMgYXJlIHByZXNlbnQgaW4gdGhlIHNvdXJjZSB0aGF0IHRoZSBsZW5ndGggaGludCBpbmRpY2F0ZXMsXG4gKiBhbmQgZXJyb3IgaXMgcmFpc2VkLlxuICogSWYgdGhlIGxlbmd0aCBoaW50IGlzIGxhcmdlciB0aGFuIHJlYWRNYXhCeXRlcywgYW4gZXJyb3IgaXMgcmFpc2VkLlxuICogSWYgdGhlIGxlbmd0aCBoaW50IGlzIG5vdCBhIHBvc2l0aXZlIGludGVnZXIsIGl0IGlzIGlnbm9yZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1SZWFkQWxsQnl0ZXMocmVhZE1heEJ5dGVzLCBsZW5ndGhIaW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHlpZWxkIF9fYXdhaXQocmVhZEFsbEJ5dGVzKGl0ZXJhYmxlLCByZWFkTWF4Qnl0ZXMsIGxlbmd0aEhpbnQpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtU2VyaWFsaXplRW52ZWxvcGUoc2VyaWFsaXphdGlvbiwgZW5kU3RyZWFtRmxhZywgZW5kU2VyaWFsaXphdGlvbikge1xuICAgIGlmIChlbmRTdHJlYW1GbGFnID09PSB1bmRlZmluZWQgfHwgZW5kU2VyaWFsaXphdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIGVfNCwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmFibGVfNCA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV80XzE7IGl0ZXJhYmxlXzRfMSA9IHlpZWxkIF9fYXdhaXQoaXRlcmFibGVfNC5uZXh0KCkpLCBfYSA9IGl0ZXJhYmxlXzRfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBpdGVyYWJsZV80XzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBzZXJpYWxpemF0aW9uLnNlcmlhbGl6ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHsgZmxhZ3M6IDAsIGRhdGEgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzQucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGl0ZXJhYmxlXzQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBlXzUsIF9iLCBfYztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV81ID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzVfMTsgaXRlcmFibGVfNV8xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV81Lm5leHQoKSksIF9hID0gaXRlcmFibGVfNV8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfNV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZsYWdzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgPSBmbGFncyB8IGVuZFN0cmVhbUZsYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZW5kU2VyaWFsaXphdGlvbi5zZXJpYWxpemUoY2h1bmsudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHNlcmlhbGl6YXRpb24uc2VyaWFsaXplKGNodW5rLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHsgZmxhZ3MsIGRhdGEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfNV8xKSB7IGVfNSA9IHsgZXJyb3I6IGVfNV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzUucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGl0ZXJhYmxlXzUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVBhcnNlRW52ZWxvcGUoc2VyaWFsaXphdGlvbiwgZW5kU3RyZWFtRmxhZywgZW5kU2VyaWFsaXphdGlvbikge1xuICAgIC8vIGNvZGUgcGF0aCBhbHdheXMgeWllbGRzIFBhcnNlZEVudmVsb3BlZE1lc3NhZ2U8VCwgRT5cbiAgICBpZiAoZW5kU2VyaWFsaXphdGlvbiAmJiBlbmRTdHJlYW1GbGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgZV82LCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV82ID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzZfMTsgaXRlcmFibGVfNl8xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV82Lm5leHQoKSksIF9hID0gaXRlcmFibGVfNl8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzZfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZsYWdzLCBkYXRhIH0gPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiBlbmRTdHJlYW1GbGFnKSA9PT0gZW5kU3RyZWFtRmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoeyB2YWx1ZTogZW5kU2VyaWFsaXphdGlvbi5wYXJzZShkYXRhKSwgZW5kOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh7IHZhbHVlOiBzZXJpYWxpemF0aW9uLnBhcnNlKGRhdGEpLCBlbmQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzZfMSkgeyBlXzYgPSB7IGVycm9yOiBlXzZfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV82LnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV82KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzYpIHRocm93IGVfNi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBjb2RlIHBhdGggYWx3YXlzIHlpZWxkcyBUXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGVfNywgX2IsIF9jO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhYmxlXzcgPSBfX2FzeW5jVmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfN18xOyBpdGVyYWJsZV83XzEgPSB5aWVsZCBfX2F3YWl0KGl0ZXJhYmxlXzcubmV4dCgpKSwgX2EgPSBpdGVyYWJsZV83XzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBpdGVyYWJsZV83XzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmxhZ3MsIGRhdGEgfSA9IF9jO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kU3RyZWFtRmxhZyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZmxhZ3MgJiBlbmRTdHJlYW1GbGFnKSA9PT0gZW5kU3RyZWFtRmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZFNlcmlhbGl6YXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKFwidW5leHBlY3RlZCBlbmQgZmxhZ1wiLCBDb2RlLkludmFsaWRBcmd1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBza2lwcyBlbmQtb2Ytc3RyZWFtIGVudmVsb3BlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHNlcmlhbGl6YXRpb24ucGFyc2UoZGF0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzdfMSkgeyBlXzcgPSB7IGVycm9yOiBlXzdfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV83LnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV83KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV83KSB0aHJvdyBlXzcuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBBc3luY0l0ZXJhYmxlVHJhbnNmb3JtIHRoYXQgdGFrZXMgZW52ZWxvcGVkIG1lc3NhZ2VzIGFzIGEgc291cmNlLFxuICogYW5kIGNvbXByZXNzZXMgdGhlbSBpZiB0aGV5IGFyZSBsYXJnZXIgdGhhbiBjb21wcmVzc01pbkJ5dGVzLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtQ29tcHJlc3NFbnZlbG9wZShjb21wcmVzc2lvbiwgY29tcHJlc3NNaW5CeXRlcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBlXzgsIF9iLCBfYztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV84ID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzhfMTsgaXRlcmFibGVfOF8xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV84Lm5leHQoKSksIF9hID0gaXRlcmFibGVfOF8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfOF8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnYgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh5aWVsZCBfX2F3YWl0KGVudmVsb3BlQ29tcHJlc3MoZW52LCBjb21wcmVzc2lvbiwgY29tcHJlc3NNaW5CeXRlcykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV84XzEpIHsgZV84ID0geyBlcnJvcjogZV84XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gaXRlcmFibGVfOC5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoaXRlcmFibGVfOCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfOCkgdGhyb3cgZV84LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gQXN5bmNJdGVyYWJsZVRyYW5zZm9ybSB0aGF0IHRha2VzIGVudmVsb3BlZCBtZXNzYWdlcyBhcyBhIHNvdXJjZSxcbiAqIGFuZCBkZWNvbXByZXNzZXMgdGhlbSB1c2luZyB0aGUgZ2l2ZW4gY29tcHJlc3Npb24uXG4gKlxuICogVGhlIGl0ZXJhYmxlIHJhaXNlcyBhbiBlcnJvciBpZiB0aGUgZGVjb21wcmVzc2VkIHBheWxvYWQgb2YgYW4gZW52ZWxvcGVkXG4gKiBtZXNzYWdlIGlzIGxhcmdlciB0aGFuIHJlYWRNYXhCeXRlcywgb3IgaWYgbm8gY29tcHJlc3Npb24gaXMgcHJvdmlkZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1EZWNvbXByZXNzRW52ZWxvcGUoY29tcHJlc3Npb24sIHJlYWRNYXhCeXRlcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBlXzksIF9iLCBfYztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV85ID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzlfMTsgaXRlcmFibGVfOV8xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV85Lm5leHQoKSksIF9hID0gaXRlcmFibGVfOV8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfOV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnYgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh5aWVsZCBfX2F3YWl0KGVudmVsb3BlRGVjb21wcmVzcyhlbnYsIGNvbXByZXNzaW9uLCByZWFkTWF4Qnl0ZXMpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfOV8xKSB7IGVfOSA9IHsgZXJyb3I6IGVfOV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzkucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGl0ZXJhYmxlXzkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzkpIHRocm93IGVfOS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gQXN5bmNJdGVyYWJsZVRyYW5zZm9ybSB0aGF0IHRha2VzIGVudmVsb3BlZCBtZXNzYWdlcyBhcyBhIHNvdXJjZSxcbiAqIGFuZCBqb2lucyB0aGVtIGludG8gYSBzdHJlYW0gb2YgcmF3IGJ5dGVzLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtSm9pbkVudmVsb3BlcygpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZV8xMCwgX2IsIF9jO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhYmxlXzEwID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzEwXzE7IGl0ZXJhYmxlXzEwXzEgPSB5aWVsZCBfX2F3YWl0KGl0ZXJhYmxlXzEwLm5leHQoKSksIF9hID0gaXRlcmFibGVfMTBfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzEwXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmxhZ3MsIGRhdGEgfSA9IF9jO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGVuY29kZUVudmVsb3BlKGZsYWdzLCBkYXRhKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMTBfMSkgeyBlXzEwID0geyBlcnJvcjogZV8xMF8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzEwLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV8xMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTApIHRocm93IGVfMTAuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIEFzeW5jSXRlcmFibGVUcmFuc2Zvcm0gdGhhdCB0YWtlcyByYXcgYnl0ZXMgYXMgYSBzb3VyY2UsIGFuZCBzcGxpdHNcbiAqIHRoZW0gaW50byBlbnZlbG9wZWQgbWVzc2FnZXMuXG4gKlxuICogVGhlIGl0ZXJhYmxlIHJhaXNlcyBhbiBlcnJvclxuICogLSBpZiB0aGUgcGF5bG9hZCBvZiBhbiBlbnZlbG9wZWQgbWVzc2FnZSBpcyBsYXJnZXIgdGhhbiByZWFkTWF4Qnl0ZXMsXG4gKiAtIGlmIHRoZSBzdHJlYW0gZW5kZWQgYmVmb3JlIGFuIGVudmVsb3BlZCBtZXNzYWdlIGZ1bGx5IGFycml2ZWQsXG4gKiAtIG9yIGlmIHRoZSBzdHJlYW0gZW5kZWQgd2l0aCBleHRyYW5lb3VzIGRhdGEuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1TcGxpdEVudmVsb3BlKHJlYWRNYXhCeXRlcykge1xuICAgIC8vIGFwcGVuZCBjaHVuayB0byBidWZmZXIsIHJldHVybmluZyB1cGRhdGVkIGJ1ZmZlclxuICAgIGZ1bmN0aW9uIGFwcGVuZChidWZmZXIsIGNodW5rKSB7XG4gICAgICAgIGNvbnN0IG4gPSBuZXcgVWludDhBcnJheShidWZmZXIuYnl0ZUxlbmd0aCArIGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICBuLnNldChidWZmZXIpO1xuICAgICAgICBuLnNldChjaHVuaywgYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICAvLyB0dXBsZSAwOiBlbnZlbG9wZSwgb3IgdW5kZWZpbmVkIGlmIGluY29tcGxldGVcbiAgICAvLyB0dXBsZSAxOiByZW1haW5kZXIgb2YgdGhlIGJ1ZmZlclxuICAgIGZ1bmN0aW9uIHNoaWZ0RW52ZWxvcGUoYnVmZmVyLCBoZWFkZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoIDwgNSArIGhlYWRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCBidWZmZXJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IGZsYWdzOiBoZWFkZXIuZmxhZ3MsIGRhdGE6IGJ1ZmZlci5zdWJhcnJheSg1LCA1ICsgaGVhZGVyLmxlbmd0aCkgfSxcbiAgICAgICAgICAgIGJ1ZmZlci5zdWJhcnJheSg1ICsgaGVhZGVyLmxlbmd0aCksXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8vIHVuZGVmaW5lZDogaGVhZGVyIGlzIGluY29tcGxldGVcbiAgICBmdW5jdGlvbiBwZWVrSGVhZGVyKGJ1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPCA1KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLmJ1ZmZlciwgYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdmlldy5nZXRVaW50MzIoMSk7IC8vIDQgYnl0ZXMgbWVzc2FnZSBsZW5ndGhcbiAgICAgICAgY29uc3QgZmxhZ3MgPSB2aWV3LmdldFVpbnQ4KDApOyAvLyBmaXJzdCBieXRlIGlzIGZsYWdzXG4gICAgICAgIHJldHVybiB7IGxlbmd0aCwgZmxhZ3MgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGVfMTEsIF9iLCBfYztcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV8xMSA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV8xMV8xOyBpdGVyYWJsZV8xMV8xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV8xMS5uZXh0KCkpLCBfYSA9IGl0ZXJhYmxlXzExXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBpdGVyYWJsZV8xMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBhcHBlbmQoYnVmZmVyLCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IHBlZWtIZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRSZWFkTWF4Qnl0ZXMocmVhZE1heEJ5dGVzLCBoZWFkZXIubGVuZ3RoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbnY7XG4gICAgICAgICAgICAgICAgICAgICAgICBbZW52LCBidWZmZXJdID0gc2hpZnRFbnZlbG9wZShidWZmZXIsIGhlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVudikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChlbnYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMTFfMSkgeyBlXzExID0geyBlcnJvcjogZV8xMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzExLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV8xMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTEpIHRocm93IGVfMTEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBwZWVrSGVhZGVyKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBcInByb3RvY29sIGVycm9yOiBpbmNvbXBsZXRlIGVudmVsb3BlXCI7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYHByb3RvY29sIGVycm9yOiBwcm9taXNlZCAke2hlYWRlci5sZW5ndGh9IGJ5dGVzIGluIGVudmVsb3BlZCBtZXNzYWdlLCBnb3QgJHtidWZmZXIuYnl0ZUxlbmd0aCAtIDV9IGJ5dGVzYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihtZXNzYWdlLCBDb2RlLkludmFsaWRBcmd1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIFJlYWRzIGFsbCBieXRlcyBmcm9tIHRoZSBzb3VyY2UsIGFuZCBjb25jYXRlbmF0ZXMgdGhlbSB0byBhIHNpbmdsZSBVaW50OEFycmF5LlxuICpcbiAqIFJhaXNlcyBhbiBlcnJvciBpZjpcbiAqIC0gbW9yZSB0aGFuIHJlYWRNYXhCeXRlcyBhcmUgcmVhZFxuICogLSBsZW5ndGhIaW50IGlzIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGxhcmdlciB0aGFuIHJlYWRNYXhCeXRlc1xuICogLSBsZW5ndGhIaW50IGlzIGEgcG9zaXRpdmUgaW50ZWdlciwgYW5kIHRoZSBzb3VyY2UgY29udGFpbnMgbW9yZSBvciBsZXNzIGJ5dGVzXG4gKiAgIHRoYW4gcHJvbWlzZWRcbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWRBbGxCeXRlcyhpdGVyYWJsZSwgcmVhZE1heEJ5dGVzLCBsZW5ndGhIaW50KSB7XG4gICAgdmFyIF9hLCBlXzEyLCBfYiwgX2MsIF9kLCBlXzEzLCBfZSwgX2Y7XG4gICAgY29uc3QgW29rLCBoaW50XSA9IHBhcnNlTGVuZ3RoSGludChsZW5ndGhIaW50KTtcbiAgICBpZiAob2spIHtcbiAgICAgICAgaWYgKGhpbnQgPiByZWFkTWF4Qnl0ZXMpIHtcbiAgICAgICAgICAgIGFzc2VydFJlYWRNYXhCeXRlcyhyZWFkTWF4Qnl0ZXMsIGhpbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGhpbnQpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9nID0gdHJ1ZSwgaXRlcmFibGVfMTIgPSBfX2FzeW5jVmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfMTJfMTsgaXRlcmFibGVfMTJfMSA9IGF3YWl0IGl0ZXJhYmxlXzEyLm5leHQoKSwgX2EgPSBpdGVyYWJsZV8xMl8xLmRvbmUsICFfYTsgX2cgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgX2MgPSBpdGVyYWJsZV8xMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIF9nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICsgY2h1bmsuYnl0ZUxlbmd0aCA+IGhpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgcHJvdG9jb2wgZXJyb3I6IHByb21pc2VkICR7aGludH0gYnl0ZXMsIHJlY2VpdmVkICR7b2Zmc2V0ICsgY2h1bmsuYnl0ZUxlbmd0aH1gLCBDb2RlLkludmFsaWRBcmd1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMTJfMSkgeyBlXzEyID0geyBlcnJvcjogZV8xMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX2cgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzEyLnJldHVybikpIGF3YWl0IF9iLmNhbGwoaXRlcmFibGVfMTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEyKSB0aHJvdyBlXzEyLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCA8IGhpbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYHByb3RvY29sIGVycm9yOiBwcm9taXNlZCAke2hpbnR9IGJ5dGVzLCByZWNlaXZlZCAke29mZnNldH1gLCBDb2RlLkludmFsaWRBcmd1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaCA9IHRydWUsIGl0ZXJhYmxlXzEzID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzEzXzE7IGl0ZXJhYmxlXzEzXzEgPSBhd2FpdCBpdGVyYWJsZV8xMy5uZXh0KCksIF9kID0gaXRlcmFibGVfMTNfMS5kb25lLCAhX2Q7IF9oID0gdHJ1ZSkge1xuICAgICAgICAgICAgX2YgPSBpdGVyYWJsZV8xM18xLnZhbHVlO1xuICAgICAgICAgICAgX2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2Y7XG4gICAgICAgICAgICBjb3VudCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgYXNzZXJ0UmVhZE1heEJ5dGVzKHJlYWRNYXhCeXRlcywgY291bnQpO1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzEzXzEpIHsgZV8xMyA9IHsgZXJyb3I6IGVfMTNfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9oICYmICFfZCAmJiAoX2UgPSBpdGVyYWJsZV8xMy5yZXR1cm4pKSBhd2FpdCBfZS5jYWxsKGl0ZXJhYmxlXzEzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTMpIHRocm93IGVfMTMuZXJyb3I7IH1cbiAgICB9XG4gICAgY29uc3QgYWxsID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGNodW5rID0gY2h1bmtzLnNoaWZ0KCk7IGNodW5rOyBjaHVuayA9IGNodW5rcy5zaGlmdCgpKSB7XG4gICAgICAgIGFsbC5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gYWxsO1xufVxuLy8gcGFyc2UgdGhlIGxlbmd0aEhpbnQgYXJndW1lbnQgb2YgcmVhZEFsbEJ5dGVzKClcbmZ1bmN0aW9uIHBhcnNlTGVuZ3RoSGludChsZW5ndGhIaW50KSB7XG4gICAgaWYgKGxlbmd0aEhpbnQgPT09IHVuZGVmaW5lZCB8fCBsZW5ndGhIaW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgIH1cbiAgICBjb25zdCBuID0gdHlwZW9mIGxlbmd0aEhpbnQgPT0gXCJzdHJpbmdcIiA/IHBhcnNlSW50KGxlbmd0aEhpbnQsIDEwKSA6IGxlbmd0aEhpbnQ7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMCkge1xuICAgICAgICByZXR1cm4gW2ZhbHNlLCBuXTtcbiAgICB9XG4gICAgcmV0dXJuIFt0cnVlLCBuXTtcbn1cbi8qKlxuICogV2FpdCBmb3IgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gaXRlcmFibGUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIGl0ZXJhYmxlLlxuICogVGhpcyBjb25zdW1lcyB0aGUgZmlyc3QgZWxlbWVudCwgYnV0IHB1c2hlcyBpdCBiYWNrIG9uIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVudGlsRmlyc3QoaXRlcmFibGUpIHtcbiAgICBjb25zdCBpdCA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIGxldCBmaXJzdCA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgY29uc3QgdyA9IHtcbiAgICAgICAgICAgICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBmaXJzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaXQudGhyb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uIC0tIGNhbid0IGhhbmRsZSBtdXRhdGVkIG9iamVjdCBzZW5zaWJseVxuICAgICAgICAgICAgICAgIHcudGhyb3cgPSAoZSkgPT4gaXQudGhyb3coZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQucmV0dXJuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbixAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIGNhbid0IGhhbmRsZSBtdXRhdGVkIG9iamVjdCBzZW5zaWJseVxuICAgICAgICAgICAgICAgIHcucmV0dXJuID0gKHZhbHVlKSA9PiBpdC5yZXR1cm4odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogV3JhcCB0aGUgZ2l2ZW4gaXRlcmFibGUgYW5kIHJldHVybiBhbiBpdGVyYWJsZSB3aXRoIGFuIGFib3J0KCkgbWV0aG9kLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZXhpc3RzIHB1cmVseSBmb3IgY29udmVuaWVuY2UuIFdoZXJlIG9uZSB3b3VsZCB0eXBpY2FsbHkgaGF2ZVxuICogdG8gYWNjZXNzIHRoZSBpdGVyYXRvciBkaXJlY3RseSwgYWR2YW5jZSB0aHJvdWdoIGFsbCBlbGVtZW50cywgYW5kIGNhbGxcbiAqIEFzeW5jSXRlcmF0b3IudGhyb3coKSB0byBub3RpZnkgdGhlIHVwc3RyZWFtIGl0ZXJhYmxlLCB0aGlzIGZ1bmN0aW9uIGFsbG93c1xuICogdG8gdXNlIGNvbnZlbmllbnQgZm9yLWF3YWl0IGxvb3BzIGFuZCBzdGlsbCBub3RpZnkgdGhlIHVwc3RyZWFtIGl0ZXJhYmxlOlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBhYm9ydGFibGUgPSBtYWtlSXRlcmFibGVBYm9ydGFibGUoaXRlcmFibGUpO1xuICogZm9yIGF3YWl0IChjb25zdCBlbGUgb2YgYWJvcnRhYmxlKSB7XG4gKiAgIGF3YWl0IGFib3J0YWJsZS5hYm9ydChcIkVSUlwiKTtcbiAqIH1cbiAqIGBgYFxuICogVGhlcmUgYXJlIGEgY291cGxlIG9mIGxpbWl0YXRpb25zIG9mIHRoaXMgZnVuY3Rpb246XG4gKiAtIHRoZSBnaXZlbiBhc3luYyBpdGVyYWJsZSBtdXN0IGltcGxlbWVudCB0aHJvd1xuICogLSB0aGUgYXN5bmMgaXRlcmFibGUgY2Fubm90IGJlIHJlLXVzZVxuICogLSBpZiBzb3VyY2UgY2F0Y2hlcyBlcnJvcnMgYW5kIHlpZWxkcyB2YWx1ZXMgZm9yIHRoZW0sIHRoZXkgYXJlIGlnbm9yZWQsIGFuZFxuICogICB0aGUgc291cmNlIG1heSBzdGlsbCBkYW5nbGVcbiAqXG4gKiBUaGVyZSBhcmUgZm91ciBwb3NzaWJsZSB3YXlzIGFuIGFzeW5jIGZ1bmN0aW9uKiBjYW4gaGFuZGxlIHlpZWxkIGVycm9yczpcbiAqIDEuIGRvbid0IGNhdGNoIGVycm9ycyBhdCBhbGwgLSBBYm9ydGFibGUuYWJvcnQoKSB3aWxsIHJlc29sdmUgXCJyZXRocm93blwiXG4gKiAyLiBjYXRjaCBlcnJvcnMgYW5kIHJldGhyb3cgLSBBYm9ydGFibGUuYWJvcnQoKSB3aWxsIHJlc29sdmUgXCJyZXRocm93blwiXG4gKiAzLiBjYXRjaCBlcnJvcnMgYW5kIHJldHVybiAtIEFib3J0YWJsZS5hYm9ydCgpIHdpbGwgcmVzb2x2ZSBcImNvbXBsZXRlZFwiXG4gKiA0LiBjYXRjaCBlcnJvcnMgYW5kIHlpZWxkIGEgdmFsdWUgLSBBYm9ydGFibGUuYWJvcnQoKSB3aWxsIHJlc29sdmUgXCJjYXVnaHRcIlxuICpcbiAqIE5vdGUgdGhhdCBjYXRjaGluZyBlcnJvcnMgYW5kIHlpZWxkaW5nIGEgdmFsdWUgaXMgcHJvYmxlbWF0aWMsIGFuZCBpdCBzaG91bGRcbiAqIGJlIGRvY3VtZW50ZWQgdGhhdCB0aGlzIG1heSBsZWF2ZSB0aGUgc291cmNlIGluIGEgZGFuZ2xpbmcgc3RhdGUuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSXRlcmFibGVBYm9ydGFibGUoaXRlcmFibGUpIHtcbiAgICBjb25zdCBpbm5lckNhbmRpZGF0ZSA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIGlmIChpbm5lckNhbmRpZGF0ZS50aHJvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jSXRlcmFibGUgZG9lcyBub3QgaW1wbGVtZW50IHRocm93XCIpO1xuICAgIH1cbiAgICBjb25zdCBpbm5lciA9IGlubmVyQ2FuZGlkYXRlO1xuICAgIGxldCBhYm9ydGVkO1xuICAgIGxldCByZXN1bHRQcm9taXNlO1xuICAgIGxldCBpdCA9IHtcbiAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICAgIHJlc3VsdFByb21pc2UgPSBpbm5lci5uZXh0KCkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFByb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHRocm93KGUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbm5lci50aHJvdyhlKTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChpbm5lckNhbmRpZGF0ZS5yZXR1cm4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXQpLCB7IHJldHVybih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lci5yZXR1cm4odmFsdWUpO1xuICAgICAgICAgICAgfSB9KTtcbiAgICB9XG4gICAgbGV0IHVzZWQgPSBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhYm9ydChyZWFzb24pIHtcbiAgICAgICAgICAgIGlmIChhYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFib3J0ZWQuc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lci50aHJvdyhyZWFzb24pLnRoZW4oKHIpID0+IChyLmRvbmUgPT09IHRydWUgPyBcImNvbXBsZXRlZFwiIDogXCJjYXVnaHRcIiksICgpID0+IFwicmV0aHJvd25cIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlc3VsdFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBhYm9ydGVkID0geyByZWFzb24sIHN0YXRlOiByZXN1bHRQcm9taXNlLnRoZW4oZiwgZikgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWJvcnRlZC5zdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFib3J0ZWQgPSB7IHJlYXNvbiwgc3RhdGU6IGYoKSB9O1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0ZWQuc3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICBpZiAodXNlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jSXRlcmFibGUgY2Fubm90IGJlIHJlLXVzZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgV3JpdGFibGVJdGVyYWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVdyaXRhYmxlSXRlcmFibGUoKSB7XG4gICAgLy8gV2Ugc3RhcnQgd2l0aCB0d28gcXVldWVzIHRvIGNhcHR1cmUgdGhlIHJlYWQgYW5kIHdyaXRlIGF0dGVtcHRzLlxuICAgIC8vXG4gICAgLy8gVGhlIHdyaXRlcyBhbmQgcmVhZHMgZWFjaCBjaGVjayBvZiB0aGVpciBjb3VudGVycGFydCBpc1xuICAgIC8vIGFscmVhZHkgYXZhaWxhYmxlIGFuZCBlaXRoZXIgaW50ZXJhY3QvYWRkIHRoZW1zZWx2ZXMgdG8gdGhlIHF1ZXVlLlxuICAgIGNvbnN0IHJlYWRRdWV1ZSA9IFtdO1xuICAgIGNvbnN0IHdyaXRlUXVldWUgPSBbXTtcbiAgICBsZXQgZXJyID0gdW5kZWZpbmVkO1xuICAgIGxldCBuZXh0UmVzb2x2ZTtcbiAgICBsZXQgbmV4dFJlamVjdDtcbiAgICBsZXQgbmV4dFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIG5leHRSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgbmV4dFJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICBsZXQgY2xvc2VkID0gZmFsc2U7XG4gICAgLy8gZHJhaW4gdGhlIHJlYWRRdWV1ZSBpbiBjYXNlIG9mIGVycm9yL3dyaXRlciBpcyBjbG9zZWQgYnkgc2VuZGluZyBhXG4gICAgLy8gZG9uZSByZXN1bHQuXG4gICAgZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmV4dCBvZiByZWFkUXVldWUuc3BsaWNlKDAsIHJlYWRRdWV1ZS5sZW5ndGgpKSB7XG4gICAgICAgICAgICBuZXh0KHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICBkcmFpbigpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyB3cml0ZShwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyICE9PSBudWxsICYmIGVyciAhPT0gdm9pZCAwID8gZXJyIDogbmV3IEVycm9yKFwiY2Fubm90IHdyaXRlLCBXcml0YWJsZUl0ZXJhYmxlIGFscmVhZHkgY2xvc2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVhZCA9IHJlYWRRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHJlYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRpZG4ndCBmaW5kIGEgcGVuZGluZyByZWFkIHNvIHdlIGFkZCB0aGUgcGF5bG9hZCB0byB0aGUgd3JpdGUgcXVldWUuXG4gICAgICAgICAgICAgICAgd3JpdGVRdWV1ZS5wdXNoKHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBwZW5kaW5nIHJlYWQgc28gd2UgcmVzcG9uZCB3aXRoIHRoZSBwYXlsb2FkLlxuICAgICAgICAgICAgICAgIHJlYWQoeyBkb25lOiBmYWxzZSwgdmFsdWU6IHBheWxvYWQgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWRRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIGluIHRoZSByZWFkIHF1ZXVlIHdlIGNhbiBtYXJrIHRoZSB3cml0ZSBhcyBjb21wbGV0ZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlIGVycm9yIHJlcG9ydGluZyBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBzZXF1ZW50aWFsIGFuZCB0aGVyZWZvcmUgY2Fubm90XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGxpbmtlZCB0byBhIHNwZWNpZmljIHdyaXRlLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgYXdhaXQgdGhlIG5leHQgY2FsbCBmb3IgYXMgbWFueSB0aW1lcyBhcyB0aGVyZSBhcmUgaXRlbXMgaW4gdGhlIHF1ZXVlICsgMVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBpdGVtcyBpbiB0aGUgd3JpdGUgcXVldWUgdGhhdCBtZWFucyB3cml0ZSBoYXBwZW5lZCBhbmQgd2UganVzdCBoYXZlXG4gICAgICAgICAgICAvLyB0byB3YWl0IGZvciBvbmUgbW9yZSBjYWxsIGxpa2V3aXNlIGlmIHdlIGFyZSB0aGUgbnRoIHdyaXRlIGluIHRoZSBxdWV1ZSB3ZVxuICAgICAgICAgICAgLy8gaGF2ZSB0byB3YWl0IGZvciBuIHdyaXRlcyB0byBjb21wbGV0ZSBhbmQgb25lIG1vcmUuXG4gICAgICAgICAgICBjb25zdCBsaW1pdCA9IHdyaXRlUXVldWUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGltaXQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5leHRQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIHRoZSBuZXh0UHJvbWlzZSB0byBpbmRpY2F0ZVxuICAgICAgICAgICAgICAgICAgICAvLyBwZW5kaW5nIHdyaXRlcyB0aGF0IGEgcmVhZCBhdHRlbXB0IGhhcyBiZWVuIG1hZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlaXIgd3JpdGUuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byByZXNldCB0aGUgcHJvbWlzZSBmb3IgZnV0dXJlIHdyaXRlcy5cbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3JpdGUgPSB3cml0ZVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3cml0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBhIHBlbmRpbmcgd3JpdGUgc28gcmVzcG9uc2Ugd2l0aCB0aGUgcGF5bG9hZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiBmYWxzZSwgdmFsdWU6IHdyaXRlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHJldHVybiBhIHByb21pc2UgaW1tZWRpYXRlbHkgdGhhdCBpcyBlaXRoZXIgcmVzb2x2ZWQvcmVqZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgd3JpdGVzIGhhcHBlbi5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlYWRSZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiAocmVhZFJlc29sdmUgPSByZXNvbHZlKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRRdWV1ZS5wdXNoKHJlYWRSZXNvbHZlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRocm93KHRocm93RXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA9IHRocm93RXJyO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZVF1ZXVlLnNwbGljZSgwLCB3cml0ZVF1ZXVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBuZXh0UHJvbWlzZSBpcyBhbHdheXMgcmVzb2x2ZWQuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgcmVqZWN0IGFsbCBwZW5kaW5nIHdyaXRlcy5cbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICBkcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJldHVybigpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVRdWV1ZS5zcGxpY2UoMCwgd3JpdGVRdWV1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIG9uY2UgZm9yIHRoZSB3cml0ZSBhd2FpdGluZyBjb25maXJtYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIG5leHRSZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlamVjdCBhbGwgZnV0dXJlIHdyaXRlcy5cbiAgICAgICAgICAgICAgICAgICAgbmV4dFByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJjYW5ub3Qgd3JpdGUsIGNvbnN1bWVyIGNhbGxlZCByZXR1cm5cIikpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0UHJvbWlzZS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUbyBtYWtlIHN1cmUgdGhhdCB0aGUgbmV4dFByb21pc2UgaXMgYWx3YXlzIHJlc29sdmVkLlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIGFzeW5jaHJvbm91cyBpdGVyYWJsZSBmcm9tIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3JlcXVpcmUtYXdhaXRcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBc3luY0l0ZXJhYmxlKGl0ZW1zKSB7XG4gICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogY3JlYXRlQXN5bmNJdGVyYWJsZV8xKCkge1xuICAgICAgICB5aWVsZCBfX2F3YWl0KHlpZWxkKiBfX2FzeW5jRGVsZWdhdG9yKF9fYXN5bmNWYWx1ZXMoaXRlbXMpKSk7XG4gICAgfSk7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fYXN5bmNWYWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNWYWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufTtcbnZhciBfX2F3YWl0ID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0KSB8fCBmdW5jdGlvbiAodikgeyByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTsgfVxudmFyIF9fYXN5bmNEZWxlZ2F0b3IgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNEZWxlZ2F0b3IpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgdmFyIGksIHA7XG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBmYWxzZSB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxufTtcbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jR2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59O1xuaW1wb3J0IHsgTWVzc2FnZSwgTWV0aG9kS2luZCB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbmltcG9ydCB7IG1ha2VBbnlDbGllbnQgfSBmcm9tIFwiLi9hbnktY2xpZW50LmpzXCI7XG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4vY29kZS5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlQXN5bmNJdGVyYWJsZSB9IGZyb20gXCIuL3Byb3RvY29sL2FzeW5jLWl0ZXJhYmxlLmpzXCI7XG4vKipcbiAqIENyZWF0ZSBhIFByb21pc2VDbGllbnQgZm9yIHRoZSBnaXZlbiBzZXJ2aWNlLCBpbnZva2luZyBSUENzIHRocm91Z2ggdGhlXG4gKiBnaXZlbiB0cmFuc3BvcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm9taXNlQ2xpZW50KHNlcnZpY2UsIHRyYW5zcG9ydCkge1xuICAgIHJldHVybiBtYWtlQW55Q2xpZW50KHNlcnZpY2UsIChtZXRob2QpID0+IHtcbiAgICAgICAgc3dpdGNoIChtZXRob2Qua2luZCkge1xuICAgICAgICAgICAgY2FzZSBNZXRob2RLaW5kLlVuYXJ5OlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVVbmFyeUZuKHRyYW5zcG9ydCwgc2VydmljZSwgbWV0aG9kKTtcbiAgICAgICAgICAgIGNhc2UgTWV0aG9kS2luZC5TZXJ2ZXJTdHJlYW1pbmc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVNlcnZlclN0cmVhbWluZ0ZuKHRyYW5zcG9ydCwgc2VydmljZSwgbWV0aG9kKTtcbiAgICAgICAgICAgIGNhc2UgTWV0aG9kS2luZC5DbGllbnRTdHJlYW1pbmc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNsaWVudFN0cmVhbWluZ0ZuKHRyYW5zcG9ydCwgc2VydmljZSwgbWV0aG9kKTtcbiAgICAgICAgICAgIGNhc2UgTWV0aG9kS2luZC5CaURpU3RyZWFtaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVCaURpU3RyZWFtaW5nRm4odHJhbnNwb3J0LCBzZXJ2aWNlLCBtZXRob2QpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVuYXJ5Rm4odHJhbnNwb3J0LCBzZXJ2aWNlLCBtZXRob2QpIHtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdHJhbnNwb3J0LnVuYXJ5KHNlcnZpY2UsIG1ldGhvZCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXRNcywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMsIGlucHV0LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udGV4dFZhbHVlcyk7XG4gICAgICAgIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbkhlYWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgcmVzcG9uc2UuaGVhZGVyKTtcbiAgICAgICAgKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uVHJhaWxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0aW9ucywgcmVzcG9uc2UudHJhaWxlcik7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5tZXNzYWdlO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VydmVyU3RyZWFtaW5nRm4odHJhbnNwb3J0LCBzZXJ2aWNlLCBtZXRob2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVTdHJlYW1SZXNwb25zZSh0cmFuc3BvcnQuc3RyZWFtKHNlcnZpY2UsIG1ldGhvZCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXRNcywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMsIGNyZWF0ZUFzeW5jSXRlcmFibGUoW2lucHV0XSksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb250ZXh0VmFsdWVzKSwgb3B0aW9ucyk7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDbGllbnRTdHJlYW1pbmdGbih0cmFuc3BvcnQsIHNlcnZpY2UsIG1ldGhvZCkge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAocmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICB2YXIgX2QsIF9lO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRyYW5zcG9ydC5zdHJlYW0oc2VydmljZSwgbWV0aG9kLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGltZW91dE1zLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycywgcmVxdWVzdCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRleHRWYWx1ZXMpO1xuICAgICAgICAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25IZWFkZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKG9wdGlvbnMsIHJlc3BvbnNlLmhlYWRlcik7XG4gICAgICAgIGxldCBzaW5nbGVNZXNzYWdlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBfZyA9IF9fYXN5bmNWYWx1ZXMocmVzcG9uc2UubWVzc2FnZSksIF9oOyBfaCA9IGF3YWl0IF9nLm5leHQoKSwgX2EgPSBfaC5kb25lLCAhX2E7IF9mID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF9jID0gX2gudmFsdWU7XG4gICAgICAgICAgICAgICAgX2YgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gX2M7XG4gICAgICAgICAgICAgICAgc2luZ2xlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX2YgJiYgIV9hICYmIChfYiA9IF9nLnJldHVybikpIGF3YWl0IF9iLmNhbGwoX2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2luZ2xlTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihcInByb3RvY29sIGVycm9yOiBtaXNzaW5nIHJlc3BvbnNlIG1lc3NhZ2VcIiwgQ29kZS5JbnRlcm5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgKF9lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uVHJhaWxlcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwob3B0aW9ucywgcmVzcG9uc2UudHJhaWxlcik7XG4gICAgICAgIHJldHVybiBzaW5nbGVNZXNzYWdlO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQmlEaVN0cmVhbWluZ0ZuKHRyYW5zcG9ydCwgc2VydmljZSwgbWV0aG9kKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVTdHJlYW1SZXNwb25zZSh0cmFuc3BvcnQuc3RyZWFtKHNlcnZpY2UsIG1ldGhvZCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXRNcywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMsIHJlcXVlc3QsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb250ZXh0VmFsdWVzKSwgb3B0aW9ucyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVN0cmVhbVJlc3BvbnNlKHN0cmVhbSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGl0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBfX2F3YWl0KHN0cmVhbSk7XG4gICAgICAgICAgICAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25IZWFkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIHJlc3BvbnNlLmhlYWRlcik7XG4gICAgICAgICAgICB5aWVsZCBfX2F3YWl0KHlpZWxkKiBfX2FzeW5jRGVsZWdhdG9yKF9fYXN5bmNWYWx1ZXMocmVzcG9uc2UubWVzc2FnZSkpKTtcbiAgICAgICAgICAgIChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vblRyYWlsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKG9wdGlvbnMsIHJlc3BvbnNlLnRyYWlsZXIpO1xuICAgICAgICB9KTtcbiAgICB9KSgpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIC8vIENyZWF0ZSBhIG5ldyBpdGVyYWJsZSB0byBvbWl0IHRocm93L3JldHVybi5cbiAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdOiAoKSA9PiAoe1xuICAgICAgICAgICAgbmV4dDogKCkgPT4gaXQubmV4dCgpLFxuICAgICAgICB9KSxcbiAgICB9O1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IENvbm5lY3RFcnJvciB9IGZyb20gXCIuLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4uL2NvZGUuanNcIjtcbi8qKlxuICogQ3JlYXRlIGFuIEFib3J0Q29udHJvbGxlciB0aGF0IGlzIGF1dG9tYXRpY2FsbHkgYWJvcnRlZCBpZiBvbmUgb2YgdGhlIGdpdmVuXG4gKiBzaWduYWxzIGlzIGFib3J0ZWQuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB0aGUgbGlua2VkIEFib3J0U2lnbmFscyBjYW4gYmUgdW5kZWZpbmVkLlxuICpcbiAqIElmIHRoZSBjb250cm9sbGVyIG9yIGFueSBvZiB0aGUgc2lnbmFscyBpcyBhYm9ydGVkLCBhbGwgZXZlbnQgbGlzdGVuZXJzIGFyZVxuICogcmVtb3ZlZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxpbmtlZEFib3J0Q29udHJvbGxlciguLi5zaWduYWxzKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzYSA9IHNpZ25hbHNcbiAgICAgICAgLmZpbHRlcigocykgPT4gcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAuY29uY2F0KGNvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBmb3IgKGNvbnN0IHNpZ25hbCBvZiBzYSkge1xuICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIG9uQWJvcnQuYXBwbHkoc2lnbmFsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQWJvcnQoKSB7XG4gICAgICAgIGlmICghY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydChnZXRBYm9ydFNpZ25hbFJlYXNvbih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzaWduYWwgb2Ygc2EpIHtcbiAgICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xsZXI7XG59XG4vKipcbiAqIENyZWF0ZSBhIGRlYWRsaW5lIHNpZ25hbC4gVGhlIHJldHVybmVkIG9iamVjdCBjb250YWlucyBhbiBBYm9ydFNpZ25hbCwgYnV0XG4gKiBhbHNvIGEgY2xlYW51cCBmdW5jdGlvbiB0byBzdG9wIHRoZSB0aW1lciwgd2hpY2ggbXVzdCBiZSBjYWxsZWQgb25jZSB0aGVcbiAqIGNhbGxpbmcgY29kZSBpcyBubyBsb25nZXIgaW50ZXJlc3RlZCBpbiB0aGUgc2lnbmFsLlxuICpcbiAqIElkZWFsbHksIHdlIHdvdWxkIHNpbXBseSB1c2UgQWJvcnRTaWduYWwudGltZW91dCgpLCBidXQgaXQgaXMgbm90IHdpZGVseVxuICogYXZhaWxhYmxlIHlldC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlYWRsaW5lU2lnbmFsKHRpbWVvdXRNcykge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQobmV3IENvbm5lY3RFcnJvcihcInRoZSBvcGVyYXRpb24gdGltZWQgb3V0XCIsIENvZGUuRGVhZGxpbmVFeGNlZWRlZCkpO1xuICAgIH07XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBpZiAodGltZW91dE1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRpbWVvdXRNcyA8PSAwKVxuICAgICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChsaXN0ZW5lciwgdGltZW91dE1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgY2xlYW51cDogKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCksXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcmVhc29uIHdoeSBhbiBBYm9ydFNpZ25hbCB3YXMgYWJvcnRlZC4gUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlXG4gKiBzaWduYWwgaGFzIG5vdCBiZWVuIGFib3J0ZWQuXG4gKlxuICogVGhlIHByb3BlcnR5IEFib3J0U2lnbmFsLnJlYXNvbiBpcyBub3Qgd2lkZWx5IGF2YWlsYWJsZS4gVGhpcyBmdW5jdGlvblxuICogcmV0dXJucyBhbiBBYm9ydEVycm9yIGlmIHRoZSBzaWduYWwgaXMgYWJvcnRlZCwgYnV0IHJlYXNvbiBpcyB1bmRlZmluZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBYm9ydFNpZ25hbFJlYXNvbihzaWduYWwpIHtcbiAgICBpZiAoIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChzaWduYWwucmVhc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNpZ25hbC5yZWFzb247XG4gICAgfVxuICAgIC8vIEFib3J0U2lnbmFsLnJlYXNvbiBpcyBhdmFpbGFibGUgaW4gTm9kZS5qcyB2MTYsIHYxOCwgYW5kIGxhdGVyLFxuICAgIC8vIGFuZCBpbiBhbGwgYnJvd3NlcnMgc2luY2UgZWFybHkgMjAyMi5cbiAgICBjb25zdCBlID0gbmV3IEVycm9yKFwiVGhpcyBvcGVyYXRpb24gd2FzIGFib3J0ZWRcIik7XG4gICAgZS5uYW1lID0gXCJBYm9ydEVycm9yXCI7XG4gICAgcmV0dXJuIGU7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBjcmVhdGVDb250ZXh0VmFsdWVzIGNyZWF0ZXMgYSBuZXcgQ29udGV4dFZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHRWYWx1ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleS5pZCBpbiB0aGlzID8gdGhpc1trZXkuaWRdIDoga2V5LmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNba2V5LmlkXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2tleS5pZF07XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBjcmVhdGVDb250ZXh0S2V5IGNyZWF0ZXMgYSBuZXcgQ29udGV4dEtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHRLZXkoZGVmYXVsdFZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHsgaWQ6IFN5bWJvbChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzY3JpcHRpb24pLCBkZWZhdWx0VmFsdWUgfTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIENyZWF0ZSBhIFVSTCBmb3IgdGhlIGdpdmVuIFJQQy4gVGhpcyBzaW1wbHkgYWRkcyB0aGUgcXVhbGlmaWVkXG4gKiBzZXJ2aWNlIG5hbWUsIGEgc2xhc2gsIGFuZCB0aGUgbWV0aG9kIG5hbWUgdG8gdGhlIHBhdGggb2YgdGhlIGdpdmVuXG4gKiBiYXNlVXJsLlxuICpcbiAqIEZvciBleGFtcGxlLCB0aGUgYmFzZVVyaSBodHRwczovL2V4YW1wbGUuY29tIGFuZCBtZXRob2QgXCJTYXlcIiBmcm9tXG4gKiB0aGUgc2VydmljZSBleGFtcGxlLkVsaXphU2VydmljZSByZXN1bHRzIGluOlxuICogaHR0cHM6Ly9leGFtcGxlLmNvbS9leGFtcGxlLkVsaXphU2VydmljZS9TYXlcbiAqXG4gKiBUaGlzIGZvcm1hdCBpcyB1c2VkIGJ5IHRoZSBwcm90b2NvbHMgQ29ubmVjdCwgZ1JQQyBhbmQgVHdpcnAuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gYWxzbyBhY2NlcHRzIGEgcHJvdG9jb2wtcmVsYXRpdmUgYmFzZVVybC5cbiAqIElmIGdpdmVuIGFuIGVtcHR5IHN0cmluZyBvciBcIi9cIiBhcyBhIGJhc2VVcmwsIGl0IHJldHVybnMganVzdCB0aGVcbiAqIHBhdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZXRob2RVcmwoYmFzZVVybCwgc2VydmljZSwgbWV0aG9kKSB7XG4gICAgY29uc3QgcyA9IHR5cGVvZiBzZXJ2aWNlID09IFwic3RyaW5nXCIgPyBzZXJ2aWNlIDogc2VydmljZS50eXBlTmFtZTtcbiAgICBjb25zdCBtID0gdHlwZW9mIG1ldGhvZCA9PSBcInN0cmluZ1wiID8gbWV0aG9kIDogbWV0aG9kLm5hbWU7XG4gICAgcmV0dXJuIGJhc2VVcmwudG9TdHJpbmcoKS5yZXBsYWNlKC9cXC8/JC8sIGAvJHtzfS8ke219YCk7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgTWVzc2FnZSB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbi8qKlxuICogIFRha2VzIGEgcGFydGlhbCBwcm90b2J1ZiBtZXNzYWdlcyBvZiB0aGVcbiAqICBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlIGFzIGlucHV0LCBhbmQgcmV0dXJucyBmdWxsIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZSh0eXBlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UgaW5zdGFuY2VvZiBNZXNzYWdlID8gbWVzc2FnZSA6IG5ldyB0eXBlKG1lc3NhZ2UpO1xufVxuLyoqXG4gKiBUYWtlcyBhbiBBc3luY0l0ZXJhYmxlIG9mIHBhcnRpYWwgcHJvdG9idWYgbWVzc2FnZXMgb2YgdGhlXG4gKiBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlIGFzIGlucHV0LCBhbmQgeWllbGRzIGZ1bGwgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplSXRlcmFibGUobWVzc2FnZVR5cGUsIGlucHV0KSB7XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0LmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHJlc3VsdC5kb25lLFxuICAgICAgICAgICAgdmFsdWU6IG5vcm1hbGl6ZShtZXNzYWdlVHlwZSwgcmVzdWx0LnZhbHVlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ID0gaW5wdXRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICAgICAgbmV4dDogKCkgPT4gaXQubmV4dCgpLnRoZW4odHJhbnNmb3JtKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaXQudGhyb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcy50aHJvdyA9IChlKSA9PiBpdC50aHJvdyhlKS50aGVuKHRyYW5zZm9ybSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0LnJldHVybiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzLnJldHVybiA9ICh2KSA9PiBpdC5yZXR1cm4odikudGhlbih0cmFuc2Zvcm0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi4vY29ubmVjdC1lcnJvci5qc1wiO1xuaW1wb3J0IHsgQ29kZSB9IGZyb20gXCIuLi9jb2RlLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRSZWFkTWF4Qnl0ZXMsIGFzc2VydFdyaXRlTWF4Qnl0ZXMgfSBmcm9tIFwiLi9saW1pdC1pby5qc1wiO1xuLyoqXG4gKiBTZXRzIGRlZmF1bHQgSlNPTiBzZXJpYWxpemF0aW9uIG9wdGlvbnMgZm9yIGNvbm5lY3QtZXMuXG4gKlxuICogV2l0aCBzdGFuZGFyZCBwcm90b2J1ZiBKU09OIHNlcmlhbGl6YXRpb24sIHVua25vd24gSlNPTiBmaWVsZHMgYXJlXG4gKiByZWplY3RlZCBieSBkZWZhdWx0LiBJbiBjb25uZWN0LWVzLCB1bmtub3duIEpTT04gZmllbGRzIGFyZSBpZ25vcmVkXG4gKiBieSBkZWZhdWx0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SnNvbk9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBvID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgKF9hID0gby5pZ25vcmVVbmtub3duRmllbGRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoby5pZ25vcmVVbmtub3duRmllbGRzID0gdHJ1ZSk7XG4gICAgcmV0dXJuIG87XG59XG4vKipcbiAqIENyZWF0ZSBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBjb252ZW5pZW50IGFjY2VzcyB0byByZXF1ZXN0IGFuZCByZXNwb25zZVxuICogbWVzc2FnZSBzZXJpYWxpemF0aW9uIGZvciBhIGdpdmVuIG1ldGhvZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZFNlcmlhbGl6YXRpb25Mb29rdXAobWV0aG9kLCBiaW5hcnlPcHRpb25zLCBqc29uT3B0aW9ucywgbGltaXRPcHRpb25zKSB7XG4gICAgY29uc3QgaW5wdXRCaW5hcnkgPSBsaW1pdFNlcmlhbGl6YXRpb24oY3JlYXRlQmluYXJ5U2VyaWFsaXphdGlvbihtZXRob2QuSSwgYmluYXJ5T3B0aW9ucyksIGxpbWl0T3B0aW9ucyk7XG4gICAgY29uc3QgaW5wdXRKc29uID0gbGltaXRTZXJpYWxpemF0aW9uKGNyZWF0ZUpzb25TZXJpYWxpemF0aW9uKG1ldGhvZC5JLCBqc29uT3B0aW9ucyksIGxpbWl0T3B0aW9ucyk7XG4gICAgY29uc3Qgb3V0cHV0QmluYXJ5ID0gbGltaXRTZXJpYWxpemF0aW9uKGNyZWF0ZUJpbmFyeVNlcmlhbGl6YXRpb24obWV0aG9kLk8sIGJpbmFyeU9wdGlvbnMpLCBsaW1pdE9wdGlvbnMpO1xuICAgIGNvbnN0IG91dHB1dEpzb24gPSBsaW1pdFNlcmlhbGl6YXRpb24oY3JlYXRlSnNvblNlcmlhbGl6YXRpb24obWV0aG9kLk8sIGpzb25PcHRpb25zKSwgbGltaXRPcHRpb25zKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRJKHVzZUJpbmFyeUZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZUJpbmFyeUZvcm1hdCA/IGlucHV0QmluYXJ5IDogaW5wdXRKc29uO1xuICAgICAgICB9LFxuICAgICAgICBnZXRPKHVzZUJpbmFyeUZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZUJpbmFyeUZvcm1hdCA/IG91dHB1dEJpbmFyeSA6IG91dHB1dEpzb247XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyBmdW5jdGlvbnMgdG8gbm9ybWFsaXplIGFuZCBzZXJpYWxpemUgdGhlIGlucHV0IG1lc3NhZ2VcbiAqIG9mIGFuIFJQQywgYW5kIHRvIHBhcnNlIHRoZSBvdXRwdXQgbWVzc2FnZSBvZiBhbiBSUEMuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDbGllbnRNZXRob2RTZXJpYWxpemVycyhtZXRob2QsIHVzZUJpbmFyeUZvcm1hdCwganNvbk9wdGlvbnMsIGJpbmFyeU9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVzZUJpbmFyeUZvcm1hdFxuICAgICAgICA/IGNyZWF0ZUJpbmFyeVNlcmlhbGl6YXRpb24obWV0aG9kLkksIGJpbmFyeU9wdGlvbnMpXG4gICAgICAgIDogY3JlYXRlSnNvblNlcmlhbGl6YXRpb24obWV0aG9kLkksIGpzb25PcHRpb25zKTtcbiAgICBjb25zdCBvdXRwdXQgPSB1c2VCaW5hcnlGb3JtYXRcbiAgICAgICAgPyBjcmVhdGVCaW5hcnlTZXJpYWxpemF0aW9uKG1ldGhvZC5PLCBiaW5hcnlPcHRpb25zKVxuICAgICAgICA6IGNyZWF0ZUpzb25TZXJpYWxpemF0aW9uKG1ldGhvZC5PLCBqc29uT3B0aW9ucyk7XG4gICAgcmV0dXJuIHsgcGFyc2U6IG91dHB1dC5wYXJzZSwgc2VyaWFsaXplOiBpbnB1dC5zZXJpYWxpemUgfTtcbn1cbi8qKlxuICogQXBwbHkgSS9PIGxpbWl0cyB0byBhIFNlcmlhbGl6YXRpb24gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGltaXRTZXJpYWxpemF0aW9uKHNlcmlhbGl6YXRpb24sIGxpbWl0T3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlcmlhbGl6ZShkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IHNlcmlhbGl6YXRpb24uc2VyaWFsaXplKGRhdGEpO1xuICAgICAgICAgICAgYXNzZXJ0V3JpdGVNYXhCeXRlcyhsaW1pdE9wdGlvbnMud3JpdGVNYXhCeXRlcywgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlKGRhdGEpIHtcbiAgICAgICAgICAgIGFzc2VydFJlYWRNYXhCeXRlcyhsaW1pdE9wdGlvbnMucmVhZE1heEJ5dGVzLCBkYXRhLmJ5dGVMZW5ndGgsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb24ucGFyc2UoZGF0YSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFNlcmlhbGl6YXRpb24gb2JqZWN0IGZvciBzZXJpYWxpemluZyB0aGUgZ2l2ZW4gcHJvdG9idWYgbWVzc2FnZVxuICogd2l0aCB0aGUgcHJvdG9idWYgYmluYXJ5IGZvcm1hdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJpbmFyeVNlcmlhbGl6YXRpb24obWVzc2FnZVR5cGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXJzZShkYXRhKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlVHlwZS5mcm9tQmluYXJ5KGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYHBhcnNlIGJpbmFyeTogJHttfWAsIENvZGUuSW52YWxpZEFyZ3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplKGRhdGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEudG9CaW5hcnkob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgc2VyaWFsaXplIGJpbmFyeTogJHttfWAsIENvZGUuSW50ZXJuYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBTZXJpYWxpemF0aW9uIG9iamVjdCBmb3Igc2VyaWFsaXppbmcgdGhlIGdpdmVuIHByb3RvYnVmIG1lc3NhZ2VcbiAqIHdpdGggdGhlIHByb3RvYnVmIGNhbm9uaWNhbCBKU09OIGVuY29kaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHVua25vd24gZmllbGRzIGFyZSBpZ25vcmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSnNvblNlcmlhbGl6YXRpb24obWVzc2FnZVR5cGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHRleHRFbmNvZGVyID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRleHRFbmNvZGVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCB0ZXh0RGVjb2RlciA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50ZXh0RGVjb2RlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFRleHREZWNvZGVyKCk7XG4gICAgY29uc3QgbyA9IGdldEpzb25PcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhcnNlKGRhdGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbiA9IHRleHREZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZVR5cGUuZnJvbUpzb25TdHJpbmcoanNvbiwgbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IENvbm5lY3RFcnJvci5mcm9tKGUsIENvZGUuSW52YWxpZEFyZ3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplKGRhdGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbiA9IGRhdGEudG9Kc29uU3RyaW5nKG8pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGUoanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IENvbm5lY3RFcnJvci5mcm9tKGUsIENvZGUuSW50ZXJuYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBSZWd1bGFyIEV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGFueSB2YWxpZCBDb25uZWN0IENvbnRlbnQtVHlwZSBoZWFkZXIgdmFsdWUuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBjb250ZW50VHlwZVJlZ0V4cCA9IC9eYXBwbGljYXRpb25cXC8oY29ubmVjdFxcKyk/KD86KGpzb24pKD86OyA/Y2hhcnNldD11dGYtPzgpP3wocHJvdG8pKSQvaTtcbi8qKlxuICogUmVndWxhciBFeHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhIENvbm5lY3QgdW5hcnkgQ29udGVudC1UeXBlIGhlYWRlciB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnRlbnRUeXBlVW5hcnlSZWdFeHAgPSAvXmFwcGxpY2F0aW9uXFwvKD86anNvbig/OjsgP2NoYXJzZXQ9dXRmLT84KT98cHJvdG8pJC9pO1xuLyoqXG4gKiBSZWd1bGFyIEV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGEgQ29ubmVjdCBzdHJlYW1pbmcgQ29udGVudC1UeXBlIGhlYWRlciB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnRlbnRUeXBlU3RyZWFtUmVnRXhwID0gL15hcHBsaWNhdGlvblxcL2Nvbm5lY3RcXCs/KD86anNvbig/OjsgP2NoYXJzZXQ9dXRmLT84KT98cHJvdG8pJC9pO1xuZXhwb3J0IGNvbnN0IGNvbnRlbnRUeXBlVW5hcnlQcm90byA9IFwiYXBwbGljYXRpb24vcHJvdG9cIjtcbmV4cG9ydCBjb25zdCBjb250ZW50VHlwZVVuYXJ5SnNvbiA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuZXhwb3J0IGNvbnN0IGNvbnRlbnRUeXBlU3RyZWFtUHJvdG8gPSBcImFwcGxpY2F0aW9uL2Nvbm5lY3QrcHJvdG9cIjtcbmV4cG9ydCBjb25zdCBjb250ZW50VHlwZVN0cmVhbUpzb24gPSBcImFwcGxpY2F0aW9uL2Nvbm5lY3QranNvblwiO1xuY29uc3QgZW5jb2RpbmdQcm90byA9IFwicHJvdG9cIjtcbmNvbnN0IGVuY29kaW5nSnNvbiA9IFwianNvblwiO1xuLyoqXG4gKiBQYXJzZSBhIENvbm5lY3QgQ29udGVudC1UeXBlIGhlYWRlci5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29udGVudFR5cGUoY29udGVudFR5cGUpIHtcbiAgICBjb25zdCBtYXRjaCA9IGNvbnRlbnRUeXBlID09PSBudWxsIHx8IGNvbnRlbnRUeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZW50VHlwZS5tYXRjaChjb250ZW50VHlwZVJlZ0V4cCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW0gPSAhIW1hdGNoWzFdO1xuICAgIGNvbnN0IGJpbmFyeSA9ICEhbWF0Y2hbM107XG4gICAgcmV0dXJuIHsgc3RyZWFtLCBiaW5hcnkgfTtcbn1cbi8qKlxuICogUGFyc2UgYSBDb25uZWN0IEdldCBlbmNvZGluZyBxdWVyeSBwYXJhbWV0ZXIuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUVuY29kaW5nUXVlcnkoZW5jb2RpbmcpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICAgIGNhc2UgZW5jb2RpbmdQcm90bzpcbiAgICAgICAgICAgIHJldHVybiB7IHN0cmVhbTogZmFsc2UsIGJpbmFyeTogdHJ1ZSB9O1xuICAgICAgICBjYXNlIGVuY29kaW5nSnNvbjpcbiAgICAgICAgICAgIHJldHVybiB7IHN0cmVhbTogZmFsc2UsIGJpbmFyeTogZmFsc2UgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbmltcG9ydCB7IE1lc3NhZ2UsIHByb3RvQmFzZTY0IH0gZnJvbSBcIkBidWZidWlsZC9wcm90b2J1ZlwiO1xuaW1wb3J0IHsgQ29kZSB9IGZyb20gXCIuLi9jb2RlLmpzXCI7XG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi4vY29ubmVjdC1lcnJvci5qc1wiO1xuaW1wb3J0IHsgY29kZUZyb21TdHJpbmcsIGNvZGVUb1N0cmluZyB9IGZyb20gXCIuL2NvZGUtc3RyaW5nLmpzXCI7XG4vKipcbiAqIFBhcnNlIGEgQ29ubmVjdCBlcnJvciBmcm9tIGEgSlNPTiB2YWx1ZS5cbiAqIFdpbGwgcmV0dXJuIGEgQ29ubmVjdEVycm9yLCBhbmQgdGhyb3cgdGhlIHByb3ZpZGVkIGZhbGxiYWNrIGlmIHBhcnNpbmcgZmFpbGVkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JGcm9tSnNvbihqc29uVmFsdWUsIG1ldGFkYXRhLCBmYWxsYmFjaykge1xuICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICBuZXcgSGVhZGVycyhtZXRhZGF0YSkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gZmFsbGJhY2subWV0YWRhdGEuYXBwZW5kKGtleSwgdmFsdWUpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBqc29uVmFsdWUgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAganNvblZhbHVlID09IG51bGwgfHxcbiAgICAgICAgQXJyYXkuaXNBcnJheShqc29uVmFsdWUpIHx8XG4gICAgICAgICEoXCJjb2RlXCIgaW4ganNvblZhbHVlKSB8fFxuICAgICAgICB0eXBlb2YganNvblZhbHVlLmNvZGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgZmFsbGJhY2s7XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBjb2RlRnJvbVN0cmluZyhqc29uVmFsdWUuY29kZSk7XG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBmYWxsYmFjaztcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IGpzb25WYWx1ZS5tZXNzYWdlO1xuICAgIGlmIChtZXNzYWdlICE9IG51bGwgJiYgdHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgZmFsbGJhY2s7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gbmV3IENvbm5lY3RFcnJvcihtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBcIlwiLCBjb2RlLCBtZXRhZGF0YSk7XG4gICAgaWYgKFwiZGV0YWlsc1wiIGluIGpzb25WYWx1ZSAmJiBBcnJheS5pc0FycmF5KGpzb25WYWx1ZS5kZXRhaWxzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGRldGFpbCBvZiBqc29uVmFsdWUuZGV0YWlscykge1xuICAgICAgICAgICAgaWYgKGRldGFpbCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBkZXRhaWwgIT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZGV0YWlsKSB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBkZXRhaWwudHlwZSAhPSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGRldGFpbC52YWx1ZSAhPSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICAgICAgKFwiZGVidWdcIiBpbiBkZXRhaWwgJiYgdHlwZW9mIGRldGFpbC5kZWJ1ZyAhPSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGZhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlcnJvci5kZXRhaWxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBkZXRhaWwudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByb3RvQmFzZTY0LmRlYyhkZXRhaWwudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZzogZGV0YWlsLmRlYnVnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG4vKipcbiAqIFBhcnNlIGEgQ29ubmVjdCBlcnJvciBmcm9tIGEgc2VyaWFsaXplZCBKU09OIHZhbHVlLlxuICogV2lsbCByZXR1cm4gYSBDb25uZWN0RXJyb3IsIGFuZCB0aHJvdyB0aGUgcHJvdmlkZWQgZmFsbGJhY2sgaWYgcGFyc2luZyBmYWlsZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckZyb21Kc29uQnl0ZXMoYnl0ZXMsIG1ldGFkYXRhLCBmYWxsYmFjaykge1xuICAgIGxldCBqc29uVmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgICAganNvblZhbHVlID0gSlNPTi5wYXJzZShuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBlcnJvckZyb21Kc29uKGpzb25WYWx1ZSwgbWV0YWRhdGEsIGZhbGxiYWNrKTtcbn1cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBlcnJvciB0byBKU09OLlxuICpcbiAqIFRoZSBKU09OIHNlcmlhbGl6YXRpb24gb3B0aW9ucyBhcmUgcmVxdWlyZWQgdG8gcHJvZHVjZSB0aGUgb3B0aW9uYWxcbiAqIGh1bWFuLXJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIGluIHRoZSBcImRlYnVnXCIga2V5IGlmIHRoZSBkZXRhaWwgdXNlc1xuICogZ29vZ2xlLnByb3RvYnVmLkFueS4gSWYgc2VyaWFsaXphdGlvbiBvZiB0aGUgXCJkZWJ1Z1wiIHZhbHVlIGZhaWxzLCBpdFxuICogaXMgc2lsZW50bHkgZGlzcmVnYXJkZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vY29ubmVjdHJwYy5jb20vZG9jcy9wcm90b2NvbCNlcnJvci1lbmQtc3RyZWFtXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvclRvSnNvbihlcnJvciwganNvbldyaXRlT3B0aW9ucykge1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICAgIGNvZGU6IGNvZGVUb1N0cmluZyhlcnJvci5jb2RlKSxcbiAgICB9O1xuICAgIGlmIChlcnJvci5yYXdNZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgby5tZXNzYWdlID0gZXJyb3IucmF3TWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKGVycm9yLmRldGFpbHMubGVuZ3RoID4gMCkge1xuICAgICAgICBvLmRldGFpbHMgPSBlcnJvci5kZXRhaWxzXG4gICAgICAgICAgICAubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHZhbHVlLmdldFR5cGUoKS50eXBlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnRvQmluYXJ5KCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpLmRlYnVnID0gdmFsdWUudG9Kc29uKGpzb25Xcml0ZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkZWxpYmVyYXRlbHkgaWdub3JlIGVycm9ycyB0aGF0IG1heSBvY2N1ciB3aGVuIHNlcmlhbGl6aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgbWVzc2FnZSB0byBKU09OICh0aGUgbWVzc2FnZSBjb250YWlucyBhbiBBbnkpLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmF0aW9uYWxlIGlzIHRoYXQgd2UgYXJlIG9ubHkgdHJ5aW5nIHRvIHByb3ZpZGUgb3B0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVidWcgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcCgoX2EpID0+IHtcbiAgICAgICAgICAgIHZhciB7IHZhbHVlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1widmFsdWVcIl0pO1xuICAgICAgICAgICAgcmV0dXJuIChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCB7IHZhbHVlOiBwcm90b0Jhc2U2NC5lbmModmFsdWUpIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvO1xufVxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIGVycm9yIHRvIEpTT04uIFRoaXMgY2FsbHMgZXJyb3JUb0pzb24oKSwgYnV0IHN0cmluZ2lmaWVzXG4gKiB0aGUgcmVzdWx0LCBhbmQgY29udmVydHMgaXQgaW50byBhIFVJbnQ4QXJyYXkuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvclRvSnNvbkJ5dGVzKGVycm9yLCBqc29uV3JpdGVPcHRpb25zKSB7XG4gICAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBqc29uT2JqZWN0ID0gZXJyb3JUb0pzb24oZXJyb3IsIGpzb25Xcml0ZU9wdGlvbnMpO1xuICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoanNvbk9iamVjdCk7XG4gICAgICAgIHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGUoanNvblN0cmluZyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IG0gPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSk7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYGZhaWxlZCB0byBzZXJpYWxpemUgQ29ubmVjdCBFcnJvcjogJHttfWAsIENvZGUuSW50ZXJuYWwpO1xuICAgIH1cbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBlcnJvckZyb21Kc29uLCBlcnJvclRvSnNvbiB9IGZyb20gXCIuL2Vycm9yLWpzb24uanNcIjtcbmltcG9ydCB7IGFwcGVuZEhlYWRlcnMgfSBmcm9tIFwiLi4vaHR0cC1oZWFkZXJzLmpzXCI7XG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi4vY29ubmVjdC1lcnJvci5qc1wiO1xuaW1wb3J0IHsgQ29kZSB9IGZyb20gXCIuLi9jb2RlLmpzXCI7XG4vKipcbiAqIGVuZFN0cmVhbUZsYWcgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaW4gYSBFbnZlbG9wZWRNZXNzYWdlXG4gKiBpcyBhIEVuZFN0cmVhbVJlc3BvbnNlIG9mIHRoZSBDb25uZWN0IHByb3RvY29sLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgY29uc3QgZW5kU3RyZWFtRmxhZyA9IDBiMDAwMDAwMTA7XG4vKipcbiAqIFBhcnNlIGFuIEVuZFN0cmVhbVJlc3BvbnNlIG9mIHRoZSBDb25uZWN0IHByb3RvY29sLlxuICogVGhyb3dzIGEgQ29ubmVjdEVycm9yIG9uIG1hbGZvcm1lZCBpbnB1dC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuZFN0cmVhbUZyb21Kc29uKGRhdGEpIHtcbiAgICBjb25zdCBwYXJzZUVyciA9IG5ldyBDb25uZWN0RXJyb3IoXCJpbnZhbGlkIGVuZCBzdHJlYW1cIiwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgIGxldCBqc29uVmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICBqc29uVmFsdWUgPSBKU09OLnBhcnNlKHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIgPyBkYXRhIDogbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgcGFyc2VFcnI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YganNvblZhbHVlICE9IFwib2JqZWN0XCIgfHxcbiAgICAgICAganNvblZhbHVlID09IG51bGwgfHxcbiAgICAgICAgQXJyYXkuaXNBcnJheShqc29uVmFsdWUpKSB7XG4gICAgICAgIHRocm93IHBhcnNlRXJyO1xuICAgIH1cbiAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBIZWFkZXJzKCk7XG4gICAgaWYgKFwibWV0YWRhdGFcIiBpbiBqc29uVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uVmFsdWUubWV0YWRhdGEgIT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAganNvblZhbHVlLm1ldGFkYXRhID09IG51bGwgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoanNvblZhbHVlLm1ldGFkYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgcGFyc2VFcnI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIE9iamVjdC5lbnRyaWVzKGpzb25WYWx1ZS5tZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpIHx8XG4gICAgICAgICAgICAgICAgdmFsdWVzLnNvbWUoKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBwYXJzZUVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gXCJlcnJvclwiIGluIGpzb25WYWx1ZVxuICAgICAgICA/IGVycm9yRnJvbUpzb24oanNvblZhbHVlLmVycm9yLCBtZXRhZGF0YSwgcGFyc2VFcnIpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB7IG1ldGFkYXRhLCBlcnJvciB9O1xufVxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIEVuZFN0cmVhbVJlc3BvbnNlIHRvIEpTT04uXG4gKlxuICogVGhlIEpTT04gc2VyaWFsaXphdGlvbiBvcHRpb25zIGFyZSByZXF1aXJlZCB0byBwcm9kdWNlIHRoZSBvcHRpb25hbFxuICogaHVtYW4tcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgZXJyb3IgZGV0YWlscyBpZiB0aGUgZGV0YWlsIHVzZXNcbiAqIGdvb2dsZS5wcm90b2J1Zi5BbnkuXG4gKlxuICogU2VlIGh0dHBzOi8vY29ubmVjdHJwYy5jb20vZG9jcy9wcm90b2NvbCNlcnJvci1lbmQtc3RyZWFtXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmRTdHJlYW1Ub0pzb24obWV0YWRhdGEsIGVycm9yLCBqc29uV3JpdGVPcHRpb25zKSB7XG4gICAgY29uc3QgZXMgPSB7fTtcbiAgICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcy5lcnJvciA9IGVycm9yVG9Kc29uKGVycm9yLCBqc29uV3JpdGVPcHRpb25zKTtcbiAgICAgICAgbWV0YWRhdGEgPSBhcHBlbmRIZWFkZXJzKG1ldGFkYXRhLCBlcnJvci5tZXRhZGF0YSk7XG4gICAgfVxuICAgIGxldCBoYXNNZXRhZGF0YSA9IGZhbHNlO1xuICAgIGNvbnN0IG1kID0ge307XG4gICAgbWV0YWRhdGEuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBoYXNNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIG1kW2tleV0gPSBbdmFsdWVdO1xuICAgIH0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKGhhc01ldGFkYXRhKSB7XG4gICAgICAgIGVzLm1ldGFkYXRhID0gbWQ7XG4gICAgfVxuICAgIHJldHVybiBlcztcbn1cbi8qKlxuICogQ3JlYXRlIGEgU2VyaWFsaXphdGlvbiBvYmplY3QgdGhhdCBzZXJpYWxpemVzIGEgQ29ubmVjdCBFbmRTdHJlYW1SZXNwb25zZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVuZFN0cmVhbVNlcmlhbGl6YXRpb24ob3B0aW9ucykge1xuICAgIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VyaWFsaXplKGRhdGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbk9iamVjdCA9IGVuZFN0cmVhbVRvSnNvbihkYXRhLm1ldGFkYXRhLCBkYXRhLmVycm9yLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoanNvbk9iamVjdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHRFbmNvZGVyLmVuY29kZShqc29uU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKGBmYWlsZWQgdG8gc2VyaWFsaXplIEVuZFN0cmVhbVJlc3BvbnNlOiAke219YCwgQ29kZS5JbnRlcm5hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlKGRhdGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZFN0cmVhbUZyb21Kc29uKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYGZhaWxlZCB0byBwYXJzZSBFbmRTdHJlYW1SZXNwb25zZTogJHttfWAsIENvZGUuSW52YWxpZEFyZ3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBoZWFkZXJDb250ZW50VHlwZSA9IFwiQ29udGVudC1UeXBlXCI7XG5leHBvcnQgY29uc3QgaGVhZGVyVW5hcnlDb250ZW50TGVuZ3RoID0gXCJDb250ZW50LUxlbmd0aFwiO1xuZXhwb3J0IGNvbnN0IGhlYWRlclVuYXJ5RW5jb2RpbmcgPSBcIkNvbnRlbnQtRW5jb2RpbmdcIjtcbmV4cG9ydCBjb25zdCBoZWFkZXJTdHJlYW1FbmNvZGluZyA9IFwiQ29ubmVjdC1Db250ZW50LUVuY29kaW5nXCI7XG5leHBvcnQgY29uc3QgaGVhZGVyVW5hcnlBY2NlcHRFbmNvZGluZyA9IFwiQWNjZXB0LUVuY29kaW5nXCI7XG5leHBvcnQgY29uc3QgaGVhZGVyU3RyZWFtQWNjZXB0RW5jb2RpbmcgPSBcIkNvbm5lY3QtQWNjZXB0LUVuY29kaW5nXCI7XG5leHBvcnQgY29uc3QgaGVhZGVyVGltZW91dCA9IFwiQ29ubmVjdC1UaW1lb3V0LU1zXCI7XG5leHBvcnQgY29uc3QgaGVhZGVyUHJvdG9jb2xWZXJzaW9uID0gXCJDb25uZWN0LVByb3RvY29sLVZlcnNpb25cIjtcbmV4cG9ydCBjb25zdCBoZWFkZXJVc2VyQWdlbnQgPSBcIlVzZXItQWdlbnRcIjtcbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4uL2NvZGUuanNcIjtcbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBDb25uZWN0IGVycm9yIGNvZGUgZm9yIHRoZSBnaXZlbiBIVFRQIHN0YXR1cyBjb2RlLlxuICogU2VlIGh0dHBzOi8vY29ubmVjdHJwYy5jb20vZG9jcy9wcm90b2NvbCNlcnJvci1jb2Rlc1xuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29kZUZyb21IdHRwU3RhdHVzKGh0dHBTdGF0dXMpIHtcbiAgICBzd2l0Y2ggKGh0dHBTdGF0dXMpIHtcbiAgICAgICAgY2FzZSA0MDA6IC8vIEJhZCBSZXF1ZXN0XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5JbnZhbGlkQXJndW1lbnQ7XG4gICAgICAgIGNhc2UgNDAxOiAvLyBVbmF1dGhvcml6ZWRcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlVuYXV0aGVudGljYXRlZDtcbiAgICAgICAgY2FzZSA0MDM6IC8vIEZvcmJpZGRlblxuICAgICAgICAgICAgcmV0dXJuIENvZGUuUGVybWlzc2lvbkRlbmllZDtcbiAgICAgICAgY2FzZSA0MDQ6IC8vIE5vdCBGb3VuZFxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVW5pbXBsZW1lbnRlZDtcbiAgICAgICAgY2FzZSA0MDg6IC8vIFJlcXVlc3QgVGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIENvZGUuRGVhZGxpbmVFeGNlZWRlZDtcbiAgICAgICAgY2FzZSA0MDk6IC8vIENvbmZsaWN0XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5BYm9ydGVkO1xuICAgICAgICBjYXNlIDQxMjogLy8gUHJlY29uZGl0aW9uIEZhaWxlZFxuICAgICAgICAgICAgcmV0dXJuIENvZGUuRmFpbGVkUHJlY29uZGl0aW9uO1xuICAgICAgICBjYXNlIDQxMzogLy8gUGF5bG9hZCBUb28gTGFyZ2VcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlJlc291cmNlRXhoYXVzdGVkO1xuICAgICAgICBjYXNlIDQxNTogLy8gVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZVxuICAgICAgICAgICAgcmV0dXJuIENvZGUuSW50ZXJuYWw7XG4gICAgICAgIGNhc2UgNDI5OiAvLyBUb28gTWFueSBSZXF1ZXN0c1xuICAgICAgICAgICAgcmV0dXJuIENvZGUuVW5hdmFpbGFibGU7XG4gICAgICAgIGNhc2UgNDMxOiAvLyBSZXF1ZXN0IEhlYWRlciBGaWVsZHMgVG9vIExhcmdlXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5SZXNvdXJjZUV4aGF1c3RlZDtcbiAgICAgICAgY2FzZSA1MDI6IC8vIEJhZCBHYXRld2F5XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5VbmF2YWlsYWJsZTtcbiAgICAgICAgY2FzZSA1MDM6IC8vIFNlcnZpY2UgVW5hdmFpbGFibGVcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlVuYXZhaWxhYmxlO1xuICAgICAgICBjYXNlIDUwNDogLy8gR2F0ZXdheSBUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5VbmF2YWlsYWJsZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlVua25vd247XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGEgSFRUUCBzdGF0dXMgY29kZSBmb3IgdGhlIGdpdmVuIENvbm5lY3QgY29kZS5cbiAqIFNlZSBodHRwczovL2Nvbm5lY3RycGMuY29tL2RvY3MvcHJvdG9jb2wjZXJyb3ItY29kZXNcbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvZGVUb0h0dHBTdGF0dXMoY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIENvZGUuQ2FuY2VsZWQ6XG4gICAgICAgICAgICByZXR1cm4gNDA4OyAvLyBSZXF1ZXN0IFRpbWVvdXRcbiAgICAgICAgY2FzZSBDb2RlLlVua25vd246XG4gICAgICAgICAgICByZXR1cm4gNTAwOyAvLyBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcbiAgICAgICAgY2FzZSBDb2RlLkludmFsaWRBcmd1bWVudDpcbiAgICAgICAgICAgIHJldHVybiA0MDA7IC8vIEJhZCBSZXF1ZXN0XG4gICAgICAgIGNhc2UgQ29kZS5EZWFkbGluZUV4Y2VlZGVkOlxuICAgICAgICAgICAgcmV0dXJuIDQwODsgLy8gUmVxdWVzdCBUaW1lb3V0XG4gICAgICAgIGNhc2UgQ29kZS5Ob3RGb3VuZDpcbiAgICAgICAgICAgIHJldHVybiA0MDQ7IC8vIE5vdCBGb3VuZFxuICAgICAgICBjYXNlIENvZGUuQWxyZWFkeUV4aXN0czpcbiAgICAgICAgICAgIHJldHVybiA0MDk7IC8vIENvbmZsaWN0XG4gICAgICAgIGNhc2UgQ29kZS5QZXJtaXNzaW9uRGVuaWVkOlxuICAgICAgICAgICAgcmV0dXJuIDQwMzsgLy8gRm9yYmlkZGVuXG4gICAgICAgIGNhc2UgQ29kZS5SZXNvdXJjZUV4aGF1c3RlZDpcbiAgICAgICAgICAgIHJldHVybiA0Mjk7IC8vIFRvbyBNYW55IFJlcXVlc3RzXG4gICAgICAgIGNhc2UgQ29kZS5GYWlsZWRQcmVjb25kaXRpb246XG4gICAgICAgICAgICByZXR1cm4gNDEyOyAvLyBQcmVjb25kaXRpb24gRmFpbGVkXG4gICAgICAgIGNhc2UgQ29kZS5BYm9ydGVkOlxuICAgICAgICAgICAgcmV0dXJuIDQwOTsgLy8gQ29uZmxpY3RcbiAgICAgICAgY2FzZSBDb2RlLk91dE9mUmFuZ2U6XG4gICAgICAgICAgICByZXR1cm4gNDAwOyAvLyBCYWQgUmVxdWVzdFxuICAgICAgICBjYXNlIENvZGUuVW5pbXBsZW1lbnRlZDpcbiAgICAgICAgICAgIHJldHVybiA0MDQ7IC8vIE5vdCBGb3VuZFxuICAgICAgICBjYXNlIENvZGUuSW50ZXJuYWw6XG4gICAgICAgICAgICByZXR1cm4gNTAwOyAvLyBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcbiAgICAgICAgY2FzZSBDb2RlLlVuYXZhaWxhYmxlOlxuICAgICAgICAgICAgcmV0dXJuIDUwMzsgLy8gU2VydmljZSBVbmF2YWlsYWJsZVxuICAgICAgICBjYXNlIENvZGUuRGF0YUxvc3M6XG4gICAgICAgICAgICByZXR1cm4gNTAwOyAvLyBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcbiAgICAgICAgY2FzZSBDb2RlLlVuYXV0aGVudGljYXRlZDpcbiAgICAgICAgICAgIHJldHVybiA0MDE7IC8vIFVuYXV0aG9yaXplZFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDUwMDsgLy8gc2FtZSBhcyBDb2RlVW5rbm93blxuICAgIH1cbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEluIHVuYXJ5IFJQQ3MsIENvbm5lY3QgdHJhbnNwb3J0cyB0cmFpbGluZyBtZXRhZGF0YSBhcyByZXNwb25zZSBoZWFkZXJcbiAqIGZpZWxkcywgcHJlZml4ZWQgd2l0aCBcInRyYWlsZXItXCIuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkZW11eGVzIGhlYWRlcnMgYW5kIHRyYWlsZXJzIGludG8gdHdvIHNlcGFyYXRlIEhlYWRlcnNcbiAqIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFpbGVyRGVtdXgoaGVhZGVyKSB7XG4gICAgY29uc3QgaCA9IG5ldyBIZWFkZXJzKCksIHQgPSBuZXcgSGVhZGVycygpO1xuICAgIGhlYWRlci5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwidHJhaWxlci1cIikpIHtcbiAgICAgICAgICAgIHQuc2V0KGtleS5zdWJzdHJpbmcoOCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGguc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFtoLCB0XTtcbn1cbi8qKlxuICogSW4gdW5hcnkgUlBDcywgQ29ubmVjdCB0cmFuc3BvcnRzIHRyYWlsaW5nIG1ldGFkYXRhIGFzIHJlc3BvbnNlIGhlYWRlclxuICogZmllbGRzLCBwcmVmaXhlZCB3aXRoIFwidHJhaWxlci1cIi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG11eGVzIGEgaGVhZGVyIGFuZCBhIHRyYWlsZXIgaW50byBhIHNpbmdsZSBIZWFkZXJzIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWlsZXJNdXgoaGVhZGVyLCB0cmFpbGVyKSB7XG4gICAgY29uc3QgaCA9IG5ldyBIZWFkZXJzKGhlYWRlcik7XG4gICAgdHJhaWxlci5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGguc2V0KGB0cmFpbGVyLSR7a2V5fWAsIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaDtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBoZWFkZXJQcm90b2NvbFZlcnNpb24gfSBmcm9tIFwiLi9oZWFkZXJzLmpzXCI7XG5pbXBvcnQgeyBwYXJhbUNvbm5lY3RWZXJzaW9uIH0gZnJvbSBcIi4vcXVlcnktcGFyYW1zLmpzXCI7XG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi4vY29ubmVjdC1lcnJvci5qc1wiO1xuaW1wb3J0IHsgQ29kZSB9IGZyb20gXCIuLi9jb2RlLmpzXCI7XG4vKipcbiAqIFRoZSBvbmx5IGtub3cgdmFsdWUgZm9yIHRoZSBoZWFkZXIgQ29ubmVjdC1Qcm90b2NvbC1WZXJzaW9uLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgY29uc3QgcHJvdG9jb2xWZXJzaW9uID0gXCIxXCI7XG4vKipcbiAqIFJlcXVpcmVzIHRoZSBDb25uZWN0LVByb3RvY29sLVZlcnNpb24gaGVhZGVyIHRvIGJlIHByZXNlbnQgd2l0aCB0aGUgZXhwZWN0ZWRcbiAqIHZhbHVlLiBSYWlzZXMgYSBDb25uZWN0RXJyb3Igd2l0aCBDb2RlLkludmFsaWRBcmd1bWVudCBvdGhlcndpc2UuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXF1aXJlUHJvdG9jb2xWZXJzaW9uSGVhZGVyKHJlcXVlc3RIZWFkZXIpIHtcbiAgICBjb25zdCB2ID0gcmVxdWVzdEhlYWRlci5nZXQoaGVhZGVyUHJvdG9jb2xWZXJzaW9uKTtcbiAgICBpZiAodiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKGBtaXNzaW5nIHJlcXVpcmVkIGhlYWRlcjogc2V0ICR7aGVhZGVyUHJvdG9jb2xWZXJzaW9ufSB0byBcIiR7cHJvdG9jb2xWZXJzaW9ufVwiYCwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2ICE9PSBwcm90b2NvbFZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgJHtoZWFkZXJQcm90b2NvbFZlcnNpb259IG11c3QgYmUgXCIke3Byb3RvY29sVmVyc2lvbn1cIjogZ290IFwiJHt2fVwiYCwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgIH1cbn1cbi8qKlxuICogUmVxdWlyZXMgdGhlIGNvbm5lY3QgcXVlcnkgcGFyYW1ldGVyIHRvIGJlIHByZXNlbnQgd2l0aCB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gKiBSYWlzZXMgYSBDb25uZWN0RXJyb3Igd2l0aCBDb2RlLkludmFsaWRBcmd1bWVudCBvdGhlcndpc2UuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXF1aXJlUHJvdG9jb2xWZXJzaW9uUGFyYW0ocXVlcnlQYXJhbXMpIHtcbiAgICBjb25zdCB2ID0gcXVlcnlQYXJhbXMuZ2V0KHBhcmFtQ29ubmVjdFZlcnNpb24pO1xuICAgIGlmICh2ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBzZXQgJHtwYXJhbUNvbm5lY3RWZXJzaW9ufSB0byBcInYke3Byb3RvY29sVmVyc2lvbn1cImAsIENvZGUuSW52YWxpZEFyZ3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodiAhPT0gYHYke3Byb3RvY29sVmVyc2lvbn1gKSB7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYCR7cGFyYW1Db25uZWN0VmVyc2lvbn0gbXVzdCBiZSBcInYke3Byb3RvY29sVmVyc2lvbn1cIjogZ290IFwiJHt2fVwiYCwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgIH1cbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBNZXRob2RLaW5kIH0gZnJvbSBcIkBidWZidWlsZC9wcm90b2J1ZlwiO1xuaW1wb3J0IHsgaGVhZGVyQ29udGVudFR5cGUsIGhlYWRlclN0cmVhbUFjY2VwdEVuY29kaW5nLCBoZWFkZXJTdHJlYW1FbmNvZGluZywgaGVhZGVyVW5hcnlBY2NlcHRFbmNvZGluZywgaGVhZGVyVW5hcnlFbmNvZGluZywgaGVhZGVyVGltZW91dCwgaGVhZGVyUHJvdG9jb2xWZXJzaW9uLCBoZWFkZXJVc2VyQWdlbnQsIH0gZnJvbSBcIi4vaGVhZGVycy5qc1wiO1xuaW1wb3J0IHsgcHJvdG9jb2xWZXJzaW9uIH0gZnJvbSBcIi4vdmVyc2lvbi5qc1wiO1xuaW1wb3J0IHsgY29udGVudFR5cGVTdHJlYW1Kc29uLCBjb250ZW50VHlwZVN0cmVhbVByb3RvLCBjb250ZW50VHlwZVVuYXJ5SnNvbiwgY29udGVudFR5cGVVbmFyeVByb3RvLCB9IGZyb20gXCIuL2NvbnRlbnQtdHlwZS5qc1wiO1xuLyoqXG4gKiBDcmVhdGVzIGhlYWRlcnMgZm9yIGEgQ29ubmVjdCByZXF1ZXN0LlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdEhlYWRlcihtZXRob2RLaW5kLCB1c2VCaW5hcnlGb3JtYXQsIHRpbWVvdXRNcywgdXNlclByb3ZpZGVkSGVhZGVycykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBIZWFkZXJzKHVzZXJQcm92aWRlZEhlYWRlcnMgIT09IG51bGwgJiYgdXNlclByb3ZpZGVkSGVhZGVycyAhPT0gdm9pZCAwID8gdXNlclByb3ZpZGVkSGVhZGVycyA6IHt9KTtcbiAgICBpZiAodGltZW91dE1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LnNldChoZWFkZXJUaW1lb3V0LCBgJHt0aW1lb3V0TXN9YCk7XG4gICAgfVxuICAgIHJlc3VsdC5zZXQoaGVhZGVyQ29udGVudFR5cGUsIG1ldGhvZEtpbmQgPT0gTWV0aG9kS2luZC5VbmFyeVxuICAgICAgICA/IHVzZUJpbmFyeUZvcm1hdFxuICAgICAgICAgICAgPyBjb250ZW50VHlwZVVuYXJ5UHJvdG9cbiAgICAgICAgICAgIDogY29udGVudFR5cGVVbmFyeUpzb25cbiAgICAgICAgOiB1c2VCaW5hcnlGb3JtYXRcbiAgICAgICAgICAgID8gY29udGVudFR5cGVTdHJlYW1Qcm90b1xuICAgICAgICAgICAgOiBjb250ZW50VHlwZVN0cmVhbUpzb24pO1xuICAgIHJlc3VsdC5zZXQoaGVhZGVyUHJvdG9jb2xWZXJzaW9uLCBwcm90b2NvbFZlcnNpb24pO1xuICAgIHJlc3VsdC5zZXQoaGVhZGVyVXNlckFnZW50LCBcImNvbm5lY3QtZXMvMS4xLjNcIik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ3JlYXRlcyBoZWFkZXJzIGZvciBhIENvbm5lY3QgcmVxdWVzdCB3aXRoIGNvbXByZXNzaW9uLlxuICpcbiAqIE5vdGUgdGhhdCB3ZSBhbHdheXMgc2V0IHRoZSBDb250ZW50LUVuY29kaW5nIGhlYWRlciBmb3IgdW5hcnkgbWV0aG9kcy5cbiAqIEl0IGlzIHVwIHRvIHRoZSBjYWxsZXIgdG8gZGVjaWRlIHdoZXRoZXIgdG8gYXBwbHkgY29tcHJlc3Npb24gLSBhbmQgcmVtb3ZlXG4gKiB0aGUgaGVhZGVyIGlmIGNvbXByZXNzaW9uIGlzIG5vdCB1c2VkLCBmb3IgZXhhbXBsZSBiZWNhdXNlIHRoZSBwYXlsb2FkIGlzXG4gKiB0b28gc21hbGwgdG8gbWFrZSBjb21wcmVzc2lvbiBlZmZlY3RpdmUuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXF1ZXN0SGVhZGVyV2l0aENvbXByZXNzaW9uKG1ldGhvZEtpbmQsIHVzZUJpbmFyeUZvcm1hdCwgdGltZW91dE1zLCB1c2VyUHJvdmlkZWRIZWFkZXJzLCBhY2NlcHRDb21wcmVzc2lvbiwgc2VuZENvbXByZXNzaW9uKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcmVxdWVzdEhlYWRlcihtZXRob2RLaW5kLCB1c2VCaW5hcnlGb3JtYXQsIHRpbWVvdXRNcywgdXNlclByb3ZpZGVkSGVhZGVycyk7XG4gICAgaWYgKHNlbmRDb21wcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBtZXRob2RLaW5kID09IE1ldGhvZEtpbmQuVW5hcnlcbiAgICAgICAgICAgID8gaGVhZGVyVW5hcnlFbmNvZGluZ1xuICAgICAgICAgICAgOiBoZWFkZXJTdHJlYW1FbmNvZGluZztcbiAgICAgICAgcmVzdWx0LnNldChuYW1lLCBzZW5kQ29tcHJlc3Npb24ubmFtZSk7XG4gICAgfVxuICAgIGlmIChhY2NlcHRDb21wcmVzc2lvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBtZXRob2RLaW5kID09IE1ldGhvZEtpbmQuVW5hcnlcbiAgICAgICAgICAgID8gaGVhZGVyVW5hcnlBY2NlcHRFbmNvZGluZ1xuICAgICAgICAgICAgOiBoZWFkZXJTdHJlYW1BY2NlcHRFbmNvZGluZztcbiAgICAgICAgcmVzdWx0LnNldChuYW1lLCBhY2NlcHRDb21wcmVzc2lvbi5tYXAoKGMpID0+IGMubmFtZSkuam9pbihcIixcIikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IE1ldGhvZEtpbmQgfSBmcm9tIFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4uL2NvZGUuanNcIjtcbmltcG9ydCB7IGNvZGVGcm9tSHR0cFN0YXR1cyB9IGZyb20gXCIuL2h0dHAtc3RhdHVzLmpzXCI7XG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi4vY29ubmVjdC1lcnJvci5qc1wiO1xuaW1wb3J0IHsgcGFyc2VDb250ZW50VHlwZSB9IGZyb20gXCIuL2NvbnRlbnQtdHlwZS5qc1wiO1xuaW1wb3J0IHsgaGVhZGVyU3RyZWFtRW5jb2RpbmcsIGhlYWRlclVuYXJ5RW5jb2RpbmcgfSBmcm9tIFwiLi9oZWFkZXJzLmpzXCI7XG4vKipcbiAqIFZhbGlkYXRlcyByZXNwb25zZSBzdGF0dXMgYW5kIGhlYWRlciBmb3IgdGhlIENvbm5lY3QgcHJvdG9jb2wuXG4gKiBUaHJvd3MgYSBDb25uZWN0RXJyb3IgaWYgdGhlIGhlYWRlciBpbmRpY2F0ZXMgYW4gZXJyb3IsIG9yIGlmXG4gKiB0aGUgY29udGVudCB0eXBlIGlzIHVuZXhwZWN0ZWQsIHdpdGggdGhlIGZvbGxvd2luZyBleGNlcHRpb246XG4gKiBGb3IgdW5hcnkgUlBDcyB3aXRoIGFuIEhUVFAgZXJyb3Igc3RhdHVzLCB0aGlzIHJldHVybnMgYW4gZXJyb3JcbiAqIGRlcml2ZWQgZnJvbSB0aGUgSFRUUCBzdGF0dXMgaW5zdGVhZCBvZiB0aHJvd2luZyBpdCwgZ2l2aW5nIGFuXG4gKiBpbXBsZW1lbnRhdGlvbiBhIGNoYW5jZSB0byBwYXJzZSBhIENvbm5lY3QgZXJyb3IgZnJvbSB0aGUgd2lyZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUmVzcG9uc2UobWV0aG9kS2luZCwgc3RhdHVzLCBoZWFkZXJzKSB7XG4gICAgY29uc3QgbWltZVR5cGUgPSBoZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gcGFyc2VDb250ZW50VHlwZShtaW1lVHlwZSk7XG4gICAgaWYgKHN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRnJvbVN0YXR1cyA9IG5ldyBDb25uZWN0RXJyb3IoYEhUVFAgJHtzdGF0dXN9YCwgY29kZUZyb21IdHRwU3RhdHVzKHN0YXR1cyksIGhlYWRlcnMpO1xuICAgICAgICAvLyBJZiBwYXJzZWRUeXBlIGlzIGRlZmluZWQgYW5kIGl0IGlzIG5vdCBiaW5hcnksIHRoZW4gdGhpcyBpcyBhIHVuYXJ5IEpTT04gcmVzcG9uc2VcbiAgICAgICAgaWYgKG1ldGhvZEtpbmQgPT0gTWV0aG9kS2luZC5VbmFyeSAmJiBwYXJzZWRUeXBlICYmICFwYXJzZWRUeXBlLmJpbmFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaXNVbmFyeUVycm9yOiB0cnVlLCB1bmFyeUVycm9yOiBlcnJvckZyb21TdGF0dXMgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvckZyb21TdGF0dXM7XG4gICAgfVxuICAgIHJldHVybiB7IGlzVW5hcnlFcnJvcjogZmFsc2UgfTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIHJlc3BvbnNlIHN0YXR1cyBhbmQgaGVhZGVyIGZvciB0aGUgQ29ubmVjdCBwcm90b2NvbC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgaWRlbnRpY2FsIHRvIHZhbGlkYXRlUmVzcG9uc2UoKSwgYnV0IGFsc28gdmVyaWZpZXNcbiAqIHRoYXQgYSBnaXZlbiBlbmNvZGluZyBoZWFkZXIgaXMgYWNjZXB0YWJsZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVSZXNwb25zZVdpdGhDb21wcmVzc2lvbihtZXRob2RLaW5kLCBhY2NlcHRDb21wcmVzc2lvbiwgc3RhdHVzLCBoZWFkZXJzKSB7XG4gICAgbGV0IGNvbXByZXNzaW9uO1xuICAgIGNvbnN0IGVuY29kaW5nID0gaGVhZGVycy5nZXQobWV0aG9kS2luZCA9PSBNZXRob2RLaW5kLlVuYXJ5ID8gaGVhZGVyVW5hcnlFbmNvZGluZyA6IGhlYWRlclN0cmVhbUVuY29kaW5nKTtcbiAgICBpZiAoZW5jb2RpbmcgIT0gbnVsbCAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpICE9PSBcImlkZW50aXR5XCIpIHtcbiAgICAgICAgY29tcHJlc3Npb24gPSBhY2NlcHRDb21wcmVzc2lvbi5maW5kKChjKSA9PiBjLm5hbWUgPT09IGVuY29kaW5nKTtcbiAgICAgICAgaWYgKCFjb21wcmVzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgdW5zdXBwb3J0ZWQgcmVzcG9uc2UgZW5jb2RpbmcgXCIke2VuY29kaW5nfVwiYCwgQ29kZS5JbnZhbGlkQXJndW1lbnQsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgY29tcHJlc3Npb24gfSwgdmFsaWRhdGVSZXNwb25zZShtZXRob2RLaW5kLCBzdGF0dXMsIGhlYWRlcnMpKTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBNZXNzYWdlLCBwcm90b0Jhc2U2NCB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbmltcG9ydCB7IGhlYWRlckNvbnRlbnRUeXBlLCBoZWFkZXJQcm90b2NvbFZlcnNpb24sIGhlYWRlclVuYXJ5QWNjZXB0RW5jb2RpbmcsIGhlYWRlclVuYXJ5Q29udGVudExlbmd0aCwgaGVhZGVyVW5hcnlFbmNvZGluZywgfSBmcm9tIFwiLi9oZWFkZXJzLmpzXCI7XG5pbXBvcnQgeyBwcm90b2NvbFZlcnNpb24gfSBmcm9tIFwiLi92ZXJzaW9uLmpzXCI7XG5jb25zdCBjb250ZW50VHlwZVByZWZpeCA9IFwiYXBwbGljYXRpb24vXCI7XG5mdW5jdGlvbiBlbmNvZGVNZXNzYWdlRm9yVXJsKG1lc3NhZ2UsIHVzZUJhc2U2NCkge1xuICAgIGlmICh1c2VCYXNlNjQpIHtcbiAgICAgICAgLy8gVE9ETyhqY2hhZHdpY2stYnVmKTogVGhyZWUgcmVnZXggcmVwbGFjZXMgc2VlbXMgZXhjZXNzaXZlLlxuICAgICAgICAvLyBDYW4gd2UgbWFrZSBwcm90b0Jhc2U2NC5lbmMgbW9yZSBmbGV4aWJsZT9cbiAgICAgICAgcmV0dXJuIHByb3RvQmFzZTY0XG4gICAgICAgICAgICAuZW5jKG1lc3NhZ2UpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwrL2csIFwiLVwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCBcIl9cIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC89KyQvLCBcIlwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKG1lc3NhZ2UpKTtcbiAgICB9XG59XG4vKipcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtQ29ubmVjdFBvc3RUb0dldFJlcXVlc3QocmVxdWVzdCwgbWVzc2FnZSwgdXNlQmFzZTY0KSB7XG4gICAgbGV0IHF1ZXJ5ID0gYD9jb25uZWN0PXYke3Byb3RvY29sVmVyc2lvbn1gO1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVxdWVzdC5oZWFkZXIuZ2V0KGhlYWRlckNvbnRlbnRUeXBlKTtcbiAgICBpZiAoKGNvbnRlbnRUeXBlID09PSBudWxsIHx8IGNvbnRlbnRUeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZW50VHlwZS5pbmRleE9mKGNvbnRlbnRUeXBlUHJlZml4KSkgPT09IDApIHtcbiAgICAgICAgcXVlcnkgKz1cbiAgICAgICAgICAgIFwiJmVuY29kaW5nPVwiICtcbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoY29udGVudFR5cGUuc2xpY2UoY29udGVudFR5cGVQcmVmaXgubGVuZ3RoKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXByZXNzaW9uID0gcmVxdWVzdC5oZWFkZXIuZ2V0KGhlYWRlclVuYXJ5RW5jb2RpbmcpO1xuICAgIGlmIChjb21wcmVzc2lvbiAhPT0gbnVsbCAmJiBjb21wcmVzc2lvbiAhPT0gXCJpZGVudGl0eVwiKSB7XG4gICAgICAgIHF1ZXJ5ICs9IFwiJmNvbXByZXNzaW9uPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGNvbXByZXNzaW9uKTtcbiAgICAgICAgLy8gRm9yY2UgYmFzZTY0IGZvciBjb21wcmVzc2VkIHBheWxvYWRzLlxuICAgICAgICB1c2VCYXNlNjQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodXNlQmFzZTY0KSB7XG4gICAgICAgIHF1ZXJ5ICs9IFwiJmJhc2U2ND0xXCI7XG4gICAgfVxuICAgIHF1ZXJ5ICs9IFwiJm1lc3NhZ2U9XCIgKyBlbmNvZGVNZXNzYWdlRm9yVXJsKG1lc3NhZ2UsIHVzZUJhc2U2NCk7XG4gICAgY29uc3QgdXJsID0gcmVxdWVzdC51cmwgKyBxdWVyeTtcbiAgICAvLyBPbWl0IGhlYWRlcnMgdGhhdCBhcmUgbm90IHVzZWQgZm9yIHVuYXJ5IEdFVCByZXF1ZXN0cy5cbiAgICBjb25zdCBoZWFkZXIgPSBuZXcgSGVhZGVycyhyZXF1ZXN0LmhlYWRlcik7XG4gICAgW1xuICAgICAgICBoZWFkZXJQcm90b2NvbFZlcnNpb24sXG4gICAgICAgIGhlYWRlckNvbnRlbnRUeXBlLFxuICAgICAgICBoZWFkZXJVbmFyeUNvbnRlbnRMZW5ndGgsXG4gICAgICAgIGhlYWRlclVuYXJ5RW5jb2RpbmcsXG4gICAgICAgIGhlYWRlclVuYXJ5QWNjZXB0RW5jb2RpbmcsXG4gICAgXS5mb3JFYWNoKChoKSA9PiBoZWFkZXIuZGVsZXRlKGgpKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBpbml0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QuaW5pdCksIHsgbWV0aG9kOiBcIkdFVFwiIH0pLCB1cmwsXG4gICAgICAgIGhlYWRlciB9KTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi4vY29ubmVjdC1lcnJvci5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlRGVhZGxpbmVTaWduYWwsIGNyZWF0ZUxpbmtlZEFib3J0Q29udHJvbGxlciwgZ2V0QWJvcnRTaWduYWxSZWFzb24sIH0gZnJvbSBcIi4vc2lnbmFscy5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplLCBub3JtYWxpemVJdGVyYWJsZSB9IGZyb20gXCIuL25vcm1hbGl6ZS5qc1wiO1xuLyoqXG4gKiBSdW5zIGEgdW5hcnkgbWV0aG9kIHdpdGggdGhlIGdpdmVuIGludGVyY2VwdG9ycy4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb25cbiAqIGlzIG9ubHkgdXNlZCB3aGVuIGltcGxlbWVudGluZyBhIFRyYW5zcG9ydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1blVuYXJ5Q2FsbChvcHQpIHtcbiAgICBjb25zdCBuZXh0ID0gYXBwbHlJbnRlcmNlcHRvcnMob3B0Lm5leHQsIG9wdC5pbnRlcmNlcHRvcnMpO1xuICAgIGNvbnN0IFtzaWduYWwsIGFib3J0LCBkb25lXSA9IHNldHVwU2lnbmFsKG9wdCk7XG4gICAgY29uc3QgcmVxID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHQucmVxKSwgeyBtZXNzYWdlOiBub3JtYWxpemUob3B0LnJlcS5tZXRob2QuSSwgb3B0LnJlcS5tZXNzYWdlKSwgc2lnbmFsIH0pO1xuICAgIHJldHVybiBuZXh0KHJlcSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCBhYm9ydCk7XG59XG4vKipcbiAqIFJ1bnMgYSBzZXJ2ZXItc3RyZWFtaW5nIG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBpbnRlcmNlcHRvcnMuIE5vdGUgdGhhdCB0aGlzXG4gKiBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgd2hlbiBpbXBsZW1lbnRpbmcgYSBUcmFuc3BvcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5TdHJlYW1pbmdDYWxsKG9wdCkge1xuICAgIGNvbnN0IG5leHQgPSBhcHBseUludGVyY2VwdG9ycyhvcHQubmV4dCwgb3B0LmludGVyY2VwdG9ycyk7XG4gICAgY29uc3QgW3NpZ25hbCwgYWJvcnQsIGRvbmVdID0gc2V0dXBTaWduYWwob3B0KTtcbiAgICBjb25zdCByZXEgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdC5yZXEpLCB7IG1lc3NhZ2U6IG5vcm1hbGl6ZUl0ZXJhYmxlKG9wdC5yZXEubWV0aG9kLkksIG9wdC5yZXEubWVzc2FnZSksIHNpZ25hbCB9KTtcbiAgICBsZXQgZG9uZUNhbGxlZCA9IGZhbHNlO1xuICAgIC8vIENhbGwgcmV0dXJuIG9uIHRoZSByZXF1ZXN0IGl0ZXJhYmxlIHRvIGluZGljYXRlXG4gICAgLy8gdGhhdCB3ZSB3aWxsIG5vIGxvbmdlciBjb25zdW1lIGl0IGFuZCBpdCBzaG91bGRcbiAgICAvLyBjbGVhbnVwIGFueSBhbGxvY2F0ZWQgcmVzb3VyY2VzLlxuICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBpdCA9IG9wdC5yZXEubWVzc2FnZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAgICAgLy8gSWYgdGhlIHNpZ25hbCBpcyBhYm9ydGVkIGR1ZSB0byBhbiBlcnJvciwgd2Ugd2FudCB0byB0aHJvd1xuICAgICAgICAvLyB0aGUgZXJyb3IgdG8gdGhlIHJlcXVlc3QgaXRlcmF0b3IuXG4gICAgICAgIGlmICghZG9uZUNhbGxlZCkge1xuICAgICAgICAgICAgKF9hID0gaXQudGhyb3cpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGl0LCB0aGlzLnJlYXNvbikuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHRocm93IHJldHVybnMgYSBwcm9taXNlLCB3aGljaCB3ZSBkb24ndCBjYXJlIGFib3V0LlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVW5jYXVnaHQgcHJvbWlzZXMgYXJlIHRocm93biBhdCBzb21ldGltZS9zb21ld2hlcmUgYnkgdGhlIGV2ZW50IGxvb3AsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBlbnN1cmUgZXJyb3IgaXMgY2F1Z2h0IGFuZCBpZ25vcmVkLlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gaXQucmV0dXJuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChpdCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gcmV0dXJuIHJldHVybnMgYSBwcm9taXNlLCB3aGljaCB3ZSBkb24ndCBjYXJlIGFib3V0LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFVuY2F1Z2h0IHByb21pc2VzIGFyZSB0aHJvd24gYXQgc29tZXRpbWUvc29tZXdoZXJlIGJ5IHRoZSBldmVudCBsb29wLFxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBlbnN1cmUgZXJyb3IgaXMgY2F1Z2h0IGFuZCBpZ25vcmVkLlxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dChyZXEpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXMpLCB7IG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHJlcy5tZXNzYWdlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXQubmV4dCgpLnRoZW4oKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuZG9uZSA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBhYm9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZGVsaWJlcmF0ZWx5IG9taXQgdGhyb3cvcmV0dXJuLlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9IH0pO1xuICAgIH0sIGFib3J0KTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIEFib3J0U2lnbmFsIGZvciBUcmFuc3BvcnQgaW1wbGVtZW50YXRpb25zLiBUaGUgc2lnbmFsIGlzIGF2YWlsYWJsZVxuICogaW4gVW5hcnlSZXF1ZXN0IGFuZCBTdHJlYW1pbmdSZXF1ZXN0LCBhbmQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNhbGwgaXNcbiAqIGFib3J0ZWQgKHZpYSBhIHRpbWVvdXQgb3IgZXhwbGljaXQgY2FuY2VsbGF0aW9uKSwgZXJyb3JlZCAoZS5nLiB3aGVuIHJlYWRpbmdcbiAqIGFuIGVycm9yIGZyb20gdGhlIHNlcnZlciBmcm9tIHRoZSB3aXJlKSwgb3IgZmluaXNoZWQgc3VjY2Vzc2Z1bGx5LlxuICpcbiAqIFRyYW5zcG9ydCBpbXBsZW1lbnRhdGlvbnMgY2FuIHBhc3MgdGhlIHNpZ25hbCB0byBIVFRQIGNsaWVudHMgdG8gZW5zdXJlIHRoYXRcbiAqIHRoZXJlIGFyZSBubyB1bnVzZWQgY29ubmVjdGlvbnMgbGVhay5cbiAqXG4gKiBSZXR1cm5zIGEgdHVwbGU6XG4gKiBbMF06IFRoZSBzaWduYWwsIHdoaWNoIGlzIGFsc28gYWJvcnRlZCBpZiB0aGUgb3B0aW9uYWwgZGVhZGxpbmUgaXMgcmVhY2hlZC5cbiAqIFsxXTogRnVuY3Rpb24gdG8gY2FsbCBpZiB0aGUgVHJhbnNwb3J0IGVuY291bnRlcmVkIGFuIGVycm9yLlxuICogWzJdOiBGdW5jdGlvbiB0byBjYWxsIGlmIHRoZSBUcmFuc3BvcnQgZmluaXNoZWQgd2l0aG91dCBhbiBlcnJvci5cbiAqL1xuZnVuY3Rpb24gc2V0dXBTaWduYWwob3B0KSB7XG4gICAgY29uc3QgeyBzaWduYWwsIGNsZWFudXAgfSA9IGNyZWF0ZURlYWRsaW5lU2lnbmFsKG9wdC50aW1lb3V0TXMpO1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBjcmVhdGVMaW5rZWRBYm9ydENvbnRyb2xsZXIob3B0LnNpZ25hbCwgc2lnbmFsKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgZnVuY3Rpb24gYWJvcnQocmVhc29uKSB7XG4gICAgICAgICAgICAvLyBXZSBwZWVrIGF0IHRoZSBkZWFkbGluZSBzaWduYWwgYmVjYXVzZSBmZXRjaCgpIHdpbGwgdGhyb3cgYW4gZXJyb3Igb25cbiAgICAgICAgICAgIC8vIGFib3J0IHRoYXQgZGlzY2FyZHMgdGhlIHNpZ25hbCByZWFzb24uXG4gICAgICAgICAgICBjb25zdCBlID0gQ29ubmVjdEVycm9yLmZyb20oc2lnbmFsLmFib3J0ZWQgPyBnZXRBYm9ydFNpZ25hbFJlYXNvbihzaWduYWwpIDogcmVhc29uKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoZSk7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH0sXG4gICAgXTtcbn1cbi8qKlxuICogYXBwbHlJbnRlcmNlcHRvcnMgdGFrZXMgdGhlIGdpdmVuIFVuYXJ5Rm4gb3IgU2VydmVyU3RyZWFtaW5nRm4sIGFuZCB3cmFwc1xuICogaXQgd2l0aCBlYWNoIG9mIHRoZSBnaXZlbiBpbnRlcmNlcHRvcnMsIHJldHVybmluZyBhIG5ldyBVbmFyeUZuIG9yXG4gKiBTZXJ2ZXJTdHJlYW1pbmdGbi5cbiAqL1xuZnVuY3Rpb24gYXBwbHlJbnRlcmNlcHRvcnMobmV4dCwgaW50ZXJjZXB0b3JzKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gaW50ZXJjZXB0b3JzID09PSBudWxsIHx8IGludGVyY2VwdG9ycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0b3JzLmNvbmNhdCgpLnJldmVyc2UoKS5yZWR1Y2UoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAobiwgaSkgPT4gaShuKSwgbmV4dCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5leHQpO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBmZXRjaCBBUEkgaXMgYXZhaWxhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RmV0Y2hBcGkoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IEhlYWRlcnMoKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29ubmVjdC13ZWIgcmVxdWlyZXMgdGhlIGZldGNoIEFQSS4gQXJlIHlvdSBydW5uaW5nIG9uIGFuIG9sZCB2ZXJzaW9uIG9mIE5vZGUuanM/IE5vZGUuanMgaXMgbm90IHN1cHBvcnRlZCBpbiBDb25uZWN0IGZvciBXZWIgLSBwbGVhc2Ugc3RheSB0dW5lZCBmb3IgQ29ubmVjdCBmb3IgTm9kZS5cIik7XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2F3YWl0ID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0KSB8fCBmdW5jdGlvbiAodikgeyByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTsgfVxudmFyIF9fYXN5bmNHZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNHZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn07XG5pbXBvcnQgeyBNZXNzYWdlLCBNZXRob2RJZGVtcG90ZW5jeSwgTWV0aG9kS2luZCB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbmltcG9ydCB7IGFwcGVuZEhlYWRlcnMsIGNyZWF0ZUNvbnRleHRWYWx1ZXMgfSBmcm9tIFwiQGNvbm5lY3RycGMvY29ubmVjdFwiO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50TWV0aG9kU2VyaWFsaXplcnMsIGNyZWF0ZUVudmVsb3BlUmVhZGFibGVTdHJlYW0sIGNyZWF0ZU1ldGhvZFVybCwgZ2V0SnNvbk9wdGlvbnMsIGVuY29kZUVudmVsb3BlLCBydW5TdHJlYW1pbmdDYWxsLCBydW5VbmFyeUNhbGwsIH0gZnJvbSBcIkBjb25uZWN0cnBjL2Nvbm5lY3QvcHJvdG9jb2xcIjtcbmltcG9ydCB7IGVuZFN0cmVhbUZsYWcsIGVuZFN0cmVhbUZyb21Kc29uLCBlcnJvckZyb21Kc29uLCByZXF1ZXN0SGVhZGVyLCB0cmFpbGVyRGVtdXgsIHRyYW5zZm9ybUNvbm5lY3RQb3N0VG9HZXRSZXF1ZXN0LCB2YWxpZGF0ZVJlc3BvbnNlLCB9IGZyb20gXCJAY29ubmVjdHJwYy9jb25uZWN0L3Byb3RvY29sLWNvbm5lY3RcIjtcbmltcG9ydCB7IGFzc2VydEZldGNoQXBpIH0gZnJvbSBcIi4vYXNzZXJ0LWZldGNoLWFwaS5qc1wiO1xuLyoqXG4gKiBDcmVhdGUgYSBUcmFuc3BvcnQgZm9yIHRoZSBDb25uZWN0IHByb3RvY29sLCB3aGljaCBtYWtlcyB1bmFyeSBhbmRcbiAqIHNlcnZlci1zdHJlYW1pbmcgbWV0aG9kcyBhdmFpbGFibGUgdG8gd2ViIGJyb3dzZXJzLiBJdCB1c2VzIHRoZSBmZXRjaFxuICogQVBJIHRvIG1ha2UgSFRUUCByZXF1ZXN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3RUcmFuc3BvcnQob3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBhc3NlcnRGZXRjaEFwaSgpO1xuICAgIGNvbnN0IHVzZUJpbmFyeUZvcm1hdCA9IChfYSA9IG9wdGlvbnMudXNlQmluYXJ5Rm9ybWF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhc3luYyB1bmFyeShzZXJ2aWNlLCBtZXRob2QsIHNpZ25hbCwgdGltZW91dE1zLCBoZWFkZXIsIG1lc3NhZ2UsIGNvbnRleHRWYWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VyaWFsaXplLCBwYXJzZSB9ID0gY3JlYXRlQ2xpZW50TWV0aG9kU2VyaWFsaXplcnMobWV0aG9kLCB1c2VCaW5hcnlGb3JtYXQsIG9wdGlvbnMuanNvbk9wdGlvbnMsIG9wdGlvbnMuYmluYXJ5T3B0aW9ucyk7XG4gICAgICAgICAgICB0aW1lb3V0TXMgPVxuICAgICAgICAgICAgICAgIHRpbWVvdXRNcyA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5kZWZhdWx0VGltZW91dE1zXG4gICAgICAgICAgICAgICAgICAgIDogdGltZW91dE1zIDw9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRpbWVvdXRNcztcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBydW5VbmFyeUNhbGwoe1xuICAgICAgICAgICAgICAgIGludGVyY2VwdG9yczogb3B0aW9ucy5pbnRlcmNlcHRvcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgICAgIHRpbWVvdXRNcyxcbiAgICAgICAgICAgICAgICByZXE6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGNyZWF0ZU1ldGhvZFVybChvcHRpb25zLmJhc2VVcmwsIHNlcnZpY2UsIG1ldGhvZCksXG4gICAgICAgICAgICAgICAgICAgIGluaXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogKF9hID0gb3B0aW9ucy5jcmVkZW50aWFscykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJzYW1lLW9yaWdpblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3Q6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiY29yc1wiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IHJlcXVlc3RIZWFkZXIobWV0aG9kLmtpbmQsIHVzZUJpbmFyeUZvcm1hdCwgdGltZW91dE1zLCBoZWFkZXIpLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0VmFsdWVzOiBjb250ZXh0VmFsdWVzICE9PSBudWxsICYmIGNvbnRleHRWYWx1ZXMgIT09IHZvaWQgMCA/IGNvbnRleHRWYWx1ZXMgOiBjcmVhdGVDb250ZXh0VmFsdWVzKCksXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuZXh0OiBhc3luYyAocmVxKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlR2V0ID0gb3B0aW9ucy51c2VIdHRwR2V0ID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QuaWRlbXBvdGVuY3kgPT09IE1ldGhvZElkZW1wb3RlbmN5Lk5vU2lkZUVmZmVjdHM7XG4gICAgICAgICAgICAgICAgICAgIGxldCBib2R5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZUdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gdHJhbnNmb3JtQ29ubmVjdFBvc3RUb0dldFJlcXVlc3QocmVxLCBzZXJpYWxpemUocmVxLm1lc3NhZ2UpLCB1c2VCaW5hcnlGb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IHNlcmlhbGl6ZShyZXEubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmV0Y2ggPSAoX2EgPSBvcHRpb25zLmZldGNoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBnbG9iYWxUaGlzLmZldGNoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcS51cmwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxLmluaXQpLCB7IGhlYWRlcnM6IHJlcS5oZWFkZXIsIHNpZ25hbDogcmVxLnNpZ25hbCwgYm9keSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNVbmFyeUVycm9yLCB1bmFyeUVycm9yIH0gPSB2YWxpZGF0ZVJlc3BvbnNlKG1ldGhvZC5raW5kLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmFyeUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvckZyb21Kc29uKChhd2FpdCByZXNwb25zZS5qc29uKCkpLCBhcHBlbmRIZWFkZXJzKC4uLnRyYWlsZXJEZW11eChyZXNwb25zZS5oZWFkZXJzKSksIHVuYXJ5RXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtkZW11eGVkSGVhZGVyLCBkZW11eGVkVHJhaWxlcl0gPSB0cmFpbGVyRGVtdXgocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcjogZGVtdXhlZEhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHVzZUJpbmFyeUZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyc2UobmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtZXRob2QuTy5mcm9tSnNvbigoYXdhaXQgcmVzcG9uc2UuanNvbigpKSwgZ2V0SnNvbk9wdGlvbnMob3B0aW9ucy5qc29uT3B0aW9ucykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxlcjogZGVtdXhlZFRyYWlsZXIsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBzdHJlYW0oc2VydmljZSwgbWV0aG9kLCBzaWduYWwsIHRpbWVvdXRNcywgaGVhZGVyLCBpbnB1dCwgY29udGV4dFZhbHVlcykge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgeyBzZXJpYWxpemUsIHBhcnNlIH0gPSBjcmVhdGVDbGllbnRNZXRob2RTZXJpYWxpemVycyhtZXRob2QsIHVzZUJpbmFyeUZvcm1hdCwgb3B0aW9ucy5qc29uT3B0aW9ucywgb3B0aW9ucy5iaW5hcnlPcHRpb25zKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VCb2R5KGJvZHksIHRyYWlsZXJUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBwYXJzZVJlc3BvbnNlQm9keV8xKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBjcmVhdGVFbnZlbG9wZVJlYWRhYmxlU3RyZWFtKGJvZHkpLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kU3RyZWFtUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgX19hd2FpdChyZWFkZXIucmVhZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmbGFncywgZGF0YSB9ID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChmbGFncyAmIGVuZFN0cmVhbUZsYWcpID09PSBlbmRTdHJlYW1GbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kU3RyZWFtUmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZFN0cmVhbSA9IGVuZFN0cmVhbUZyb21Kc29uKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRTdHJlYW0uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZW5kU3RyZWFtLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRTdHJlYW0ubWV0YWRhdGEuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdHJhaWxlclRhcmdldC5zZXQoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChwYXJzZShkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRTdHJlYW1SZWNlaXZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJtaXNzaW5nIEVuZFN0cmVhbVJlc3BvbnNlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RCb2R5KGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZC5raW5kICE9IE1ldGhvZEtpbmQuU2VydmVyU3RyZWFtaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiVGhlIGZldGNoIEFQSSBkb2VzIG5vdCBzdXBwb3J0IHN0cmVhbWluZyByZXF1ZXN0IGJvZGllc1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByID0gYXdhaXQgaW5wdXRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChyLmRvbmUgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIm1pc3NpbmcgcmVxdWVzdCBtZXNzYWdlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVFbnZlbG9wZSgwLCBzZXJpYWxpemUoci52YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZW91dE1zID1cbiAgICAgICAgICAgICAgICB0aW1lb3V0TXMgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuZGVmYXVsdFRpbWVvdXRNc1xuICAgICAgICAgICAgICAgICAgICA6IHRpbWVvdXRNcyA8PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aW1lb3V0TXM7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcnVuU3RyZWFtaW5nQ2FsbCh7XG4gICAgICAgICAgICAgICAgaW50ZXJjZXB0b3JzOiBvcHRpb25zLmludGVyY2VwdG9ycyxcbiAgICAgICAgICAgICAgICB0aW1lb3V0TXMsXG4gICAgICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgICAgIHJlcToge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW06IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjcmVhdGVNZXRob2RVcmwob3B0aW9ucy5iYXNlVXJsLCBzZXJ2aWNlLCBtZXRob2QpLFxuICAgICAgICAgICAgICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IChfYSA9IG9wdGlvbnMuY3JlZGVudGlhbHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwic2FtZS1vcmlnaW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0OiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImNvcnNcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiByZXF1ZXN0SGVhZGVyKG1ldGhvZC5raW5kLCB1c2VCaW5hcnlGb3JtYXQsIHRpbWVvdXRNcywgaGVhZGVyKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFZhbHVlczogY29udGV4dFZhbHVlcyAhPT0gbnVsbCAmJiBjb250ZXh0VmFsdWVzICE9PSB2b2lkIDAgPyBjb250ZXh0VmFsdWVzIDogY3JlYXRlQ29udGV4dFZhbHVlcygpLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBpbnB1dCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5leHQ6IGFzeW5jIChyZXEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaCA9IChfYSA9IG9wdGlvbnMuZmV0Y2gpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGdsb2JhbFRoaXMuZmV0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZSZXMgPSBhd2FpdCBmZXRjaChyZXEudXJsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcS5pbml0KSwgeyBoZWFkZXJzOiByZXEuaGVhZGVyLCBzaWduYWw6IHJlcS5zaWduYWwsIGJvZHk6IGF3YWl0IGNyZWF0ZVJlcXVlc3RCb2R5KHJlcS5tZXNzYWdlKSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUmVzcG9uc2UobWV0aG9kLmtpbmQsIGZSZXMuc3RhdHVzLCBmUmVzLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZlJlcy5ib2R5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIm1pc3NpbmcgcmVzcG9uc2UgYm9keVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYWlsZXIgPSBuZXcgSGVhZGVycygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcSksIHsgaGVhZGVyOiBmUmVzLmhlYWRlcnMsIHRyYWlsZXIsIG1lc3NhZ2U6IHBhcnNlUmVzcG9uc2VCb2R5KGZSZXMuYm9keSwgdHJhaWxlcikgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG4iLG51bGwsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG5cbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmV4cG9ydCB7IF9hcnJheUxpa2VUb0FycmF5IGFzIGFycmF5TGlrZVRvQXJyYXksIF9hcnJheVdpdGhIb2xlcyBhcyBhcnJheVdpdGhIb2xlcywgX2RlZmluZVByb3BlcnR5IGFzIGRlZmluZVByb3BlcnR5LCBfaXRlcmFibGVUb0FycmF5TGltaXQgYXMgaXRlcmFibGVUb0FycmF5TGltaXQsIF9ub25JdGVyYWJsZVJlc3QgYXMgbm9uSXRlcmFibGVSZXN0LCBfb2JqZWN0U3ByZWFkMiBhcyBvYmplY3RTcHJlYWQyLCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgYXMgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMsIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGFzIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UsIF9zbGljZWRUb0FycmF5IGFzIHNsaWNlZFRvQXJyYXksIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSBhcyB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSB9O1xuIiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZm5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGZucy5yZWR1Y2VSaWdodChmdW5jdGlvbiAoeSwgZikge1xuICAgICAgcmV0dXJuIGYoeSk7XG4gICAgfSwgeCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGN1cnJ5KGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjdXJyaWVkKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJncy5sZW5ndGggPj0gZm4ubGVuZ3RoID8gZm4uYXBwbHkodGhpcywgYXJncykgOiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIG5leHRBcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIG5leHRBcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyaWVkLmFwcGx5KF90aGlzLCBbXS5jb25jYXQoYXJncywgbmV4dEFyZ3MpKTtcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4ge30udG9TdHJpbmcuY2FsbCh2YWx1ZSkuaW5jbHVkZXMoJ09iamVjdCcpO1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICByZXR1cm4gIU9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGFuZ2VzKGluaXRpYWwsIGNoYW5nZXMpIHtcbiAgaWYgKCFpc09iamVjdChjaGFuZ2VzKSkgZXJyb3JIYW5kbGVyKCdjaGFuZ2VUeXBlJyk7XG4gIGlmIChPYmplY3Qua2V5cyhjaGFuZ2VzKS5zb21lKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIHJldHVybiAhaGFzT3duUHJvcGVydHkoaW5pdGlhbCwgZmllbGQpO1xuICB9KSkgZXJyb3JIYW5kbGVyKCdjaGFuZ2VGaWVsZCcpO1xuICByZXR1cm4gY2hhbmdlcztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTZWxlY3RvcihzZWxlY3Rvcikge1xuICBpZiAoIWlzRnVuY3Rpb24oc2VsZWN0b3IpKSBlcnJvckhhbmRsZXIoJ3NlbGVjdG9yVHlwZScpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUhhbmRsZXIoaGFuZGxlcikge1xuICBpZiAoIShpc0Z1bmN0aW9uKGhhbmRsZXIpIHx8IGlzT2JqZWN0KGhhbmRsZXIpKSkgZXJyb3JIYW5kbGVyKCdoYW5kbGVyVHlwZScpO1xuICBpZiAoaXNPYmplY3QoaGFuZGxlcikgJiYgT2JqZWN0LnZhbHVlcyhoYW5kbGVyKS5zb21lKGZ1bmN0aW9uIChfaGFuZGxlcikge1xuICAgIHJldHVybiAhaXNGdW5jdGlvbihfaGFuZGxlcik7XG4gIH0pKSBlcnJvckhhbmRsZXIoJ2hhbmRsZXJzVHlwZScpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUluaXRpYWwoaW5pdGlhbCkge1xuICBpZiAoIWluaXRpYWwpIGVycm9ySGFuZGxlcignaW5pdGlhbElzUmVxdWlyZWQnKTtcbiAgaWYgKCFpc09iamVjdChpbml0aWFsKSkgZXJyb3JIYW5kbGVyKCdpbml0aWFsVHlwZScpO1xuICBpZiAoaXNFbXB0eShpbml0aWFsKSkgZXJyb3JIYW5kbGVyKCdpbml0aWFsQ29udGVudCcpO1xufVxuXG5mdW5jdGlvbiB0aHJvd0Vycm9yKGVycm9yTWVzc2FnZXMsIHR5cGUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZXNbdHlwZV0gfHwgZXJyb3JNZXNzYWdlc1tcImRlZmF1bHRcIl0pO1xufVxuXG52YXIgZXJyb3JNZXNzYWdlcyA9IHtcbiAgaW5pdGlhbElzUmVxdWlyZWQ6ICdpbml0aWFsIHN0YXRlIGlzIHJlcXVpcmVkJyxcbiAgaW5pdGlhbFR5cGU6ICdpbml0aWFsIHN0YXRlIHNob3VsZCBiZSBhbiBvYmplY3QnLFxuICBpbml0aWFsQ29udGVudDogJ2luaXRpYWwgc3RhdGUgc2hvdWxkblxcJ3QgYmUgYW4gZW1wdHkgb2JqZWN0JyxcbiAgaGFuZGxlclR5cGU6ICdoYW5kbGVyIHNob3VsZCBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbicsXG4gIGhhbmRsZXJzVHlwZTogJ2FsbCBoYW5kbGVycyBzaG91bGQgYmUgYSBmdW5jdGlvbnMnLFxuICBzZWxlY3RvclR5cGU6ICdzZWxlY3RvciBzaG91bGQgYmUgYSBmdW5jdGlvbicsXG4gIGNoYW5nZVR5cGU6ICdwcm92aWRlZCB2YWx1ZSBvZiBjaGFuZ2VzIHNob3VsZCBiZSBhbiBvYmplY3QnLFxuICBjaGFuZ2VGaWVsZDogJ2l0IHNlYW1zIHlvdSB3YW50IHRvIGNoYW5nZSBhIGZpZWxkIGluIHRoZSBzdGF0ZSB3aGljaCBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBcImluaXRpYWxcIiBzdGF0ZScsXG4gIFwiZGVmYXVsdFwiOiAnYW4gdW5rbm93biBlcnJvciBhY2N1cmVkIGluIGBzdGF0ZS1sb2NhbGAgcGFja2FnZSdcbn07XG52YXIgZXJyb3JIYW5kbGVyID0gY3VycnkodGhyb3dFcnJvcikoZXJyb3JNZXNzYWdlcyk7XG52YXIgdmFsaWRhdG9ycyA9IHtcbiAgY2hhbmdlczogdmFsaWRhdGVDaGFuZ2VzLFxuICBzZWxlY3RvcjogdmFsaWRhdGVTZWxlY3RvcixcbiAgaGFuZGxlcjogdmFsaWRhdGVIYW5kbGVyLFxuICBpbml0aWFsOiB2YWxpZGF0ZUluaXRpYWxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZShpbml0aWFsKSB7XG4gIHZhciBoYW5kbGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFsaWRhdG9ycy5pbml0aWFsKGluaXRpYWwpO1xuICB2YWxpZGF0b3JzLmhhbmRsZXIoaGFuZGxlcik7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICBjdXJyZW50OiBpbml0aWFsXG4gIH07XG4gIHZhciBkaWRVcGRhdGUgPSBjdXJyeShkaWRTdGF0ZVVwZGF0ZSkoc3RhdGUsIGhhbmRsZXIpO1xuICB2YXIgdXBkYXRlID0gY3VycnkodXBkYXRlU3RhdGUpKHN0YXRlKTtcbiAgdmFyIHZhbGlkYXRlID0gY3VycnkodmFsaWRhdG9ycy5jaGFuZ2VzKShpbml0aWFsKTtcbiAgdmFyIGdldENoYW5nZXMgPSBjdXJyeShleHRyYWN0Q2hhbmdlcykoc3RhdGUpO1xuXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIHZhciBzZWxlY3RvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbiAgICB2YWxpZGF0b3JzLnNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gc2VsZWN0b3Ioc3RhdGUuY3VycmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTdGF0ZShjYXVzZWRDaGFuZ2VzKSB7XG4gICAgY29tcG9zZShkaWRVcGRhdGUsIHVwZGF0ZSwgdmFsaWRhdGUsIGdldENoYW5nZXMpKGNhdXNlZENoYW5nZXMpO1xuICB9XG5cbiAgcmV0dXJuIFtnZXRTdGF0ZSwgc2V0U3RhdGVdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0Q2hhbmdlcyhzdGF0ZSwgY2F1c2VkQ2hhbmdlcykge1xuICByZXR1cm4gaXNGdW5jdGlvbihjYXVzZWRDaGFuZ2VzKSA/IGNhdXNlZENoYW5nZXMoc3RhdGUuY3VycmVudCkgOiBjYXVzZWRDaGFuZ2VzO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZShzdGF0ZSwgY2hhbmdlcykge1xuICBzdGF0ZS5jdXJyZW50ID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHN0YXRlLmN1cnJlbnQpLCBjaGFuZ2VzKTtcbiAgcmV0dXJuIGNoYW5nZXM7XG59XG5cbmZ1bmN0aW9uIGRpZFN0YXRlVXBkYXRlKHN0YXRlLCBoYW5kbGVyLCBjaGFuZ2VzKSB7XG4gIGlzRnVuY3Rpb24oaGFuZGxlcikgPyBoYW5kbGVyKHN0YXRlLmN1cnJlbnQpIDogT2JqZWN0LmtleXMoY2hhbmdlcykuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICB2YXIgX2hhbmRsZXIkZmllbGQ7XG5cbiAgICByZXR1cm4gKF9oYW5kbGVyJGZpZWxkID0gaGFuZGxlcltmaWVsZF0pID09PSBudWxsIHx8IF9oYW5kbGVyJGZpZWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaGFuZGxlciRmaWVsZC5jYWxsKGhhbmRsZXIsIHN0YXRlLmN1cnJlbnRbZmllbGRdKTtcbiAgfSk7XG4gIHJldHVybiBjaGFuZ2VzO1xufVxuXG52YXIgaW5kZXggPSB7XG4gIGNyZWF0ZTogY3JlYXRlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiIsInZhciBjb25maWcgPSB7XG4gIHBhdGhzOiB7XG4gICAgdnM6ICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL21vbmFjby1lZGl0b3JAMC40My4wL21pbi92cydcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY29uZmlnO1xuIiwiZnVuY3Rpb24gY3VycnkoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGN1cnJpZWQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJncy5sZW5ndGggPj0gZm4ubGVuZ3RoID8gZm4uYXBwbHkodGhpcywgYXJncykgOiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5leHRBcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIG5leHRBcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyaWVkLmFwcGx5KF90aGlzLCBbXS5jb25jYXQoYXJncywgbmV4dEFyZ3MpKTtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjdXJyeTtcbiIsImZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHZhbHVlKS5pbmNsdWRlcygnT2JqZWN0Jyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0O1xuIiwiaW1wb3J0IGN1cnJ5IGZyb20gJy4uL3V0aWxzL2N1cnJ5LmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuLi91dGlscy9pc09iamVjdC5qcyc7XG5cbi8qKlxuICogdmFsaWRhdGVzIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBhbmQgaW5mb3JtcyBhYm91dCBkZXByZWNhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBcbiAqIEByZXR1cm4ge09iamVjdH0gY29uZmlnIC0gdGhlIHZhbGlkYXRlZCBjb25maWd1cmF0aW9uIG9iamVjdFxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29uZmlnKGNvbmZpZykge1xuICBpZiAoIWNvbmZpZykgZXJyb3JIYW5kbGVyKCdjb25maWdJc1JlcXVpcmVkJyk7XG4gIGlmICghaXNPYmplY3QoY29uZmlnKSkgZXJyb3JIYW5kbGVyKCdjb25maWdUeXBlJyk7XG5cbiAgaWYgKGNvbmZpZy51cmxzKSB7XG4gICAgaW5mb3JtQWJvdXREZXByZWNhdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoczoge1xuICAgICAgICB2czogY29uZmlnLnVybHMubW9uYWNvQmFzZVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gY29uZmlnO1xufVxuLyoqXG4gKiBsb2dzIGRlcHJlY2F0aW9uIG1lc3NhZ2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGluZm9ybUFib3V0RGVwcmVjYXRpb24oKSB7XG4gIGNvbnNvbGUud2FybihlcnJvck1lc3NhZ2VzLmRlcHJlY2F0aW9uKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihlcnJvck1lc3NhZ2VzLCB0eXBlKSB7XG4gIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2VzW3R5cGVdIHx8IGVycm9yTWVzc2FnZXNbXCJkZWZhdWx0XCJdKTtcbn1cblxudmFyIGVycm9yTWVzc2FnZXMgPSB7XG4gIGNvbmZpZ0lzUmVxdWlyZWQ6ICd0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgaXMgcmVxdWlyZWQnLFxuICBjb25maWdUeXBlOiAndGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHNob3VsZCBiZSBhbiBvYmplY3QnLFxuICBcImRlZmF1bHRcIjogJ2FuIHVua25vd24gZXJyb3IgYWNjdXJlZCBpbiBgQG1vbmFjby1lZGl0b3IvbG9hZGVyYCBwYWNrYWdlJyxcbiAgZGVwcmVjYXRpb246IFwiRGVwcmVjYXRpb24gd2FybmluZyFcXG4gICAgWW91IGFyZSB1c2luZyBkZXByZWNhdGVkIHdheSBvZiBjb25maWd1cmF0aW9uLlxcblxcbiAgICBJbnN0ZWFkIG9mIHVzaW5nXFxuICAgICAgbW9uYWNvLmNvbmZpZyh7IHVybHM6IHsgbW9uYWNvQmFzZTogJy4uLicgfSB9KVxcbiAgICB1c2VcXG4gICAgICBtb25hY28uY29uZmlnKHsgcGF0aHM6IHsgdnM6ICcuLi4nIH0gfSlcXG5cXG4gICAgRm9yIG1vcmUgcGxlYXNlIGNoZWNrIHRoZSBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXJlbi1hdG95YW4vbW9uYWNvLWxvYWRlciNjb25maWdcXG4gIFwiXG59O1xudmFyIGVycm9ySGFuZGxlciA9IGN1cnJ5KHRocm93RXJyb3IpKGVycm9yTWVzc2FnZXMpO1xudmFyIHZhbGlkYXRvcnMgPSB7XG4gIGNvbmZpZzogdmFsaWRhdGVDb25maWdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRvcnM7XG5leHBvcnQgeyBlcnJvckhhbmRsZXIsIGVycm9yTWVzc2FnZXMgfTtcbiIsInZhciBjb21wb3NlID0gZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gZm5zLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uICh5LCBmKSB7XG4gICAgICByZXR1cm4gZih5KTtcbiAgICB9LCB4KTtcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvc2U7XG4iLCJpbXBvcnQgeyBvYmplY3RTcHJlYWQyIGFzIF9vYmplY3RTcHJlYWQyIH0gZnJvbSAnLi4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyc7XG5cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlKSB7XG4gIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKHNvdXJjZVtrZXldIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICBpZiAodGFyZ2V0W2tleV0pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzb3VyY2Vba2V5XSwgbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB0YXJnZXQpLCBzb3VyY2UpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZXJnZTtcbiIsIi8vIFRoZSBzb3VyY2UgKGhhcyBiZWVuIGNoYW5nZWQpIGlzIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNTQ2NSNpc3N1ZWNvbW1lbnQtMTU3ODg4MzI1XG52YXIgQ0FOQ0VMQVRJT05fTUVTU0FHRSA9IHtcbiAgdHlwZTogJ2NhbmNlbGF0aW9uJyxcbiAgbXNnOiAnb3BlcmF0aW9uIGlzIG1hbnVhbGx5IGNhbmNlbGVkJ1xufTtcblxuZnVuY3Rpb24gbWFrZUNhbmNlbGFibGUocHJvbWlzZSkge1xuICB2YXIgaGFzQ2FuY2VsZWRfID0gZmFsc2U7XG4gIHZhciB3cmFwcGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIGhhc0NhbmNlbGVkXyA/IHJlamVjdChDQU5DRUxBVElPTl9NRVNTQUdFKSA6IHJlc29sdmUodmFsKTtcbiAgICB9KTtcbiAgICBwcm9taXNlW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgfSk7XG4gIHJldHVybiB3cmFwcGVkUHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGhhc0NhbmNlbGVkXyA9IHRydWU7XG4gIH0sIHdyYXBwZWRQcm9taXNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYWtlQ2FuY2VsYWJsZTtcbmV4cG9ydCB7IENBTkNFTEFUSU9OX01FU1NBR0UgfTtcbiIsImltcG9ydCB7IHNsaWNlZFRvQXJyYXkgYXMgX3NsaWNlZFRvQXJyYXksIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGFzIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyB9IGZyb20gJy4uL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanMnO1xuaW1wb3J0IHN0YXRlIGZyb20gJ3N0YXRlLWxvY2FsJztcbmltcG9ydCBjb25maWckMSBmcm9tICcuLi9jb25maWcvaW5kZXguanMnO1xuaW1wb3J0IHZhbGlkYXRvcnMgZnJvbSAnLi4vdmFsaWRhdG9ycy9pbmRleC5qcyc7XG5pbXBvcnQgY29tcG9zZSBmcm9tICcuLi91dGlscy9jb21wb3NlLmpzJztcbmltcG9ydCBtZXJnZSBmcm9tICcuLi91dGlscy9kZWVwTWVyZ2UuanMnO1xuaW1wb3J0IG1ha2VDYW5jZWxhYmxlIGZyb20gJy4uL3V0aWxzL21ha2VDYW5jZWxhYmxlLmpzJztcblxuLyoqIHRoZSBsb2NhbCBzdGF0ZSBvZiB0aGUgbW9kdWxlICovXG5cbnZhciBfc3RhdGUkY3JlYXRlID0gc3RhdGUuY3JlYXRlKHtcbiAgY29uZmlnOiBjb25maWckMSxcbiAgaXNJbml0aWFsaXplZDogZmFsc2UsXG4gIHJlc29sdmU6IG51bGwsXG4gIHJlamVjdDogbnVsbCxcbiAgbW9uYWNvOiBudWxsXG59KSxcbiAgICBfc3RhdGUkY3JlYXRlMiA9IF9zbGljZWRUb0FycmF5KF9zdGF0ZSRjcmVhdGUsIDIpLFxuICAgIGdldFN0YXRlID0gX3N0YXRlJGNyZWF0ZTJbMF0sXG4gICAgc2V0U3RhdGUgPSBfc3RhdGUkY3JlYXRlMlsxXTtcbi8qKlxuICogc2V0IHRoZSBsb2FkZXIgY29uZmlndXJhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICovXG5cblxuZnVuY3Rpb24gY29uZmlnKGdsb2JhbENvbmZpZykge1xuICB2YXIgX3ZhbGlkYXRvcnMkY29uZmlnID0gdmFsaWRhdG9ycy5jb25maWcoZ2xvYmFsQ29uZmlnKSxcbiAgICAgIG1vbmFjbyA9IF92YWxpZGF0b3JzJGNvbmZpZy5tb25hY28sXG4gICAgICBjb25maWcgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3ZhbGlkYXRvcnMkY29uZmlnLCBbXCJtb25hY29cIl0pO1xuXG4gIHNldFN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWc6IG1lcmdlKHN0YXRlLmNvbmZpZywgY29uZmlnKSxcbiAgICAgIG1vbmFjbzogbW9uYWNvXG4gICAgfTtcbiAgfSk7XG59XG4vKipcbiAqIGhhbmRsZXMgdGhlIGluaXRpYWxpemF0aW9uIG9mIHRoZSBtb25hY28tZWRpdG9yXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAtIHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgbW9uYWNvICh3aXRoIGEgY2FuY2VsYWJsZSBwcm9taXNlKVxuICovXG5cblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbW9uYWNvID0gX3JlZi5tb25hY28sXG4gICAgICAgIGlzSW5pdGlhbGl6ZWQgPSBfcmVmLmlzSW5pdGlhbGl6ZWQsXG4gICAgICAgIHJlc29sdmUgPSBfcmVmLnJlc29sdmU7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vbmFjbzogbW9uYWNvLFxuICAgICAgaXNJbml0aWFsaXplZDogaXNJbml0aWFsaXplZCxcbiAgICAgIHJlc29sdmU6IHJlc29sdmVcbiAgICB9O1xuICB9KTtcblxuICBpZiAoIXN0YXRlLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICBzZXRTdGF0ZSh7XG4gICAgICBpc0luaXRpYWxpemVkOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoc3RhdGUubW9uYWNvKSB7XG4gICAgICBzdGF0ZS5yZXNvbHZlKHN0YXRlLm1vbmFjbyk7XG4gICAgICByZXR1cm4gbWFrZUNhbmNlbGFibGUod3JhcHBlclByb21pc2UpO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cubW9uYWNvICYmIHdpbmRvdy5tb25hY28uZWRpdG9yKSB7XG4gICAgICBzdG9yZU1vbmFjb0luc3RhbmNlKHdpbmRvdy5tb25hY28pO1xuICAgICAgc3RhdGUucmVzb2x2ZSh3aW5kb3cubW9uYWNvKTtcbiAgICAgIHJldHVybiBtYWtlQ2FuY2VsYWJsZSh3cmFwcGVyUHJvbWlzZSk7XG4gICAgfVxuXG4gICAgY29tcG9zZShpbmplY3RTY3JpcHRzLCBnZXRNb25hY29Mb2FkZXJTY3JpcHQpKGNvbmZpZ3VyZUxvYWRlcik7XG4gIH1cblxuICByZXR1cm4gbWFrZUNhbmNlbGFibGUod3JhcHBlclByb21pc2UpO1xufVxuLyoqXG4gKiBpbmplY3RzIHByb3ZpZGVkIHNjcmlwdHMgaW50byB0aGUgZG9jdW1lbnQuYm9keVxuICogQHBhcmFtIHtPYmplY3R9IHNjcmlwdCAtIGFuIEhUTUwgc2NyaXB0IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gLSB0aGUgaW5qZWN0ZWQgSFRNTCBzY3JpcHQgZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gaW5qZWN0U2NyaXB0cyhzY3JpcHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbn1cbi8qKlxuICogY3JlYXRlcyBhbiBIVE1MIHNjcmlwdCBlbGVtZW50IHdpdGgvd2l0aG91dCBwcm92aWRlZCBzcmNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3JjXSAtIHRoZSBzb3VyY2UgcGF0aCBvZiB0aGUgc2NyaXB0XG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gdGhlIGNyZWF0ZWQgSFRNTCBzY3JpcHQgZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlU2NyaXB0KHNyYykge1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHJldHVybiBzcmMgJiYgKHNjcmlwdC5zcmMgPSBzcmMpLCBzY3JpcHQ7XG59XG4vKipcbiAqIGNyZWF0ZXMgYW4gSFRNTCBzY3JpcHQgZWxlbWVudCB3aXRoIHRoZSBtb25hY28gbG9hZGVyIHNyY1xuICogQHJldHVybiB7T2JqZWN0fSAtIHRoZSBjcmVhdGVkIEhUTUwgc2NyaXB0IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE1vbmFjb0xvYWRlclNjcmlwdChjb25maWd1cmVMb2FkZXIpIHtcbiAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIGNvbmZpZyA9IF9yZWYyLmNvbmZpZyxcbiAgICAgICAgcmVqZWN0ID0gX3JlZjIucmVqZWN0O1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgIHJlamVjdDogcmVqZWN0XG4gICAgfTtcbiAgfSk7XG4gIHZhciBsb2FkZXJTY3JpcHQgPSBjcmVhdGVTY3JpcHQoXCJcIi5jb25jYXQoc3RhdGUuY29uZmlnLnBhdGhzLnZzLCBcIi9sb2FkZXIuanNcIikpO1xuXG4gIGxvYWRlclNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbmZpZ3VyZUxvYWRlcigpO1xuICB9O1xuXG4gIGxvYWRlclNjcmlwdC5vbmVycm9yID0gc3RhdGUucmVqZWN0O1xuICByZXR1cm4gbG9hZGVyU2NyaXB0O1xufVxuLyoqXG4gKiBjb25maWd1cmVzIHRoZSBtb25hY28gbG9hZGVyXG4gKi9cblxuXG5mdW5jdGlvbiBjb25maWd1cmVMb2FkZXIoKSB7XG4gIHZhciBzdGF0ZSA9IGdldFN0YXRlKGZ1bmN0aW9uIChfcmVmMykge1xuICAgIHZhciBjb25maWcgPSBfcmVmMy5jb25maWcsXG4gICAgICAgIHJlc29sdmUgPSBfcmVmMy5yZXNvbHZlLFxuICAgICAgICByZWplY3QgPSBfcmVmMy5yZWplY3Q7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgIHJlamVjdDogcmVqZWN0XG4gICAgfTtcbiAgfSk7XG4gIHZhciByZXF1aXJlID0gd2luZG93LnJlcXVpcmU7XG5cbiAgcmVxdWlyZS5jb25maWcoc3RhdGUuY29uZmlnKTtcblxuICByZXF1aXJlKFsndnMvZWRpdG9yL2VkaXRvci5tYWluJ10sIGZ1bmN0aW9uIChtb25hY28pIHtcbiAgICBzdG9yZU1vbmFjb0luc3RhbmNlKG1vbmFjbyk7XG4gICAgc3RhdGUucmVzb2x2ZShtb25hY28pO1xuICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBzdGF0ZS5yZWplY3QoZXJyb3IpO1xuICB9KTtcbn1cbi8qKlxuICogc3RvcmUgbW9uYWNvIGluc3RhbmNlIGluIGxvY2FsIHN0YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzdG9yZU1vbmFjb0luc3RhbmNlKG1vbmFjbykge1xuICBpZiAoIWdldFN0YXRlKCkubW9uYWNvKSB7XG4gICAgc2V0U3RhdGUoe1xuICAgICAgbW9uYWNvOiBtb25hY29cbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBpbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25cbiAqIGV4dHJhY3RzIHN0b3JlZCBtb25hY28gaW5zdGFuY2VcbiAqIEByZXR1cm4ge09iamVjdHxudWxsfSAtIHRoZSBtb25hY28gaW5zdGFuY2VcbiAqL1xuXG5cbmZ1bmN0aW9uIF9fZ2V0TW9uYWNvSW5zdGFuY2UoKSB7XG4gIHJldHVybiBnZXRTdGF0ZShmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICB2YXIgbW9uYWNvID0gX3JlZjQubW9uYWNvO1xuICAgIHJldHVybiBtb25hY287XG4gIH0pO1xufVxuXG52YXIgd3JhcHBlclByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHJldHVybiBzZXRTdGF0ZSh7XG4gICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICByZWplY3Q6IHJlamVjdFxuICB9KTtcbn0pO1xudmFyIGxvYWRlciA9IHtcbiAgY29uZmlnOiBjb25maWcsXG4gIGluaXQ6IGluaXQsXG4gIF9fZ2V0TW9uYWNvSW5zdGFuY2U6IF9fZ2V0TW9uYWNvSW5zdGFuY2Vcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGxvYWRlcjtcbiIsImltcG9ydCBfdCBmcm9tXCJAbW9uYWNvLWVkaXRvci9sb2FkZXJcIjtpbXBvcnR7bWVtbyBhcyBUZX1mcm9tXCJyZWFjdFwiO2ltcG9ydCBrZSx7dXNlU3RhdGUgYXMgcmUsdXNlUmVmIGFzIFMsdXNlQ2FsbGJhY2sgYXMgb2UsdXNlRWZmZWN0IGFzIG5lfWZyb21cInJlYWN0XCI7aW1wb3J0IFNlIGZyb21cIkBtb25hY28tZWRpdG9yL2xvYWRlclwiO2ltcG9ydHttZW1vIGFzIHllfWZyb21cInJlYWN0XCI7aW1wb3J0IEsgZnJvbVwicmVhY3RcIjt2YXIgbGU9e3dyYXBwZXI6e2Rpc3BsYXk6XCJmbGV4XCIscG9zaXRpb246XCJyZWxhdGl2ZVwiLHRleHRBbGlnbjpcImluaXRpYWxcIn0sZnVsbFdpZHRoOnt3aWR0aDpcIjEwMCVcIn0saGlkZTp7ZGlzcGxheTpcIm5vbmVcIn19LHY9bGU7aW1wb3J0IG1lIGZyb21cInJlYWN0XCI7dmFyIGFlPXtjb250YWluZXI6e2Rpc3BsYXk6XCJmbGV4XCIsaGVpZ2h0OlwiMTAwJVwiLHdpZHRoOlwiMTAwJVwiLGp1c3RpZnlDb250ZW50OlwiY2VudGVyXCIsYWxpZ25JdGVtczpcImNlbnRlclwifX0sWT1hZTtmdW5jdGlvbiBNZSh7Y2hpbGRyZW46ZX0pe3JldHVybiBtZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3N0eWxlOlkuY29udGFpbmVyfSxlKX12YXIgWj1NZTt2YXIgJD1aO2Z1bmN0aW9uIEVlKHt3aWR0aDplLGhlaWdodDpyLGlzRWRpdG9yUmVhZHk6bixsb2FkaW5nOnQsX3JlZjphLGNsYXNzTmFtZTptLHdyYXBwZXJQcm9wczpFfSl7cmV0dXJuIEsuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIix7c3R5bGU6ey4uLnYud3JhcHBlcix3aWR0aDplLGhlaWdodDpyfSwuLi5FfSwhbiYmSy5jcmVhdGVFbGVtZW50KCQsbnVsbCx0KSxLLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7cmVmOmEsc3R5bGU6ey4uLnYuZnVsbFdpZHRoLC4uLiFuJiZ2LmhpZGV9LGNsYXNzTmFtZTptfSkpfXZhciBlZT1FZTt2YXIgSD15ZShlZSk7aW1wb3J0e3VzZUVmZmVjdCBhcyB4ZX1mcm9tXCJyZWFjdFwiO2Z1bmN0aW9uIENlKGUpe3hlKGUsW10pfXZhciBrPUNlO2ltcG9ydHt1c2VFZmZlY3QgYXMgZ2UsdXNlUmVmIGFzIFJlfWZyb21cInJlYWN0XCI7ZnVuY3Rpb24gaGUoZSxyLG49ITApe2xldCB0PVJlKCEwKTtnZSh0LmN1cnJlbnR8fCFuPygpPT57dC5jdXJyZW50PSExfTplLHIpfXZhciBsPWhlO2Z1bmN0aW9uIEQoKXt9ZnVuY3Rpb24gaChlLHIsbix0KXtyZXR1cm4gRGUoZSx0KXx8YmUoZSxyLG4sdCl9ZnVuY3Rpb24gRGUoZSxyKXtyZXR1cm4gZS5lZGl0b3IuZ2V0TW9kZWwodGUoZSxyKSl9ZnVuY3Rpb24gYmUoZSxyLG4sdCl7cmV0dXJuIGUuZWRpdG9yLmNyZWF0ZU1vZGVsKHIsbix0P3RlKGUsdCk6dm9pZCAwKX1mdW5jdGlvbiB0ZShlLHIpe3JldHVybiBlLlVyaS5wYXJzZShyKX1mdW5jdGlvbiBPZSh7b3JpZ2luYWw6ZSxtb2RpZmllZDpyLGxhbmd1YWdlOm4sb3JpZ2luYWxMYW5ndWFnZTp0LG1vZGlmaWVkTGFuZ3VhZ2U6YSxvcmlnaW5hbE1vZGVsUGF0aDptLG1vZGlmaWVkTW9kZWxQYXRoOkUsa2VlcEN1cnJlbnRPcmlnaW5hbE1vZGVsOmc9ITEsa2VlcEN1cnJlbnRNb2RpZmllZE1vZGVsOk49ITEsdGhlbWU6eD1cImxpZ2h0XCIsbG9hZGluZzpQPVwiTG9hZGluZy4uLlwiLG9wdGlvbnM6eT17fSxoZWlnaHQ6Vj1cIjEwMCVcIix3aWR0aDp6PVwiMTAwJVwiLGNsYXNzTmFtZTpGLHdyYXBwZXJQcm9wczpqPXt9LGJlZm9yZU1vdW50OkE9RCxvbk1vdW50OnE9RH0pe2xldFtNLE9dPXJlKCExKSxbVCxzXT1yZSghMCksdT1TKG51bGwpLGM9UyhudWxsKSx3PVMobnVsbCksZD1TKHEpLG89UyhBKSxiPVMoITEpO2soKCk9PntsZXQgaT1TZS5pbml0KCk7cmV0dXJuIGkudGhlbihmPT4oYy5jdXJyZW50PWYpJiZzKCExKSkuY2F0Y2goZj0+Zj8udHlwZSE9PVwiY2FuY2VsYXRpb25cIiYmY29uc29sZS5lcnJvcihcIk1vbmFjbyBpbml0aWFsaXphdGlvbjogZXJyb3I6XCIsZikpLCgpPT51LmN1cnJlbnQ/SSgpOmkuY2FuY2VsKCl9KSxsKCgpPT57aWYodS5jdXJyZW50JiZjLmN1cnJlbnQpe2xldCBpPXUuY3VycmVudC5nZXRPcmlnaW5hbEVkaXRvcigpLGY9aChjLmN1cnJlbnQsZXx8XCJcIix0fHxufHxcInRleHRcIixtfHxcIlwiKTtmIT09aS5nZXRNb2RlbCgpJiZpLnNldE1vZGVsKGYpfX0sW21dLE0pLGwoKCk9PntpZih1LmN1cnJlbnQmJmMuY3VycmVudCl7bGV0IGk9dS5jdXJyZW50LmdldE1vZGlmaWVkRWRpdG9yKCksZj1oKGMuY3VycmVudCxyfHxcIlwiLGF8fG58fFwidGV4dFwiLEV8fFwiXCIpO2YhPT1pLmdldE1vZGVsKCkmJmkuc2V0TW9kZWwoZil9fSxbRV0sTSksbCgoKT0+e2xldCBpPXUuY3VycmVudC5nZXRNb2RpZmllZEVkaXRvcigpO2kuZ2V0T3B0aW9uKGMuY3VycmVudC5lZGl0b3IuRWRpdG9yT3B0aW9uLnJlYWRPbmx5KT9pLnNldFZhbHVlKHJ8fFwiXCIpOnIhPT1pLmdldFZhbHVlKCkmJihpLmV4ZWN1dGVFZGl0cyhcIlwiLFt7cmFuZ2U6aS5nZXRNb2RlbCgpLmdldEZ1bGxNb2RlbFJhbmdlKCksdGV4dDpyfHxcIlwiLGZvcmNlTW92ZU1hcmtlcnM6ITB9XSksaS5wdXNoVW5kb1N0b3AoKSl9LFtyXSxNKSxsKCgpPT57dS5jdXJyZW50Py5nZXRNb2RlbCgpPy5vcmlnaW5hbC5zZXRWYWx1ZShlfHxcIlwiKX0sW2VdLE0pLGwoKCk9PntsZXR7b3JpZ2luYWw6aSxtb2RpZmllZDpmfT11LmN1cnJlbnQuZ2V0TW9kZWwoKTtjLmN1cnJlbnQuZWRpdG9yLnNldE1vZGVsTGFuZ3VhZ2UoaSx0fHxufHxcInRleHRcIiksYy5jdXJyZW50LmVkaXRvci5zZXRNb2RlbExhbmd1YWdlKGYsYXx8bnx8XCJ0ZXh0XCIpfSxbbix0LGFdLE0pLGwoKCk9PntjLmN1cnJlbnQ/LmVkaXRvci5zZXRUaGVtZSh4KX0sW3hdLE0pLGwoKCk9Pnt1LmN1cnJlbnQ/LnVwZGF0ZU9wdGlvbnMoeSl9LFt5XSxNKTtsZXQgTD1vZSgoKT0+e2lmKCFjLmN1cnJlbnQpcmV0dXJuO28uY3VycmVudChjLmN1cnJlbnQpO2xldCBpPWgoYy5jdXJyZW50LGV8fFwiXCIsdHx8bnx8XCJ0ZXh0XCIsbXx8XCJcIiksZj1oKGMuY3VycmVudCxyfHxcIlwiLGF8fG58fFwidGV4dFwiLEV8fFwiXCIpO3UuY3VycmVudD8uc2V0TW9kZWwoe29yaWdpbmFsOmksbW9kaWZpZWQ6Zn0pfSxbbixyLGEsZSx0LG0sRV0pLFU9b2UoKCk9PnshYi5jdXJyZW50JiZ3LmN1cnJlbnQmJih1LmN1cnJlbnQ9Yy5jdXJyZW50LmVkaXRvci5jcmVhdGVEaWZmRWRpdG9yKHcuY3VycmVudCx7YXV0b21hdGljTGF5b3V0OiEwLC4uLnl9KSxMKCksYy5jdXJyZW50Py5lZGl0b3Iuc2V0VGhlbWUoeCksTyghMCksYi5jdXJyZW50PSEwKX0sW3kseCxMXSk7bmUoKCk9PntNJiZkLmN1cnJlbnQodS5jdXJyZW50LGMuY3VycmVudCl9LFtNXSksbmUoKCk9PnshVCYmIU0mJlUoKX0sW1QsTSxVXSk7ZnVuY3Rpb24gSSgpe2xldCBpPXUuY3VycmVudD8uZ2V0TW9kZWwoKTtnfHxpPy5vcmlnaW5hbD8uZGlzcG9zZSgpLE58fGk/Lm1vZGlmaWVkPy5kaXNwb3NlKCksdS5jdXJyZW50Py5kaXNwb3NlKCl9cmV0dXJuIGtlLmNyZWF0ZUVsZW1lbnQoSCx7d2lkdGg6eixoZWlnaHQ6Vixpc0VkaXRvclJlYWR5Ok0sbG9hZGluZzpQLF9yZWY6dyxjbGFzc05hbWU6Rix3cmFwcGVyUHJvcHM6an0pfXZhciBpZT1PZTt2YXIgd2U9VGUoaWUpO2ltcG9ydHt1c2VTdGF0ZSBhcyBJZX1mcm9tXCJyZWFjdFwiO2ltcG9ydCBjZSBmcm9tXCJAbW9uYWNvLWVkaXRvci9sb2FkZXJcIjtmdW5jdGlvbiBQZSgpe2xldFtlLHJdPUllKGNlLl9fZ2V0TW9uYWNvSW5zdGFuY2UoKSk7cmV0dXJuIGsoKCk9PntsZXQgbjtyZXR1cm4gZXx8KG49Y2UuaW5pdCgpLG4udGhlbih0PT57cih0KX0pKSwoKT0+bj8uY2FuY2VsKCl9KSxlfXZhciBMZT1QZTtpbXBvcnR7bWVtbyBhcyB6ZX1mcm9tXCJyZWFjdFwiO2ltcG9ydCBXZSx7dXNlU3RhdGUgYXMgdWUsdXNlRWZmZWN0IGFzIFcsdXNlUmVmIGFzIEMsdXNlQ2FsbGJhY2sgYXMgX2V9ZnJvbVwicmVhY3RcIjtpbXBvcnQgTmUgZnJvbVwiQG1vbmFjby1lZGl0b3IvbG9hZGVyXCI7aW1wb3J0e3VzZUVmZmVjdCBhcyBVZSx1c2VSZWYgYXMgdmV9ZnJvbVwicmVhY3RcIjtmdW5jdGlvbiBIZShlKXtsZXQgcj12ZSgpO3JldHVybiBVZSgoKT0+e3IuY3VycmVudD1lfSxbZV0pLHIuY3VycmVudH12YXIgc2U9SGU7dmFyIF89bmV3IE1hcDtmdW5jdGlvbiBWZSh7ZGVmYXVsdFZhbHVlOmUsZGVmYXVsdExhbmd1YWdlOnIsZGVmYXVsdFBhdGg6bix2YWx1ZTp0LGxhbmd1YWdlOmEscGF0aDptLHRoZW1lOkU9XCJsaWdodFwiLGxpbmU6Zyxsb2FkaW5nOk49XCJMb2FkaW5nLi4uXCIsb3B0aW9uczp4PXt9LG92ZXJyaWRlU2VydmljZXM6UD17fSxzYXZlVmlld1N0YXRlOnk9ITAsa2VlcEN1cnJlbnRNb2RlbDpWPSExLHdpZHRoOno9XCIxMDAlXCIsaGVpZ2h0OkY9XCIxMDAlXCIsY2xhc3NOYW1lOmosd3JhcHBlclByb3BzOkE9e30sYmVmb3JlTW91bnQ6cT1ELG9uTW91bnQ6TT1ELG9uQ2hhbmdlOk8sb25WYWxpZGF0ZTpUPUR9KXtsZXRbcyx1XT11ZSghMSksW2Msd109dWUoITApLGQ9QyhudWxsKSxvPUMobnVsbCksYj1DKG51bGwpLEw9QyhNKSxVPUMocSksST1DKCksaT1DKHQpLGY9c2UobSksUT1DKCExKSxCPUMoITEpO2soKCk9PntsZXQgcD1OZS5pbml0KCk7cmV0dXJuIHAudGhlbihSPT4oZC5jdXJyZW50PVIpJiZ3KCExKSkuY2F0Y2goUj0+Uj8udHlwZSE9PVwiY2FuY2VsYXRpb25cIiYmY29uc29sZS5lcnJvcihcIk1vbmFjbyBpbml0aWFsaXphdGlvbjogZXJyb3I6XCIsUikpLCgpPT5vLmN1cnJlbnQ/cGUoKTpwLmNhbmNlbCgpfSksbCgoKT0+e2xldCBwPWgoZC5jdXJyZW50LGV8fHR8fFwiXCIscnx8YXx8XCJcIixtfHxufHxcIlwiKTtwIT09by5jdXJyZW50Py5nZXRNb2RlbCgpJiYoeSYmXy5zZXQoZixvLmN1cnJlbnQ/LnNhdmVWaWV3U3RhdGUoKSksby5jdXJyZW50Py5zZXRNb2RlbChwKSx5JiZvLmN1cnJlbnQ/LnJlc3RvcmVWaWV3U3RhdGUoXy5nZXQobSkpKX0sW21dLHMpLGwoKCk9PntvLmN1cnJlbnQ/LnVwZGF0ZU9wdGlvbnMoeCl9LFt4XSxzKSxsKCgpPT57IW8uY3VycmVudHx8dD09PXZvaWQgMHx8KG8uY3VycmVudC5nZXRPcHRpb24oZC5jdXJyZW50LmVkaXRvci5FZGl0b3JPcHRpb24ucmVhZE9ubHkpP28uY3VycmVudC5zZXRWYWx1ZSh0KTp0IT09by5jdXJyZW50LmdldFZhbHVlKCkmJihCLmN1cnJlbnQ9ITAsby5jdXJyZW50LmV4ZWN1dGVFZGl0cyhcIlwiLFt7cmFuZ2U6by5jdXJyZW50LmdldE1vZGVsKCkuZ2V0RnVsbE1vZGVsUmFuZ2UoKSx0ZXh0OnQsZm9yY2VNb3ZlTWFya2VyczohMH1dKSxvLmN1cnJlbnQucHVzaFVuZG9TdG9wKCksQi5jdXJyZW50PSExKSl9LFt0XSxzKSxsKCgpPT57bGV0IHA9by5jdXJyZW50Py5nZXRNb2RlbCgpO3AmJmEmJmQuY3VycmVudD8uZWRpdG9yLnNldE1vZGVsTGFuZ3VhZ2UocCxhKX0sW2FdLHMpLGwoKCk9PntnIT09dm9pZCAwJiZvLmN1cnJlbnQ/LnJldmVhbExpbmUoZyl9LFtnXSxzKSxsKCgpPT57ZC5jdXJyZW50Py5lZGl0b3Iuc2V0VGhlbWUoRSl9LFtFXSxzKTtsZXQgWD1fZSgoKT0+e2lmKCEoIWIuY3VycmVudHx8IWQuY3VycmVudCkmJiFRLmN1cnJlbnQpe1UuY3VycmVudChkLmN1cnJlbnQpO2xldCBwPW18fG4sUj1oKGQuY3VycmVudCx0fHxlfHxcIlwiLHJ8fGF8fFwiXCIscHx8XCJcIik7by5jdXJyZW50PWQuY3VycmVudD8uZWRpdG9yLmNyZWF0ZShiLmN1cnJlbnQse21vZGVsOlIsYXV0b21hdGljTGF5b3V0OiEwLC4uLnh9LFApLHkmJm8uY3VycmVudC5yZXN0b3JlVmlld1N0YXRlKF8uZ2V0KHApKSxkLmN1cnJlbnQuZWRpdG9yLnNldFRoZW1lKEUpLGchPT12b2lkIDAmJm8uY3VycmVudC5yZXZlYWxMaW5lKGcpLHUoITApLFEuY3VycmVudD0hMH19LFtlLHIsbix0LGEsbSx4LFAseSxFLGddKTtXKCgpPT57cyYmTC5jdXJyZW50KG8uY3VycmVudCxkLmN1cnJlbnQpfSxbc10pLFcoKCk9PnshYyYmIXMmJlgoKX0sW2MscyxYXSksaS5jdXJyZW50PXQsVygoKT0+e3MmJk8mJihJLmN1cnJlbnQ/LmRpc3Bvc2UoKSxJLmN1cnJlbnQ9by5jdXJyZW50Py5vbkRpZENoYW5nZU1vZGVsQ29udGVudChwPT57Qi5jdXJyZW50fHxPKG8uY3VycmVudC5nZXRWYWx1ZSgpLHApfSkpfSxbcyxPXSksVygoKT0+e2lmKHMpe2xldCBwPWQuY3VycmVudC5lZGl0b3Iub25EaWRDaGFuZ2VNYXJrZXJzKFI9PntsZXQgRz1vLmN1cnJlbnQuZ2V0TW9kZWwoKT8udXJpO2lmKEcmJlIuZmluZChKPT5KLnBhdGg9PT1HLnBhdGgpKXtsZXQgSj1kLmN1cnJlbnQuZWRpdG9yLmdldE1vZGVsTWFya2Vycyh7cmVzb3VyY2U6R30pO1Q/LihKKX19KTtyZXR1cm4oKT0+e3A/LmRpc3Bvc2UoKX19cmV0dXJuKCk9Pnt9fSxbcyxUXSk7ZnVuY3Rpb24gcGUoKXtJLmN1cnJlbnQ/LmRpc3Bvc2UoKSxWP3kmJl8uc2V0KG0sby5jdXJyZW50LnNhdmVWaWV3U3RhdGUoKSk6by5jdXJyZW50LmdldE1vZGVsKCk/LmRpc3Bvc2UoKSxvLmN1cnJlbnQuZGlzcG9zZSgpfXJldHVybiBXZS5jcmVhdGVFbGVtZW50KEgse3dpZHRoOnosaGVpZ2h0OkYsaXNFZGl0b3JSZWFkeTpzLGxvYWRpbmc6TixfcmVmOmIsY2xhc3NOYW1lOmosd3JhcHBlclByb3BzOkF9KX12YXIgZmU9VmU7dmFyIGRlPXplKGZlKTt2YXIgRnQ9ZGU7ZXhwb3J0e3dlIGFzIERpZmZFZGl0b3IsZGUgYXMgRWRpdG9yLEZ0IGFzIGRlZmF1bHQsX3QgYXMgbG9hZGVyLExlIGFzIHVzZU1vbmFjb307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIl9fcmVzdCIsInMiLCJlIiwidCIsInAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJTdXBwcmVzc2VkRXJyb3IiLCJlcnJvciIsInN1cHByZXNzZWQiLCJtZXNzYWdlIiwiRXJyb3IiLCJuYW1lIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwibXNnIiwiRkxPQVQzMl9NQVgiLCJGTE9BVDMyX01JTiIsIlVJTlQzMl9NQVgiLCJJTlQzMl9NQVgiLCJJTlQzMl9NSU4iLCJhc3NlcnRJbnQzMiIsImFyZyIsIk51bWJlciIsImlzSW50ZWdlciIsImFzc2VydFVJbnQzMiIsImFzc2VydEZsb2F0MzIiLCJpc0Zpbml0ZSIsImVudW1UeXBlU3ltYm9sIiwiU3ltYm9sIiwiZ2V0RW51bVR5cGUiLCJlbnVtT2JqZWN0Iiwic2V0RW51bVR5cGUiLCJ0eXBlTmFtZSIsInZhbHVlcyIsIm9wdCIsIm1ha2VFbnVtVHlwZSIsIm1hcCIsInYiLCJubyIsImxvY2FsTmFtZSIsIl9vcHQiLCJuYW1lcyIsImNyZWF0ZSIsIm51bWJlcnMiLCJub3JtYWxWYWx1ZXMiLCJuIiwibm9ybWFsaXplRW51bVZhbHVlIiwicHVzaCIsImZpbmROYW1lIiwiZmluZE51bWJlciIsIm1ha2VFbnVtIiwiYXNzaWduIiwiTWVzc2FnZSIsImVxdWFscyIsIm90aGVyIiwiZ2V0VHlwZSIsInJ1bnRpbWUiLCJ1dGlsIiwiY2xvbmUiLCJmcm9tQmluYXJ5IiwiYnl0ZXMiLCJvcHRpb25zIiwidHlwZSIsImZvcm1hdCIsImJpbiIsIm1ha2VSZWFkT3B0aW9ucyIsInJlYWRNZXNzYWdlIiwicmVhZGVyRmFjdG9yeSIsImJ5dGVMZW5ndGgiLCJmcm9tSnNvbiIsImpzb25WYWx1ZSIsImpzb24iLCJmcm9tSnNvblN0cmluZyIsImpzb25TdHJpbmciLCJKU09OIiwicGFyc2UiLCJTdHJpbmciLCJ0b0JpbmFyeSIsIm1ha2VXcml0ZU9wdGlvbnMiLCJ3cml0ZXIiLCJ3cml0ZXJGYWN0b3J5Iiwid3JpdGVNZXNzYWdlIiwiZmluaXNoIiwidG9Kc29uIiwidG9Kc29uU3RyaW5nIiwiX2EiLCJzdHJpbmdpZnkiLCJwcmV0dHlTcGFjZXMiLCJ0b0pTT04iLCJlbWl0RGVmYXVsdFZhbHVlcyIsImdldFByb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCJtYWtlTWVzc2FnZVR5cGUiLCJmaWVsZHMiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsImRhdGEiLCJpbml0RmllbGRzIiwiaW5pdFBhcnRpYWwiLCJzZXRQcm90b3R5cGVPZiIsIm5ld0ZpZWxkTGlzdCIsImEiLCJiIiwibWFrZVByb3RvUnVudGltZSIsInN5bnRheCIsIlNjYWxhclR5cGUiLCJMb25nVHlwZSIsInZhcmludDY0cmVhZCIsImxvd0JpdHMiLCJoaWdoQml0cyIsInNoaWZ0IiwiYnVmIiwicG9zIiwiYXNzZXJ0Qm91bmRzIiwibWlkZGxlQnl0ZSIsInZhcmludDY0d3JpdGUiLCJsbyIsImhpIiwiaGFzTmV4dCIsImJ5dGUiLCJzcGxpdEJpdHMiLCJoYXNNb3JlQml0cyIsIlRXT19QV1JfMzJfREJMIiwiaW50NjRGcm9tU3RyaW5nIiwiZGVjIiwibWludXMiLCJzbGljZSIsImJhc2UiLCJhZGQxZTZkaWdpdCIsImJlZ2luIiwiZW5kIiwiZGlnaXQxZTYiLCJuZWdhdGUiLCJuZXdCaXRzIiwiaW50NjRUb1N0cmluZyIsImJpdHMiLCJuZWdhdGl2ZSIsInVJbnQ2NFRvU3RyaW5nIiwidG9VbnNpZ25lZCIsImxvdyIsIm1pZCIsImhpZ2giLCJkaWdpdEEiLCJkaWdpdEIiLCJkaWdpdEMiLCJNYXRoIiwiZmxvb3IiLCJ0b1N0cmluZyIsImRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyIsImRpZ2l0MWU3IiwicGFydGlhbCIsInZhcmludDMyd3JpdGUiLCJ2YXJpbnQzMnJlYWQiLCJyZWFkQnl0ZXMiLCJtYWtlSW50NjRTdXBwb3J0IiwiZHYiLCJEYXRhVmlldyIsIkFycmF5QnVmZmVyIiwib2siLCJCaWdJbnQiLCJnZXRCaWdJbnQ2NCIsImdldEJpZ1VpbnQ2NCIsInNldEJpZ0ludDY0Iiwic2V0QmlnVWludDY0IiwicHJvY2VzcyIsImVudiIsIkJVRl9CSUdJTlRfRElTQUJMRSIsIk1JTiIsIk1BWCIsIlVNSU4iLCJVTUFYIiwiemVybyIsInN1cHBvcnRlZCIsImJpIiwidVBhcnNlIiwiZW5jIiwiZ2V0SW50MzIiLCJ1RW5jIiwic2V0SW50MzIiLCJ1RGVjIiwiYXNzZXJ0SW50NjRTdHJpbmciLCJ0ZXN0IiwiYXNzZXJ0VUludDY0U3RyaW5nIiwicHJvdG9JbnQ2NCIsIldpcmVUeXBlIiwiQmluYXJ5V3JpdGVyIiwidGV4dEVuY29kZXIiLCJzdGFjayIsIlRleHRFbmNvZGVyIiwiY2h1bmtzIiwiVWludDhBcnJheSIsImxlbiIsIm9mZnNldCIsInNldCIsImZvcmsiLCJqb2luIiwiY2h1bmsiLCJwcmV2IiwicG9wIiwidWludDMyIiwicmF3IiwidGFnIiwiZmllbGRObyIsImludDMyIiwiYm9vbCIsInN0cmluZyIsImVuY29kZSIsImZsb2F0IiwiYnVmZmVyIiwic2V0RmxvYXQzMiIsImRvdWJsZSIsInNldEZsb2F0NjQiLCJmaXhlZDMyIiwic2V0VWludDMyIiwic2ZpeGVkMzIiLCJzaW50MzIiLCJzZml4ZWQ2NCIsInZpZXciLCJ0YyIsImZpeGVkNjQiLCJpbnQ2NCIsInNpbnQ2NCIsInNpZ24iLCJ1aW50NjQiLCJCaW5hcnlSZWFkZXIiLCJ0ZXh0RGVjb2RlciIsInZhcmludDY0IiwiYnl0ZU9mZnNldCIsIlRleHREZWNvZGVyIiwid2lyZVR5cGUiLCJza2lwIiwic3RhcnQiLCJWYXJpbnQiLCJCaXQ2NCIsIkJpdDMyIiwiTGVuZ3RoRGVsaW1pdGVkIiwiU3RhcnRHcm91cCIsIkVuZEdyb3VwIiwic3ViYXJyYXkiLCJSYW5nZUVycm9yIiwienplIiwiZ2V0VWludDMyIiwiZ2V0RmxvYXQzMiIsImdldEZsb2F0NjQiLCJkZWNvZGUiLCJ3cmFwRmllbGQiLCJmaWVsZFdyYXBwZXIiLCJET1VCTEUiLCJGTE9BVCIsIklOVDY0IiwiVUlOVDY0IiwiSU5UMzIiLCJVSU5UMzIiLCJCT09MIiwiU1RSSU5HIiwiQllURVMiLCJzY2FsYXJFcXVhbHMiLCJGSVhFRDY0IiwiU0ZJWEVENjQiLCJTSU5UNjQiLCJzY2FsYXJEZWZhdWx0VmFsdWUiLCJsb25nVHlwZSIsInNjYWxhclR5cGVJbmZvIiwiaXNVbmRlZmluZWQiLCJ1bmRlZmluZWQiLCJpc0ludHJpbnNpY0RlZmF1bHQiLCJGSVhFRDMyIiwiU0ZJWEVEMzIiLCJtZXRob2QiLCJ0b0xvd2VyQ2FzZSIsInVua25vd25GaWVsZHNTeW1ib2wiLCJyZWFkRGVmYXVsdHMiLCJyZWFkVW5rbm93bkZpZWxkcyIsIndyaXRlRGVmYXVsdHMiLCJ3cml0ZVVua25vd25GaWVsZHMiLCJtYWtlQmluYXJ5Rm9ybWF0Q29tbW9uIiwibGlzdFVua25vd25GaWVsZHMiLCJkaXNjYXJkVW5rbm93bkZpZWxkcyIsIm0iLCJjIiwiZiIsIm9uVW5rbm93bkZpZWxkIiwiQXJyYXkiLCJpc0FycmF5IiwicmVhZGVyIiwiZmllbGQiLCJmaW5kIiwidGFyZ2V0IiwicmVwZWF0ZWQiLCJvbmVvZiIsImNhc2UiLCJraW5kIiwic2NhbGFyVHlwZSIsIlQiLCJyZWFkIiwicmVhZFNjYWxhciIsIkwiLCJyZWFkU2NhbGFyTFRTdHJpbmciLCJhcnIiLCJtZXNzYWdlVHlwZSIsInJlYWRNZXNzYWdlRmllbGQiLCJ1bndyYXBGaWVsZCIsIm1hcEtleSIsIm1hcFZhbCIsInJlYWRNYXBFbnRyeSIsImtleSIsInZhbCIsIksiLCJWIiwia2V5UmF3IiwiQklHSU5UIiwiU0lOVDMyIiwid3JpdGVNYXBFbnRyeSIsImtleVZhbHVlIiwicGFyc2VJbnQiLCJ3cml0ZVNjYWxhciIsIndyaXRlTWVzc2FnZUZpZWxkIiwiZW1pdEludHJpbnNpY0RlZmF1bHQiLCJ3cml0ZVBhY2tlZCIsIm1ha2VCaW5hcnlGb3JtYXRQcm90bzMiLCJieU51bWJlciIsInBhY2tlZCIsIml0ZW0iLCJlbnRyaWVzIiwiZW5jVGFibGUiLCJzcGxpdCIsImRlY1RhYmxlIiwiY2hhckNvZGVBdCIsInByb3RvQmFzZTY0IiwiYmFzZTY0U3RyIiwiZXMiLCJieXRlUG9zIiwiZ3JvdXBQb3MiLCJiYXNlNjQiLCJqc29uUmVhZERlZmF1bHRzIiwiaWdub3JlVW5rbm93bkZpZWxkcyIsImpzb25Xcml0ZURlZmF1bHRzIiwiZW51bUFzSW50ZWdlciIsInVzZVByb3RvRmllbGROYW1lIiwibWFrZUpzb25Gb3JtYXRDb21tb24iLCJtYWtlV3JpdGVGaWVsZCIsIndyaXRlRmllbGQiLCJ3cml0ZUVudW0iLCJkZWJ1ZyIsIm9uZW9mU2VlbiIsImpzb25LZXkiLCJmaW5kSnNvbk5hbWUiLCJzZWVuIiwidGFyZ2V0QXJyYXkiLCJqc29uSXRlbSIsInJlYWRFbnVtIiwidGFyZ2V0TWFwIiwianNvbk1hcEtleSIsImpzb25NYXBWYWx1ZSIsImVudW1WYWx1ZSIsIm1lbWJlciIsImJ5TWVtYmVyIiwiZmluZEZpZWxkIiwianNvbk5hbWUiLCJyIiwiZGVidWdKc29uVmFsdWUiLCJOYU4iLCJQT1NJVElWRV9JTkZJTklUWSIsIk5FR0FUSVZFX0lORklOSVRZIiwidHJpbSIsImlzTmFOIiwibG9uZyIsInVMb25nIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibWFrZUpzb25Gb3JtYXRQcm90bzMiLCJqc29uT2JqIiwiZW50cnlLZXkiLCJlbnRyeVZhbHVlIiwiZW51bVR5cGUiLCJrZXlzIiwianNvbkFyciIsIm1ha2VVdGlsQ29tbW9uIiwic291cmNlIiwic2siLCJzb3VyY2VGaWVsZCIsInRvVThBcnIiLCJjb3B5IiwiayIsIm10IiwiZXZlcnkiLCJ2YSIsInZiIiwiY29uY2F0IiwiYW55IiwiY2xvbmVTaW5ndWxhckZpZWxkIiwiaW5wdXQiLCJJbnRlcm5hbEZpZWxkTGlzdCIsIm5vcm1hbGl6ZXIiLCJfZmllbGRzIiwiX25vcm1hbGl6ZXIiLCJqc29uTmFtZXMiLCJsaXN0IiwiYWxsIiwibnVtYmVyc0FzYyIsInNvcnQiLCJtZW1iZXJzIiwibyIsImxvY2FsRmllbGROYW1lIiwicHJvdG9OYW1lIiwiaW5PbmVvZiIsInByb3RvQ2FtZWxDYXNlIiwic2FmZU9iamVjdFByb3BlcnR5Iiwic2FmZU1lc3NhZ2VQcm9wZXJ0eSIsImxvY2FsT25lb2ZOYW1lIiwiZmllbGRKc29uTmFtZSIsInNuYWtlQ2FzZSIsImNhcE5leHQiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInJlc2VydmVkT2JqZWN0UHJvcGVydGllcyIsIlNldCIsInJlc2VydmVkTWVzc2FnZVByb3BlcnRpZXMiLCJmYWxsYmFjayIsImhhcyIsIkludGVybmFsT25lb2ZJbmZvIiwiZGVmYXVsdCIsImFkZEZpZWxkIiwiX2xvb2t1cCIsInByb3RvMyIsIm5vcm1hbGl6ZUZpZWxkSW5mb3NQcm90bzMiLCJmaWVsZEluZm9zIiwiX2IiLCJfYyIsIl9kIiwib29uYW1lIiwiTWV0aG9kS2luZCIsIk1ldGhvZElkZW1wb3RlbmN5IiwiQ29kZSIsImNvZGVUb1N0cmluZyIsInJlcGxhY2UiLCJzdHJpbmdUb0NvZGUiLCJjb2RlRnJvbVN0cmluZyIsIkNvbm5lY3RFcnJvciIsImNvZGUiLCJVbmtub3duIiwibWV0YWRhdGEiLCJvdXRnb2luZ0RldGFpbHMiLCJjYXVzZSIsImNyZWF0ZU1lc3NhZ2UiLCJyYXdNZXNzYWdlIiwiSGVhZGVycyIsImRldGFpbHMiLCJmcm9tIiwicmVhc29uIiwiQ2FuY2VsZWQiLCJmaW5kRGV0YWlscyIsInR5cGVPclJlZ2lzdHJ5IiwicmVnaXN0cnkiLCJmaW5kTWVzc2FnZSIsIl8iLCJhcHBlbmRIZWFkZXJzIiwiaGVhZGVycyIsImgiLCJmb3JFYWNoIiwiYXBwZW5kIiwibWFrZUFueUNsaWVudCIsInNlcnZpY2UiLCJjcmVhdGVNZXRob2QiLCJjbGllbnQiLCJtZXRob2RJbmZvIiwibWV0aG9kcyIsImNyZWF0ZUVudmVsb3BlUmVhZGFibGVTdHJlYW0iLCJzdHJlYW0iLCJSZWFkYWJsZVN0cmVhbSIsImdldFJlYWRlciIsInB1bGwiLCJjb250cm9sbGVyIiwiaGVhZGVyIiwiZmxhZ3MiLCJjbG9zZSIsIkRhdGFMb3NzIiwiZW5xdWV1ZSIsImVuY29kZUVudmVsb3BlIiwic2V0VWludDgiLCJfX2FzeW5jVmFsdWVzIiwidGhpcyIsImFzeW5jSXRlcmF0b3IiLCJUeXBlRXJyb3IiLCJfX3ZhbHVlcyIsIml0ZXJhdG9yIiwidmVyYiIsInNldHRsZSIsImQiLCJfX2F3YWl0IiwiX19hc3luY0dlbmVyYXRvciIsImciLCJxIiwicmVzdW1lIiwiZnVsZmlsbCIsIl9fYXN5bmNEZWxlZ2F0b3IiLCJjcmVhdGVBc3luY0l0ZXJhYmxlIiwiaXRlbXMiLCJhcmd1bWVudHMiLCJjcmVhdGVBc3luY0l0ZXJhYmxlXzEiLCJjcmVhdGVQcm9taXNlQ2xpZW50IiwidHJhbnNwb3J0IiwiVW5hcnkiLCJjcmVhdGVVbmFyeUZuIiwiU2VydmVyU3RyZWFtaW5nIiwiY3JlYXRlU2VydmVyU3RyZWFtaW5nRm4iLCJDbGllbnRTdHJlYW1pbmciLCJjcmVhdGVDbGllbnRTdHJlYW1pbmdGbiIsIkJpRGlTdHJlYW1pbmciLCJjcmVhdGVCaURpU3RyZWFtaW5nRm4iLCJyZXNwb25zZSIsInVuYXJ5Iiwic2lnbmFsIiwidGltZW91dE1zIiwiY29udGV4dFZhbHVlcyIsIm9uSGVhZGVyIiwib25UcmFpbGVyIiwidHJhaWxlciIsImhhbmRsZVN0cmVhbVJlc3BvbnNlIiwicmVxdWVzdCIsImVfMSIsIl9lIiwic2luZ2xlTWVzc2FnZSIsIl9mIiwiX2ciLCJfaCIsImVfMV8xIiwicmV0dXJuIiwiSW50ZXJuYWwiLCJpdCIsImNyZWF0ZUxpbmtlZEFib3J0Q29udHJvbGxlciIsInNpZ25hbHMiLCJBYm9ydENvbnRyb2xsZXIiLCJzYSIsImZpbHRlciIsImFib3J0ZWQiLCJvbkFib3J0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImFib3J0IiwiZ2V0QWJvcnRTaWduYWxSZWFzb24iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY3JlYXRlRGVhZGxpbmVTaWduYWwiLCJsaXN0ZW5lciIsIkRlYWRsaW5lRXhjZWVkZWQiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiY2xlYW51cCIsImNsZWFyVGltZW91dCIsImNyZWF0ZUNvbnRleHRWYWx1ZXMiLCJnZXQiLCJpZCIsImRlZmF1bHRWYWx1ZSIsImRlbGV0ZSIsImNyZWF0ZU1ldGhvZFVybCIsImJhc2VVcmwiLCJub3JtYWxpemUiLCJub3JtYWxpemVJdGVyYWJsZSIsInRyYW5zZm9ybSIsInJlcyIsInRocm93IiwiZ2V0SnNvbk9wdGlvbnMiLCJjcmVhdGVDbGllbnRNZXRob2RTZXJpYWxpemVycyIsInVzZUJpbmFyeUZvcm1hdCIsImpzb25PcHRpb25zIiwiYmluYXJ5T3B0aW9ucyIsImNyZWF0ZUJpbmFyeVNlcmlhbGl6YXRpb24iLCJJIiwiY3JlYXRlSnNvblNlcmlhbGl6YXRpb24iLCJvdXRwdXQiLCJPIiwic2VyaWFsaXplIiwiSW52YWxpZEFyZ3VtZW50IiwiY29udGVudFR5cGVSZWdFeHAiLCJjb250ZW50VHlwZVVuYXJ5UHJvdG8iLCJjb250ZW50VHlwZVVuYXJ5SnNvbiIsImNvbnRlbnRUeXBlU3RyZWFtUHJvdG8iLCJjb250ZW50VHlwZVN0cmVhbUpzb24iLCJwYXJzZUNvbnRlbnRUeXBlIiwiY29udGVudFR5cGUiLCJtYXRjaCIsImJpbmFyeSIsImVycm9yRnJvbUpzb24iLCJkZXRhaWwiLCJlbmRTdHJlYW1GbGFnIiwiZW5kU3RyZWFtRnJvbUpzb24iLCJwYXJzZUVyciIsInNvbWUiLCJoZWFkZXJDb250ZW50VHlwZSIsImhlYWRlclVuYXJ5Q29udGVudExlbmd0aCIsImhlYWRlclVuYXJ5RW5jb2RpbmciLCJoZWFkZXJVbmFyeUFjY2VwdEVuY29kaW5nIiwiaGVhZGVyVGltZW91dCIsImhlYWRlclByb3RvY29sVmVyc2lvbiIsImhlYWRlclVzZXJBZ2VudCIsImNvZGVGcm9tSHR0cFN0YXR1cyIsImh0dHBTdGF0dXMiLCJVbmF1dGhlbnRpY2F0ZWQiLCJQZXJtaXNzaW9uRGVuaWVkIiwiVW5pbXBsZW1lbnRlZCIsIkFib3J0ZWQiLCJGYWlsZWRQcmVjb25kaXRpb24iLCJSZXNvdXJjZUV4aGF1c3RlZCIsIlVuYXZhaWxhYmxlIiwidHJhaWxlckRlbXV4Iiwic3RhcnRzV2l0aCIsInByb3RvY29sVmVyc2lvbiIsInJlcXVlc3RIZWFkZXIiLCJtZXRob2RLaW5kIiwidXNlclByb3ZpZGVkSGVhZGVycyIsInZhbGlkYXRlUmVzcG9uc2UiLCJzdGF0dXMiLCJtaW1lVHlwZSIsInBhcnNlZFR5cGUiLCJlcnJvckZyb21TdGF0dXMiLCJpc1VuYXJ5RXJyb3IiLCJ1bmFyeUVycm9yIiwiY29udGVudFR5cGVQcmVmaXgiLCJlbmNvZGVNZXNzYWdlRm9yVXJsIiwidXNlQmFzZTY0IiwidHJhbnNmb3JtQ29ubmVjdFBvc3RUb0dldFJlcXVlc3QiLCJxdWVyeSIsImNvbXByZXNzaW9uIiwidXJsIiwiaW5pdCIsInJ1blVuYXJ5Q2FsbCIsImFwcGx5SW50ZXJjZXB0b3JzIiwiaW50ZXJjZXB0b3JzIiwic2V0dXBTaWduYWwiLCJyZXEiLCJydW5TdHJlYW1pbmdDYWxsIiwiZG9uZUNhbGxlZCIsImNhdGNoIiwicmV2ZXJzZSIsInJlZHVjZSIsImFzc2VydEZldGNoQXBpIiwiY3JlYXRlQ29ubmVjdFRyYW5zcG9ydCIsImRlZmF1bHRUaW1lb3V0TXMiLCJjcmVkZW50aWFscyIsInJlZGlyZWN0IiwibW9kZSIsInVzZUdldCIsInVzZUh0dHBHZXQiLCJpZGVtcG90ZW5jeSIsIk5vU2lkZUVmZmVjdHMiLCJib2R5IiwiZmV0Y2giLCJnbG9iYWxUaGlzIiwiZGVtdXhlZEhlYWRlciIsImRlbXV4ZWRUcmFpbGVyIiwiYXJyYXlCdWZmZXIiLCJwYXJzZVJlc3BvbnNlQm9keSIsInRyYWlsZXJUYXJnZXQiLCJwYXJzZVJlc3BvbnNlQm9keV8xIiwiZW5kU3RyZWFtUmVjZWl2ZWQiLCJlbmRTdHJlYW0iLCJjcmVhdGVSZXF1ZXN0Qm9keSIsImZSZXMiLCJTdGF0dXMiLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsInN5bWJvbHMiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfb2JqZWN0U3ByZWFkMiIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJleGNsdWRlZCIsInNvdXJjZUtleXMiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2VTeW1ib2xLZXlzIiwiX3NsaWNlZFRvQXJyYXkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiX2FyciIsIl9uIiwiX2kiLCJfcyIsImVyciIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwiYXJyMiIsImNvbXBvc2UiLCJfbGVuIiwiZm5zIiwiX2tleSIsIngiLCJyZWR1Y2VSaWdodCIsInkiLCJjdXJyeSIsImZuIiwiY3VycmllZCIsIl90aGlzIiwiX2xlbjIiLCJhcmdzIiwiX2tleTIiLCJfbGVuMyIsIm5leHRBcmdzIiwiX2tleTMiLCJpc09iamVjdCIsImluY2x1ZGVzIiwiaXNFbXB0eSIsImlzRnVuY3Rpb24iLCJwcm9wZXJ0eSIsInZhbGlkYXRlQ2hhbmdlcyIsImluaXRpYWwiLCJjaGFuZ2VzIiwiZXJyb3JIYW5kbGVyIiwidmFsaWRhdGVTZWxlY3RvciIsInNlbGVjdG9yIiwidmFsaWRhdGVIYW5kbGVyIiwiaGFuZGxlciIsIl9oYW5kbGVyIiwidmFsaWRhdGVJbml0aWFsIiwidGhyb3dFcnJvciIsImVycm9yTWVzc2FnZXMiLCJpbml0aWFsSXNSZXF1aXJlZCIsImluaXRpYWxUeXBlIiwiaW5pdGlhbENvbnRlbnQiLCJoYW5kbGVyVHlwZSIsImhhbmRsZXJzVHlwZSIsInNlbGVjdG9yVHlwZSIsImNoYW5nZVR5cGUiLCJjaGFuZ2VGaWVsZCIsInZhbGlkYXRvcnMiLCJzdGF0ZSIsImN1cnJlbnQiLCJkaWRVcGRhdGUiLCJkaWRTdGF0ZVVwZGF0ZSIsInVwZGF0ZSIsInVwZGF0ZVN0YXRlIiwidmFsaWRhdGUiLCJnZXRDaGFuZ2VzIiwiZXh0cmFjdENoYW5nZXMiLCJnZXRTdGF0ZSIsInNldFN0YXRlIiwiY2F1c2VkQ2hhbmdlcyIsIl9oYW5kbGVyJGZpZWxkIiwiaW5kZXgiLCJjb25maWciLCJwYXRocyIsInZzIiwidmFsaWRhdGVDb25maWciLCJ1cmxzIiwiaW5mb3JtQWJvdXREZXByZWNhdGlvbiIsIm1vbmFjb0Jhc2UiLCJjb25zb2xlIiwid2FybiIsImRlcHJlY2F0aW9uIiwiY29uZmlnSXNSZXF1aXJlZCIsImNvbmZpZ1R5cGUiLCJtZXJnZSIsIkNBTkNFTEFUSU9OX01FU1NBR0UiLCJtYWtlQ2FuY2VsYWJsZSIsInByb21pc2UiLCJoYXNDYW5jZWxlZF8iLCJ3cmFwcGVkUHJvbWlzZSIsImNhbmNlbCIsIl9zdGF0ZSRjcmVhdGUiLCJjb25maWckMSIsImlzSW5pdGlhbGl6ZWQiLCJtb25hY28iLCJfc3RhdGUkY3JlYXRlMiIsImdsb2JhbENvbmZpZyIsIl92YWxpZGF0b3JzJGNvbmZpZyIsIl9yZWYiLCJ3cmFwcGVyUHJvbWlzZSIsIndpbmRvdyIsImVkaXRvciIsInN0b3JlTW9uYWNvSW5zdGFuY2UiLCJpbmplY3RTY3JpcHRzIiwiZ2V0TW9uYWNvTG9hZGVyU2NyaXB0IiwiY29uZmlndXJlTG9hZGVyIiwic2NyaXB0IiwiZG9jdW1lbnQiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVNjcmlwdCIsInNyYyIsImNyZWF0ZUVsZW1lbnQiLCJfcmVmMiIsImxvYWRlclNjcmlwdCIsIm9ubG9hZCIsIm9uZXJyb3IiLCJfcmVmMyIsInJlcXVpcmUiLCJfX2dldE1vbmFjb0luc3RhbmNlIiwiX3JlZjQiLCJsb2FkZXIiLCJsZSIsIndyYXBwZXIiLCJkaXNwbGF5IiwicG9zaXRpb24iLCJ0ZXh0QWxpZ24iLCJmdWxsV2lkdGgiLCJ3aWR0aCIsImhpZGUiLCJhZSIsImNvbnRhaW5lciIsImhlaWdodCIsImp1c3RpZnlDb250ZW50IiwiYWxpZ25JdGVtcyIsIlkiLCJNZSIsImNoaWxkcmVuIiwibWUiLCJzdHlsZSIsIloiLCIkIiwiRWUiLCJpc0VkaXRvclJlYWR5IiwibG9hZGluZyIsImNsYXNzTmFtZSIsIndyYXBwZXJQcm9wcyIsIkUiLCJyZWYiLCJlZSIsIkgiLCJ5ZSIsIkNlIiwieGUiLCJoZSIsIlJlIiwiZ2UiLCJsIiwiRCIsIkRlIiwiYmUiLCJnZXRNb2RlbCIsInRlIiwiY3JlYXRlTW9kZWwiLCJVcmkiLCJPZSIsIm9yaWdpbmFsIiwibW9kaWZpZWQiLCJsYW5ndWFnZSIsIm9yaWdpbmFsTGFuZ3VhZ2UiLCJtb2RpZmllZExhbmd1YWdlIiwib3JpZ2luYWxNb2RlbFBhdGgiLCJtb2RpZmllZE1vZGVsUGF0aCIsImtlZXBDdXJyZW50T3JpZ2luYWxNb2RlbCIsImtlZXBDdXJyZW50TW9kaWZpZWRNb2RlbCIsIk4iLCJ0aGVtZSIsInoiLCJGIiwiaiIsImJlZm9yZU1vdW50IiwiQSIsIm9uTW91bnQiLCJNIiwicmUiLCJ1IiwiUyIsInciLCJTZSIsImdldE9yaWdpbmFsRWRpdG9yIiwic2V0TW9kZWwiLCJnZXRNb2RpZmllZEVkaXRvciIsImdldE9wdGlvbiIsIkVkaXRvck9wdGlvbiIsInJlYWRPbmx5Iiwic2V0VmFsdWUiLCJnZXRWYWx1ZSIsImV4ZWN1dGVFZGl0cyIsInJhbmdlIiwiZ2V0RnVsbE1vZGVsUmFuZ2UiLCJ0ZXh0IiwiZm9yY2VNb3ZlTWFya2VycyIsInB1c2hVbmRvU3RvcCIsInNldE1vZGVsTGFuZ3VhZ2UiLCJzZXRUaGVtZSIsInVwZGF0ZU9wdGlvbnMiLCJvZSIsIlUiLCJjcmVhdGVEaWZmRWRpdG9yIiwiYXV0b21hdGljTGF5b3V0IiwibmUiLCJkaXNwb3NlIiwia2UiLCJpZSIsIlRlIiwiSGUiLCJ2ZSIsIlVlIiwic2UiLCJNYXAiLCJWZSIsImRlZmF1bHRMYW5ndWFnZSIsImRlZmF1bHRQYXRoIiwicGF0aCIsImxpbmUiLCJvdmVycmlkZVNlcnZpY2VzIiwic2F2ZVZpZXdTdGF0ZSIsImtlZXBDdXJyZW50TW9kZWwiLCJvbkNoYW5nZSIsIm9uVmFsaWRhdGUiLCJ1ZSIsIkMiLCJRIiwiQiIsIk5lIiwiUiIsInBlIiwicmVzdG9yZVZpZXdTdGF0ZSIsInJldmVhbExpbmUiLCJYIiwibW9kZWwiLCJXIiwib25EaWRDaGFuZ2VNb2RlbENvbnRlbnQiLCJvbkRpZENoYW5nZU1hcmtlcnMiLCJHIiwidXJpIiwiSiIsImdldE1vZGVsTWFya2VycyIsInJlc291cmNlIiwiV2UiLCJmZSIsImRlIiwiemUiLCJGdCIsImdldERlZmF1bHRWYWx1ZSIsIkV4cGVyaW1lbnRLZXkiLCJBdXRoU291cmNlIiwiRXZlbnRUeXBlIiwiQ29tcGxldGlvblNvdXJjZSIsIkxhbmd1YWdlIiwiQ29tcGxldGlvbiIsImNvbXBsZXRpb25JZCIsInByZWZpeCIsInN0b3AiLCJzY29yZSIsInRva2VucyIsImRlY29kZWRUb2tlbnMiLCJwcm9iYWJpbGl0aWVzIiwiYWRqdXN0ZWRQcm9iYWJpbGl0aWVzIiwiZ2VuZXJhdGVkTGVuZ3RoIiwiTWV0YWRhdGEiLCJpZGVOYW1lIiwiaWRlVmVyc2lvbiIsImV4dGVuc2lvbk5hbWUiLCJleHRlbnNpb25WZXJzaW9uIiwiYXBpS2V5IiwibG9jYWxlIiwic2Vzc2lvbklkIiwicmVxdWVzdElkIiwidXNlckFnZW50IiwiYXV0aFNvdXJjZSIsIkNPREVJVU0iLCJFZGl0b3JPcHRpb25zIiwidGFiU2l6ZSIsImluc2VydFNwYWNlcyIsIkV2ZW50IiwiZXZlbnRUeXBlIiwiVU5TUEVDSUZJRUQiLCJldmVudEpzb24iLCJ0aW1lc3RhbXBVbml4TXMiLCJDb2RlaXVtU3RhdGUiLCJMaW5lVHlwZSIsIkNvbXBsZXRpb25QYXJ0VHlwZSIsIk11bHRpbGluZUNvbmZpZyIsInRocmVzaG9sZCIsIkdldENvbXBsZXRpb25zUmVxdWVzdCIsIm90aGVyRG9jdW1lbnRzIiwibW9kZWxOYW1lIiwiRG9jdW1lbnQiLCJFeHBlcmltZW50Q29uZmlnIiwiR2V0Q29tcGxldGlvbnNSZXNwb25zZSIsImNvbXBsZXRpb25JdGVtcyIsIlN0YXRlIiwiQ29tcGxldGlvbkl0ZW0iLCJBY2NlcHRDb21wbGV0aW9uUmVxdWVzdCIsIkFjY2VwdENvbXBsZXRpb25SZXNwb25zZSIsIkdldEF1dGhUb2tlblJlcXVlc3QiLCJHZXRBdXRoVG9rZW5SZXNwb25zZSIsImF1dGhUb2tlbiIsInV1aWQiLCJEb2N1bWVudFBvc2l0aW9uIiwicm93IiwiY29sIiwiYWJzb2x1dGVQYXRoIiwicmVsYXRpdmVQYXRoIiwiZWRpdG9yTGFuZ3VhZ2UiLCJjdXJzb3JPZmZzZXQiLCJsaW5lRW5kaW5nIiwiZm9yY2VFbmFibGVFeHBlcmltZW50cyIsIlJhbmdlIiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJTdWZmaXgiLCJkZWx0YUN1cnNvck9mZnNldCIsIkNvbXBsZXRpb25QYXJ0IiwiY29tcGxldGlvblBhcnRzIiwiTGFuZ3VhZ2VTZXJ2ZXJTZXJ2aWNlIiwiZ2V0Q29tcGxldGlvbnMiLCJhY2NlcHRDb21wbGV0aW9uIiwiZ2V0QXV0aFRva2VuIiwiUG9zaXRpb24iLCJjaGFyYWN0ZXIiLCJsaW5lTnVtYmVyIiwiY29sdW1uIiwiZnJvbU1vbmFjbyIsImZyb21Qb3NpdGlvbiIsInN0YXJ0TGluZU51bWJlciIsInN0YXJ0Q29sdW1uIiwiZW5kTGluZU51bWJlciIsImVuZENvbHVtbiIsImZyb21SYW5nZSIsIkxpbmUiLCJsYW5ndWFnZUlkIiwiZ2V0TGFuZ3VhZ2VJZCIsImxpbmVDb3VudCIsImdldExpbmVDb3VudCIsImxpbmVBdCIsInBvc2l0aW9uT3JMaW5lIiwiZ2V0TGluZUNvbnRlbnQiLCJnZXRMaW5lTGVuZ3RoIiwib2Zmc2V0QXQiLCJnZXRPZmZzZXRBdCIsInBvc2l0aW9uQXQiLCJnZXRQb3NpdGlvbkF0IiwiZ2V0VGV4dCIsImdldFZhbHVlSW5SYW5nZSIsIm51bVV0ZjhCeXRlc0ZvckNvZGVQb2ludCIsImNvZGVQb2ludFZhbHVlIiwibnVtQ29kZVVuaXRzVG9OdW1VdGY4Qnl0ZXMiLCJudW1Db2RlVW5pdHMiLCJjdXJOdW1VdGY4Qnl0ZXMiLCJjdXJOdW1Db2RlVW5pdHMiLCJjb2RlUG9pbnQiLCJjb2RlUG9pbnRBdCIsIm51bVV0ZjhCeXRlc1RvTnVtQ29kZVVuaXRzIiwibnVtVXRmOEJ5dGVzIiwicmFuZG9tIiwiZ2V0Q3VycmVudFVSTCIsImxvY2F0aW9uIiwiaHJlZiIsImdldFBhY2thZ2VWZXJzaW9uIiwiQ09ERUlVTV9SRUFDVF9DT0RFX1ZFUlNJT04iLCJsYW5ndWFnZUlkVG9FbnVtIiwiQ0xPSlVSRSIsIkNPRkZFRVNDUklQVCIsIkNQUCIsIkNTSEFSUCIsIkNTUyIsIkNVREFDUFAiLCJET0NLRVJGSUxFIiwiR08iLCJHUk9PVlkiLCJIQU5ETEVCQVJTIiwiSEFTS0VMTCIsIkhDTCIsIkhUTUwiLCJJTkkiLCJKQVZBIiwiSkFWQVNDUklQVCIsIkpVTElBIiwiS09UTElOIiwiTEFURVgiLCJMRVNTIiwiTFVBIiwiTUFLRUZJTEUiLCJNQVJLRE9XTiIsIk9CSkVDVElWRUMiLCJPQkpFQ1RJVkVDUFAiLCJQRVJMIiwiUEhQIiwiUExBSU5URVhUIiwiUFJPVE9CVUYiLCJQQlRYVCIsIlBZVEhPTiIsIlJVQlkiLCJSVVNUIiwiU0FTUyIsIlNDQUxBIiwiU0NTUyIsIlNIRUxMIiwiU1FMIiwiU1RBUkxBUksiLCJTV0lGVCIsIlRTWCIsIlRZUEVTQ1JJUFQiLCJWSVNVQUxCQVNJQyIsIlZVRSIsIlhNTCIsIlhTTCIsIllBTUwiLCJTVkVMVEUiLCJUT01MIiwiREFSVCIsIlJTVCIsIk9DQU1MIiwiQ01BS0UiLCJQQVNDQUwiLCJFTElYSVIiLCJGU0hBUlAiLCJMSVNQIiwiTUFUTEFCIiwiUE9XRVJTSEVMTCIsIlNPTElESVRZIiwiQURBIiwiT0NBTUxfSU5URVJGQUNFIiwiTW9uYWNvSW5saW5lQ29tcGxldGlvbiIsImluc2VydFRleHQiLCJjb21tYW5kIiwidGl0bGUiLCJFRElUT1JfQVBJX0tFWSIsIk1vbmFjb0NvbXBsZXRpb25Qcm92aWRlciIsImdycGNDbGllbnQiLCJzZXRTdGF0dXMiLCJzZXRNZXNzYWdlIiwibXVsdGlsaW5lTW9kZWxUaHJlc2hvbGQiLCJnZXRBdXRoSGVhZGVyIiwiZ2V0TWV0YWRhdGEiLCJBdXRob3JpemF0aW9uIiwicHJvdmlkZUlubGluZUNvbXBsZXRpb25zIiwibW9uYWNvUG9zaXRpb24iLCJ0b2tlbiIsIm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwiY2FuY2VsbGF0aW9uQ2FsbGJhY2siLCJhYm9ydENvbnRyb2xsZXIiLCJQUk9DRVNTSU5HIiwiZG9jdW1lbnRJbmZvIiwiZ2V0RG9jdW1lbnRJbmZvIiwiZWRpdG9yT3B0aW9ucyIsImdldE9wdGlvbnMiLCJpbmNsdWRlZE90aGVyRG9jcyIsIm11bHRpbGluZUNvbmZpZyIsImdldENvbXBsZXRpb25zUmVzcG9uc2UiLCJFUlJPUiIsIlNVQ0NFU1MiLCJpbmxpbmVDb21wbGV0aW9uSXRlbXMiLCJjb21wbGV0aW9uSXRlbSIsImNyZWF0ZUlubGluZUNvbXBsZXRpb25JdGVtIiwiYWNjZXB0ZWRMYXN0Q29tcGxldGlvbiIsImxvZyIsIkRvY3VtZW50SW5mbyIsImNvbXBsZXRpb24iLCJzdGFydFBvc2l0aW9uIiwiZW5kUG9zaXRpb24iLCJpbmxpbmVDb21wbGV0aW9uSXRlbSIsIklubGluZUNvbXBsZXRpb25Qcm92aWRlciIsInNldENvbXBsZXRpb25Db3VudCIsInNldENvZGVpdW1TdGF0dXMiLCJzZXRDb2RlaXVtU3RhdHVzTWVzc2FnZSIsIm51bUNvbXBsZXRpb25zUHJvdmlkZWQiLCJjb21wbGV0aW9uUHJvdmlkZXIiLCJmcmVlSW5saW5lQ29tcGxldGlvbnMiLCJjb250ZXh0IiwiY29tcGxldGlvbnMiLCJ1cGRhdGVPdGhlckRvY3VtZW50cyIsIkNvZGVpdW1Mb2dvIiwicHJvcHMiLCJSZWFjdCIsInZpZXdCb3giLCJmaWxsIiwieG1sbnMiLCJtYXNrVHlwZSIsIm1hc2tVbml0cyIsIm1hc2siLCJhbmltYXRpb25EZWxheSIsImRlZXBNZXJnZSIsIm1lcmdlZCIsIkNvZGVpdW1FZGl0b3IiLCJsYW5ndWFnZVNlcnZlckFkZHJlc3MiLCJjb250YWluZXJDbGFzc05hbWUiLCJjb250YWluZXJTdHlsZSIsImVkaXRvclJlZiIsInVzZVJlZiIsIm1vbmFjb1JlZiIsImlubGluZUNvbXBsZXRpb25zUHJvdmlkZXJSZWYiLCJhY2NlcHRlZENvbXBsZXRpb25Db3VudCIsInNldEFjY2VwdGVkQ29tcGxldGlvbkNvdW50IiwidXNlU3RhdGUiLCJjb21wbGV0aW9uQ291bnQiLCJjb2RlaXVtU3RhdHVzIiwiSU5BQ1RJVkUiLCJjb2RlaXVtU3RhdHVzTWVzc2FnZSIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwidXNlTWVtbyIsInVzZUVmZmVjdCIsInByb3ZpZGVyRGlzcG9zYWJsZSIsImxhbmd1YWdlcyIsInJlZ2lzdGVySW5saW5lQ29tcGxldGlvbnNQcm92aWRlciIsInBhdHRlcm4iLCJjb21wbGV0aW9uRGlzcG9zYWJsZSIsInJlZ2lzdGVyQ29tbWFuZCIsIm9uQXV0b2NvbXBsZXRlIiwiaGFuZGxlRWRpdG9yRGlkTW91bnQiLCJkZWZhdWx0TGFuZ3VhZ2VQcm9wcyIsImxheW91dCIsInJlbCIsInRvcCIsInJpZ2h0IiwiekluZGV4IiwiRWRpdG9yIiwic2Nyb2xsQmV5b25kTGFzdENvbHVtbiIsInNjcm9sbGJhciIsImFsd2F5c0NvbnN1bWVNb3VzZVdoZWVsIiwiY29kZUxlbnMiLCJtaW5pbWFwIiwiZW5hYmxlZCIsInF1aWNrU3VnZ2VzdGlvbnMiLCJmb2xkaW5nIiwiZm9sZGluZ0hpZ2hsaWdodCIsImZvbGRpbmdJbXBvcnRzQnlEZWZhdWx0IiwibGlua3MiLCJmb250U2l6ZSIsIndvcmRXcmFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codeium/react-code-editor/dist/esm/index.js\n");

/***/ })

};
;